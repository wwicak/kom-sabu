{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/index.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/css-calc.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/cache.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/util.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/common.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/constant.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/color.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/css-var.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/relative-color.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/resolve.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/css-gradient.ts","turbopack:///[project]/node_modules/@asamuzakjp/css-color/src/js/convert.ts"],"sourcesContent":["/*!\n * CSS color - Resolve, parse, convert CSS color.\n * @license MIT\n * @copyright asamuzaK (Kazz)\n * @see {@link https://github.com/asamuzaK/cssColor/blob/main/LICENSE}\n */\n\nimport { cssCalc as csscalc } from './js/css-calc';\nimport { isGradient } from './js/css-gradient';\nimport { cssVar } from './js/css-var';\nimport { extractDashedIdent, isColor as iscolor, splitValue } from './js/util';\n\nexport { convert } from './js/convert';\nexport { resolve } from './js/resolve';\n/* utils */\nexport const utils = {\n  cssCalc: csscalc,\n  cssVar,\n  extractDashedIdent,\n  isColor: iscolor,\n  isGradient,\n  splitValue\n};\n/* TODO: remove later */\n/* alias */\nexport const isColor = utils.isColor;\nexport const cssCalc = utils.cssCalc;\n","/**\n * css-calc\n */\n\nimport { calc } from '@csstools/css-calc';\nimport { CSSToken, TokenType, tokenize } from '@csstools/css-tokenizer';\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport { isString, isStringOrNumber } from './common';\nimport { resolveVar } from './css-var';\nimport { roundToPrecision } from './util';\nimport { MatchedRegExp, Options } from './typedef';\n\n/* constants */\nimport {\n  ANGLE,\n  LENGTH,\n  NUM,\n  SYN_FN_CALC,\n  SYN_FN_MATH_START,\n  SYN_FN_VAR,\n  SYN_FN_VAR_START,\n  VAL_SPEC\n} from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  OpenParen: PAREN_OPEN,\n  Whitespace: W_SPACE\n} = TokenType;\nconst NAMESPACE = 'css-calc';\n\n/* numeric constants */\nconst TRIA = 3;\nconst HEX = 16;\nconst MAX_PCT = 100;\n\n/* regexp */\nconst REG_FN_CALC = new RegExp(SYN_FN_CALC);\nconst REG_FN_CALC_NUM = new RegExp(`^calc\\\\((${NUM})\\\\)$`);\nconst REG_FN_MATH_START = new RegExp(SYN_FN_MATH_START);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\nconst REG_FN_VAR_START = new RegExp(SYN_FN_VAR_START);\nconst REG_OPERATOR = /\\s[*+/-]\\s/;\nconst REG_TYPE_DIM = new RegExp(`^(${NUM})(${ANGLE}|${LENGTH})$`);\nconst REG_TYPE_DIM_PCT = new RegExp(`^(${NUM})(${ANGLE}|${LENGTH}|%)$`);\nconst REG_TYPE_PCT = new RegExp(`^(${NUM})%$`);\n\n/**\n * Calclator\n */\nexport class Calculator {\n  /* private */\n  // number\n  #hasNum: boolean;\n  #numSum: number[];\n  #numMul: number[];\n  // percentage\n  #hasPct: boolean;\n  #pctSum: number[];\n  #pctMul: number[];\n  // dimension\n  #hasDim: boolean;\n  #dimSum: string[];\n  #dimSub: string[];\n  #dimMul: string[];\n  #dimDiv: string[];\n  // et cetra\n  #hasEtc: boolean;\n  #etcSum: string[];\n  #etcSub: string[];\n  #etcMul: string[];\n  #etcDiv: string[];\n\n  /**\n   * constructor\n   */\n  constructor() {\n    // number\n    this.#hasNum = false;\n    this.#numSum = [];\n    this.#numMul = [];\n    // percentage\n    this.#hasPct = false;\n    this.#pctSum = [];\n    this.#pctMul = [];\n    // dimension\n    this.#hasDim = false;\n    this.#dimSum = [];\n    this.#dimSub = [];\n    this.#dimMul = [];\n    this.#dimDiv = [];\n    // et cetra\n    this.#hasEtc = false;\n    this.#etcSum = [];\n    this.#etcSub = [];\n    this.#etcMul = [];\n    this.#etcDiv = [];\n  }\n\n  get hasNum() {\n    return this.#hasNum;\n  }\n\n  set hasNum(value: boolean) {\n    this.#hasNum = !!value;\n  }\n\n  get numSum() {\n    return this.#numSum;\n  }\n\n  get numMul() {\n    return this.#numMul;\n  }\n\n  get hasPct() {\n    return this.#hasPct;\n  }\n\n  set hasPct(value: boolean) {\n    this.#hasPct = !!value;\n  }\n\n  get pctSum() {\n    return this.#pctSum;\n  }\n\n  get pctMul() {\n    return this.#pctMul;\n  }\n\n  get hasDim() {\n    return this.#hasDim;\n  }\n\n  set hasDim(value: boolean) {\n    this.#hasDim = !!value;\n  }\n\n  get dimSum() {\n    return this.#dimSum;\n  }\n\n  get dimSub() {\n    return this.#dimSub;\n  }\n\n  get dimMul() {\n    return this.#dimMul;\n  }\n\n  get dimDiv() {\n    return this.#dimDiv;\n  }\n\n  get hasEtc() {\n    return this.#hasEtc;\n  }\n\n  set hasEtc(value: boolean) {\n    this.#hasEtc = !!value;\n  }\n\n  get etcSum() {\n    return this.#etcSum;\n  }\n\n  get etcSub() {\n    return this.#etcSub;\n  }\n\n  get etcMul() {\n    return this.#etcMul;\n  }\n\n  get etcDiv() {\n    return this.#etcDiv;\n  }\n\n  /**\n   * clear values\n   * @returns void\n   */\n  clear() {\n    // number\n    this.#hasNum = false;\n    this.#numSum = [];\n    this.#numMul = [];\n    // percentage\n    this.#hasPct = false;\n    this.#pctSum = [];\n    this.#pctMul = [];\n    // dimension\n    this.#hasDim = false;\n    this.#dimSum = [];\n    this.#dimSub = [];\n    this.#dimMul = [];\n    this.#dimDiv = [];\n    // et cetra\n    this.#hasEtc = false;\n    this.#etcSum = [];\n    this.#etcSub = [];\n    this.#etcMul = [];\n    this.#etcDiv = [];\n  }\n\n  /**\n   * sort values\n   * @param values - values\n   * @returns sorted values\n   */\n  sort(values: string[] = []): string[] {\n    const arr = [...values];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        let res;\n        if (REG_TYPE_DIM_PCT.test(a) && REG_TYPE_DIM_PCT.test(b)) {\n          const [, valA, unitA] = a.match(REG_TYPE_DIM_PCT) as MatchedRegExp;\n          const [, valB, unitB] = b.match(REG_TYPE_DIM_PCT) as MatchedRegExp;\n          if (unitA === unitB) {\n            if (Number(valA) === Number(valB)) {\n              res = 0;\n            } else if (Number(valA) > Number(valB)) {\n              res = 1;\n            } else {\n              res = -1;\n            }\n          } else if (unitA > unitB) {\n            res = 1;\n          } else {\n            res = -1;\n          }\n        } else {\n          if (a === b) {\n            res = 0;\n          } else if (a > b) {\n            res = 1;\n          } else {\n            res = -1;\n          }\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n\n  /**\n   * multiply values\n   * @returns resolved value\n   */\n  multiply(): string {\n    const value = [];\n    let num;\n    if (this.#hasNum) {\n      num = 1;\n      for (const i of this.#numMul) {\n        num *= i;\n        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      if (!this.#hasPct && !this.#hasDim && !this.hasEtc) {\n        if (Number.isFinite(num)) {\n          num = roundToPrecision(num, HEX);\n        }\n        value.push(num);\n      }\n    }\n    if (this.#hasPct) {\n      if (typeof num !== 'number') {\n        num = 1;\n      }\n      for (const i of this.#pctMul) {\n        num *= i;\n        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      if (Number.isFinite(num)) {\n        num = `${roundToPrecision(num, HEX)}%`;\n      }\n      if (!this.#hasDim && !this.hasEtc) {\n        value.push(num);\n      }\n    }\n    if (this.#hasDim) {\n      let dim = '';\n      let mul = '';\n      let div = '';\n      if (this.#dimMul.length) {\n        if (this.#dimMul.length === 1) {\n          [mul] = this.#dimMul as [string];\n        } else {\n          mul = `${this.sort(this.#dimMul).join(' * ')}`;\n        }\n      }\n      if (this.#dimDiv.length) {\n        if (this.#dimDiv.length === 1) {\n          [div] = this.#dimDiv as [string];\n        } else {\n          div = `${this.sort(this.#dimDiv).join(' * ')}`;\n        }\n      }\n      if (Number.isFinite(num)) {\n        if (mul) {\n          if (div) {\n            if (div.includes('*')) {\n              dim = calc(`calc(${num} * ${mul} / (${div}))`, {\n                toCanonicalUnits: true\n              });\n            } else {\n              dim = calc(`calc(${num} * ${mul} / ${div})`, {\n                toCanonicalUnits: true\n              });\n            }\n          } else {\n            dim = calc(`calc(${num} * ${mul})`, {\n              toCanonicalUnits: true\n            });\n          }\n        } else if (div.includes('*')) {\n          dim = calc(`calc(${num} / (${div}))`, {\n            toCanonicalUnits: true\n          });\n        } else {\n          dim = calc(`calc(${num} / ${div})`, {\n            toCanonicalUnits: true\n          });\n        }\n        value.push(dim.replace(/^calc/, ''));\n      } else {\n        if (!value.length && num !== undefined) {\n          value.push(num);\n        }\n        if (mul) {\n          if (div) {\n            if (div.includes('*')) {\n              dim = calc(`calc(${mul} / (${div}))`, {\n                toCanonicalUnits: true\n              });\n            } else {\n              dim = calc(`calc(${mul} / ${div})`, {\n                toCanonicalUnits: true\n              });\n            }\n          } else {\n            dim = calc(`calc(${mul})`, {\n              toCanonicalUnits: true\n            });\n          }\n          if (value.length) {\n            value.push('*', dim.replace(/^calc/, ''));\n          } else {\n            value.push(dim.replace(/^calc/, ''));\n          }\n        } else {\n          dim = calc(`calc(${div})`, {\n            toCanonicalUnits: true\n          });\n          if (value.length) {\n            value.push('/', dim.replace(/^calc/, ''));\n          } else {\n            value.push('1', '/', dim.replace(/^calc/, ''));\n          }\n        }\n      }\n    }\n    if (this.#hasEtc) {\n      if (this.#etcMul.length) {\n        if (!value.length && num !== undefined) {\n          value.push(num);\n        }\n        const mul = this.sort(this.#etcMul).join(' * ');\n        if (value.length) {\n          value.push(`* ${mul}`);\n        } else {\n          value.push(`${mul}`);\n        }\n      }\n      if (this.#etcDiv.length) {\n        const div = this.sort(this.#etcDiv).join(' * ');\n        if (div.includes('*')) {\n          if (value.length) {\n            value.push(`/ (${div})`);\n          } else {\n            value.push(`1 / (${div})`);\n          }\n        } else if (value.length) {\n          value.push(`/ ${div}`);\n        } else {\n          value.push(`1 / ${div}`);\n        }\n      }\n    }\n    if (value.length) {\n      return value.join(' ');\n    }\n    return '';\n  }\n\n  /**\n   * sum values\n   * @returns resolved value\n   */\n  sum(): string {\n    const value = [];\n    if (this.#hasNum) {\n      let num = 0;\n      for (const i of this.#numSum) {\n        num += i;\n        if (!Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      value.push(num);\n    }\n    if (this.#hasPct) {\n      let num: number | string = 0;\n      for (const i of this.#pctSum) {\n        num += i;\n        if (!Number.isFinite(num)) {\n          break;\n        }\n      }\n      if (Number.isFinite(num)) {\n        num = `${num}%`;\n      }\n      if (value.length) {\n        value.push(`+ ${num}`);\n      } else {\n        value.push(num);\n      }\n    }\n    if (this.#hasDim) {\n      let dim, sum, sub;\n      if (this.#dimSum.length) {\n        sum = this.sort(this.#dimSum).join(' + ');\n      }\n      if (this.#dimSub.length) {\n        sub = this.sort(this.#dimSub).join(' + ');\n      }\n      if (sum) {\n        if (sub) {\n          if (sub.includes('-')) {\n            dim = calc(`calc(${sum} - (${sub}))`, {\n              toCanonicalUnits: true\n            });\n          } else {\n            dim = calc(`calc(${sum} - ${sub})`, {\n              toCanonicalUnits: true\n            });\n          }\n        } else {\n          dim = calc(`calc(${sum})`, {\n            toCanonicalUnits: true\n          });\n        }\n      } else {\n        dim = calc(`calc(-1 * (${sub}))`, {\n          toCanonicalUnits: true\n        });\n      }\n      if (value.length) {\n        value.push('+', dim.replace(/^calc/, ''));\n      } else {\n        value.push(dim.replace(/^calc/, ''));\n      }\n    }\n    if (this.#hasEtc) {\n      if (this.#etcSum.length) {\n        const sum = this.sort(this.#etcSum)\n          .map(item => {\n            let res;\n            if (\n              REG_OPERATOR.test(item) &&\n              !item.startsWith('(') &&\n              !item.endsWith(')')\n            ) {\n              res = `(${item})`;\n            } else {\n              res = item;\n            }\n            return res;\n          })\n          .join(' + ');\n        if (value.length) {\n          if (this.#etcSum.length > 1) {\n            value.push(`+ (${sum})`);\n          } else {\n            value.push(`+ ${sum}`);\n          }\n        } else {\n          value.push(`${sum}`);\n        }\n      }\n      if (this.#etcSub.length) {\n        const sub = this.sort(this.#etcSub)\n          .map(item => {\n            let res;\n            if (\n              REG_OPERATOR.test(item) &&\n              !item.startsWith('(') &&\n              !item.endsWith(')')\n            ) {\n              res = `(${item})`;\n            } else {\n              res = item;\n            }\n            return res;\n          })\n          .join(' + ');\n        if (value.length) {\n          if (this.#etcSub.length > 1) {\n            value.push(`- (${sub})`);\n          } else {\n            value.push(`- ${sub}`);\n          }\n        } else if (this.#etcSub.length > 1) {\n          value.push(`-1 * (${sub})`);\n        } else {\n          value.push(`-1 * ${sub}`);\n        }\n      }\n    }\n    if (value.length) {\n      return value.join(' ');\n    }\n    return '';\n  }\n}\n\n/**\n * sort calc values\n * @param values - values to sort\n * @param [finalize] - finalize values\n * @returns sorted values\n */\nexport const sortCalcValues = (\n  values: (number | string)[] = [],\n  finalize: boolean = false\n): string => {\n  if (values.length < TRIA) {\n    throw new Error(`Unexpected array length ${values.length}.`);\n  }\n  const start = values.shift();\n  if (!isString(start) || !start.endsWith('(')) {\n    throw new Error(`Unexpected token ${start}.`);\n  }\n  const end = values.pop();\n  if (end !== ')') {\n    throw new Error(`Unexpected token ${end}.`);\n  }\n  if (values.length === 1) {\n    const [value] = values;\n    if (!isStringOrNumber(value)) {\n      throw new Error(`Unexpected token ${value}.`);\n    }\n    return `${start}${value}${end}`;\n  }\n  const sortedValues = [];\n  const cal = new Calculator();\n  let operator: string = '';\n  const l = values.length;\n  for (let i = 0; i < l; i++) {\n    const value = values[i];\n    if (!isStringOrNumber(value)) {\n      throw new Error(`Unexpected token ${value}.`);\n    }\n    if (value === '*' || value === '/') {\n      operator = value;\n    } else if (value === '+' || value === '-') {\n      const sortedValue = cal.multiply();\n      if (sortedValue) {\n        sortedValues.push(sortedValue, value);\n      }\n      cal.clear();\n      operator = '';\n    } else {\n      const numValue = Number(value);\n      const strValue = `${value}`;\n      switch (operator) {\n        case '/': {\n          if (Number.isFinite(numValue)) {\n            cal.hasNum = true;\n            cal.numMul.push(1 / numValue);\n          } else if (REG_TYPE_PCT.test(strValue)) {\n            const [, val] = strValue.match(REG_TYPE_PCT) as MatchedRegExp;\n            cal.hasPct = true;\n            cal.pctMul.push((MAX_PCT * MAX_PCT) / Number(val));\n          } else if (REG_TYPE_DIM.test(strValue)) {\n            cal.hasDim = true;\n            cal.dimDiv.push(strValue);\n          } else {\n            cal.hasEtc = true;\n            cal.etcDiv.push(strValue);\n          }\n          break;\n        }\n        case '*':\n        default: {\n          if (Number.isFinite(numValue)) {\n            cal.hasNum = true;\n            cal.numMul.push(numValue);\n          } else if (REG_TYPE_PCT.test(strValue)) {\n            const [, val] = strValue.match(REG_TYPE_PCT) as MatchedRegExp;\n            cal.hasPct = true;\n            cal.pctMul.push(Number(val));\n          } else if (REG_TYPE_DIM.test(strValue)) {\n            cal.hasDim = true;\n            cal.dimMul.push(strValue);\n          } else {\n            cal.hasEtc = true;\n            cal.etcMul.push(strValue);\n          }\n        }\n      }\n    }\n    if (i === l - 1) {\n      const sortedValue = cal.multiply();\n      if (sortedValue) {\n        sortedValues.push(sortedValue);\n      }\n      cal.clear();\n      operator = '';\n    }\n  }\n  let resolvedValue = '';\n  if (finalize && (sortedValues.includes('+') || sortedValues.includes('-'))) {\n    const finalizedValues = [];\n    cal.clear();\n    operator = '';\n    const l = sortedValues.length;\n    for (let i = 0; i < l; i++) {\n      const value = sortedValues[i];\n      if (isStringOrNumber(value)) {\n        if (value === '+' || value === '-') {\n          operator = value;\n        } else {\n          const numValue = Number(value);\n          const strValue = `${value}`;\n          switch (operator) {\n            case '-': {\n              if (Number.isFinite(numValue)) {\n                cal.hasNum = true;\n                cal.numSum.push(-1 * numValue);\n              } else if (REG_TYPE_PCT.test(strValue)) {\n                const [, val] = strValue.match(REG_TYPE_PCT) as MatchedRegExp;\n                cal.hasPct = true;\n                cal.pctSum.push(-1 * Number(val));\n              } else if (REG_TYPE_DIM.test(strValue)) {\n                cal.hasDim = true;\n                cal.dimSub.push(strValue);\n              } else {\n                cal.hasEtc = true;\n                cal.etcSub.push(strValue);\n              }\n              break;\n            }\n            case '+':\n            default: {\n              if (Number.isFinite(numValue)) {\n                cal.hasNum = true;\n                cal.numSum.push(numValue);\n              } else if (REG_TYPE_PCT.test(strValue)) {\n                const [, val] = strValue.match(REG_TYPE_PCT) as MatchedRegExp;\n                cal.hasPct = true;\n                cal.pctSum.push(Number(val));\n              } else if (REG_TYPE_DIM.test(strValue)) {\n                cal.hasDim = true;\n                cal.dimSum.push(strValue);\n              } else {\n                cal.hasEtc = true;\n                cal.etcSum.push(strValue);\n              }\n            }\n          }\n        }\n      }\n      if (i === l - 1) {\n        const sortedValue = cal.sum();\n        if (sortedValue) {\n          finalizedValues.push(sortedValue);\n        }\n        cal.clear();\n        operator = '';\n      }\n    }\n    resolvedValue = finalizedValues.join(' ').replace(/\\+\\s-/g, '- ');\n  } else {\n    resolvedValue = sortedValues.join(' ').replace(/\\+\\s-/g, '- ');\n  }\n  if (\n    resolvedValue.startsWith('(') &&\n    resolvedValue.endsWith(')') &&\n    resolvedValue.lastIndexOf('(') === 0 &&\n    resolvedValue.indexOf(')') === resolvedValue.length - 1\n  ) {\n    resolvedValue = resolvedValue.replace(/^\\(/, '').replace(/\\)$/, '');\n  }\n  return `${start}${resolvedValue}${end}`;\n};\n\n/**\n * serialize calc\n * @param value - CSS value\n * @param [opt] - options\n * @returns serialized value\n */\nexport const serializeCalc = (value: string, opt: Options = {}): string => {\n  const { format = '' } = opt;\n  if (isString(value)) {\n    if (!REG_FN_VAR_START.test(value) || format !== VAL_SPEC) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'serializeCalc',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string;\n  }\n  const items: string[] = tokenize({ css: value })\n    .map((token: CSSToken): string => {\n      const [type, value] = token as [TokenType, string];\n      let res = '';\n      if (type !== W_SPACE && type !== COMMENT) {\n        res = value;\n      }\n      return res;\n    })\n    .filter(v => v);\n  let startIndex = items.findLastIndex((item: string) => /\\($/.test(item));\n  while (startIndex) {\n    const endIndex = items.findIndex((item: unknown, index: number) => {\n      return item === ')' && index > startIndex;\n    });\n    const slicedValues: string[] = items.slice(startIndex, endIndex + 1);\n    let serializedValue: string = sortCalcValues(slicedValues);\n    if (REG_FN_VAR_START.test(serializedValue)) {\n      serializedValue = calc(serializedValue, {\n        toCanonicalUnits: true\n      });\n    }\n    items.splice(startIndex, endIndex - startIndex + 1, serializedValue);\n    startIndex = items.findLastIndex((item: string) => /\\($/.test(item));\n  }\n  const serializedCalc = sortCalcValues(items, true);\n  setCache(cacheKey, serializedCalc);\n  return serializedCalc;\n};\n\n/**\n * resolve dimension\n * @param token - CSS token\n * @param [opt] - options\n * @returns resolved value\n */\nexport const resolveDimension = (\n  token: CSSToken,\n  opt: Options = {}\n): string | NullObject => {\n  if (!Array.isArray(token)) {\n    throw new TypeError(`${token} is not an array.`);\n  }\n  const [, , , , detail = {}] = token;\n  const { unit, value } = detail as {\n    unit: string;\n    value: number;\n  };\n  const { dimension = {} } = opt;\n  if (unit === 'px') {\n    return `${value}${unit}`;\n  }\n  const relativeValue = Number(value);\n  if (unit && Number.isFinite(relativeValue)) {\n    let pixelValue;\n    if (Object.hasOwnProperty.call(dimension, unit)) {\n      pixelValue = dimension[unit];\n    } else if (typeof dimension.callback === 'function') {\n      pixelValue = dimension.callback(unit);\n    }\n    pixelValue = Number(pixelValue);\n    if (Number.isFinite(pixelValue)) {\n      return `${relativeValue * pixelValue}px`;\n    }\n  }\n  return new NullObject();\n};\n\n/**\n * parse tokens\n * @param tokens - CSS tokens\n * @param [opt] - options\n * @returns parsed tokens\n */\nexport const parseTokens = (\n  tokens: CSSToken[],\n  opt: Options = {}\n): string[] => {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { format = '' } = opt;\n  const mathFunc = new Set();\n  let nest = 0;\n  const res: string[] = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type = '', value = ''] = token as [TokenType, string];\n    switch (type) {\n      case DIM: {\n        if (format === VAL_SPEC && !mathFunc.has(nest)) {\n          res.push(value);\n        } else {\n          const resolvedValue = resolveDimension(token, opt);\n          if (isString(resolvedValue)) {\n            res.push(resolvedValue);\n          } else {\n            res.push(value);\n          }\n        }\n        break;\n      }\n      case FUNC:\n      case PAREN_OPEN: {\n        res.push(value);\n        nest++;\n        if (REG_FN_MATH_START.test(value)) {\n          mathFunc.add(nest);\n        }\n        break;\n      }\n      case PAREN_CLOSE: {\n        if (res.length) {\n          const lastValue = res[res.length - 1];\n          if (lastValue === ' ') {\n            res.splice(-1, 1, value);\n          } else {\n            res.push(value);\n          }\n        } else {\n          res.push(value);\n        }\n        if (mathFunc.has(nest)) {\n          mathFunc.delete(nest);\n        }\n        nest--;\n        break;\n      }\n      case W_SPACE: {\n        if (res.length) {\n          const lastValue = res[res.length - 1];\n          if (\n            isString(lastValue) &&\n            !lastValue.endsWith('(') &&\n            lastValue !== ' '\n          ) {\n            res.push(value);\n          }\n        }\n        break;\n      }\n      default: {\n        if (type !== COMMENT && type !== EOF) {\n          res.push(value);\n        }\n      }\n    }\n  }\n  return res;\n};\n\n/**\n * CSS calc()\n * @param value - CSS value including calc()\n * @param [opt] - options\n * @returns resolved value\n */\nexport const cssCalc = (value: string, opt: Options = {}): string => {\n  const { format = '' } = opt;\n  if (isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === VAL_SPEC) {\n        return value;\n      } else {\n        const resolvedValue = resolveVar(value, opt);\n        if (isString(resolvedValue)) {\n          return resolvedValue;\n        } else {\n          return '';\n        }\n      }\n    } else if (!REG_FN_CALC.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'cssCalc',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string;\n  }\n  const tokens = tokenize({ css: value });\n  const values = parseTokens(tokens, opt);\n  let resolvedValue: string = calc(values.join(''), {\n    toCanonicalUnits: true\n  });\n  if (REG_FN_VAR_START.test(value)) {\n    if (REG_TYPE_DIM_PCT.test(resolvedValue)) {\n      const [, val, unit] = resolvedValue.match(\n        REG_TYPE_DIM_PCT\n      ) as MatchedRegExp;\n      resolvedValue = `${roundToPrecision(Number(val), HEX)}${unit}`;\n    }\n    // wrap with `calc()`\n    if (\n      resolvedValue &&\n      !REG_FN_VAR_START.test(resolvedValue) &&\n      format === VAL_SPEC\n    ) {\n      resolvedValue = `calc(${resolvedValue})`;\n    }\n  }\n  if (format === VAL_SPEC) {\n    if (/\\s[-+*/]\\s/.test(resolvedValue) && !resolvedValue.includes('NaN')) {\n      resolvedValue = serializeCalc(resolvedValue, opt);\n    } else if (REG_FN_CALC_NUM.test(resolvedValue)) {\n      const [, val] = resolvedValue.match(REG_FN_CALC_NUM) as MatchedRegExp;\n      resolvedValue = `calc(${roundToPrecision(Number(val), HEX)})`;\n    }\n  }\n  setCache(cacheKey, resolvedValue);\n  return resolvedValue;\n};\n","/**\n * cache\n */\n\nimport { LRUCache } from 'lru-cache';\nimport { Options } from './typedef';\nimport { valueToJsonString } from './util';\n\n/* numeric constants */\nconst MAX_CACHE = 4096;\n\n/**\n * CacheItem\n */\nexport class CacheItem {\n  /* private */\n  #isNull: boolean;\n  #item: unknown;\n\n  /**\n   * constructor\n   */\n  constructor(item: unknown, isNull: boolean = false) {\n    this.#item = item;\n    this.#isNull = !!isNull;\n  }\n\n  get item() {\n    return this.#item;\n  }\n\n  get isNull() {\n    return this.#isNull;\n  }\n}\n\n/**\n * NullObject\n */\nexport class NullObject extends CacheItem {\n  /**\n   * constructor\n   */\n  constructor() {\n    super(Symbol('null'), true);\n  }\n}\n\n/*\n * lru cache\n */\nexport const lruCache = new LRUCache({\n  max: MAX_CACHE\n});\n\n/**\n * set cache\n * @param key - cache key\n * @param value - value to cache\n * @returns void\n */\nexport const setCache = (key: string, value: unknown): void => {\n  if (key) {\n    if (value === null) {\n      lruCache.set(key, new NullObject());\n    } else if (value instanceof CacheItem) {\n      lruCache.set(key, value);\n    } else {\n      lruCache.set(key, new CacheItem(value));\n    }\n  }\n};\n\n/**\n * get cache\n * @param key - cache key\n * @returns cached item or false otherwise\n */\nexport const getCache = (key: string): CacheItem | boolean => {\n  if (key && lruCache.has(key)) {\n    const item = lruCache.get(key);\n    if (item instanceof CacheItem) {\n      return item;\n    }\n    // delete unexpected cached item\n    lruCache.delete(key);\n    return false;\n  }\n  return false;\n};\n\n/**\n * create cache key\n * @param keyData - key data\n * @param [opt] - options\n * @returns cache key\n */\nexport const createCacheKey = (\n  keyData: Record<string, string>,\n  opt: Options = {}\n): string => {\n  const { customProperty = {}, dimension = {} } = opt;\n  let cacheKey = '';\n  if (\n    keyData &&\n    Object.keys(keyData).length &&\n    typeof customProperty.callback !== 'function' &&\n    typeof dimension.callback !== 'function'\n  ) {\n    keyData.opt = valueToJsonString(opt);\n    cacheKey = valueToJsonString(keyData);\n  }\n  return cacheKey;\n};\n","/**\n * util\n */\n\nimport { TokenType, tokenize } from '@csstools/css-tokenizer';\nimport { CacheItem, createCacheKey, getCache, setCache } from './cache';\nimport { isString } from './common';\nimport { resolveColor } from './resolve';\nimport { Options } from './typedef';\n\n/* constants */\nimport { NAMED_COLORS } from './color';\nimport { SYN_COLOR_TYPE, SYN_MIX, VAL_SPEC } from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comma: COMMA,\n  Comment: COMMENT,\n  Delim: DELIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  OpenParen: PAREN_OPEN,\n  Whitespace: W_SPACE\n} = TokenType;\nconst NAMESPACE = 'util';\n\n/* numeric constants */\nconst DEC = 10;\nconst HEX = 16;\nconst DEG = 360;\nconst DEG_HALF = 180;\n\n/* regexp */\nconst REG_COLOR = new RegExp(`^(?:${SYN_COLOR_TYPE})$`);\nconst REG_FN_COLOR =\n  /^(?:(?:ok)?l(?:ab|ch)|color(?:-mix)?|hsla?|hwb|rgba?|var)\\(/;\nconst REG_MIX = new RegExp(SYN_MIX);\n\n/**\n * split value\n * NOTE: comments are stripped, it can be preserved if, in the options param,\n * `delimiter` is either ',' or '/' and with `preserveComment` set to `true`\n * @param value - CSS value\n * @param [opt] - options\n * @returns array of values\n */\nexport const splitValue = (value: string, opt: Options = {}): string[] => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { delimiter = ' ', preserveComment = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'splitValue',\n      value\n    },\n    {\n      delimiter,\n      preserveComment\n    }\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string[];\n  }\n  let regDelimiter;\n  if (delimiter === ',') {\n    regDelimiter = /^,$/;\n  } else if (delimiter === '/') {\n    regDelimiter = /^\\/$/;\n  } else {\n    regDelimiter = /^\\s+$/;\n  }\n  const tokens = tokenize({ css: value });\n  let nest = 0;\n  let str = '';\n  const res: string[] = [];\n  while (tokens.length) {\n    const [type, value] = tokens.shift() as [TokenType, string];\n    switch (type) {\n      case COMMA: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            res.push(str.trim());\n            str = '';\n          } else {\n            str += value;\n          }\n        } else {\n          str += value;\n        }\n        break;\n      }\n      case DELIM: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            res.push(str.trim());\n            str = '';\n          } else {\n            str += value;\n          }\n        } else {\n          str += value;\n        }\n        break;\n      }\n      case COMMENT: {\n        if (preserveComment && (delimiter === ',' || delimiter === '/')) {\n          str += value;\n        }\n        break;\n      }\n      case FUNC:\n      case PAREN_OPEN: {\n        str += value;\n        nest++;\n        break;\n      }\n      case PAREN_CLOSE: {\n        str += value;\n        nest--;\n        break;\n      }\n      case W_SPACE: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            if (str) {\n              res.push(str.trim());\n              str = '';\n            }\n          } else {\n            str += ' ';\n          }\n        } else if (!str.endsWith(' ')) {\n          str += ' ';\n        }\n        break;\n      }\n      default: {\n        if (type === EOF) {\n          res.push(str.trim());\n          str = '';\n        } else {\n          str += value;\n        }\n      }\n    }\n  }\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * extract dashed-ident tokens\n * @param value - CSS value\n * @returns array of dashed-ident tokens\n */\nexport const extractDashedIdent = (value: string): string[] => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey({\n    namespace: NAMESPACE,\n    name: 'extractDashedIdent',\n    value\n  });\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string[];\n  }\n  const tokens = tokenize({ css: value });\n  const items = new Set();\n  while (tokens.length) {\n    const [type, value] = tokens.shift() as [TokenType, string];\n    if (type === IDENT && value.startsWith('--')) {\n      items.add(value);\n    }\n  }\n  const res = [...items] as string[];\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * is color\n * @param value - CSS value\n * @param [opt] - options\n * @returns result\n */\nexport const isColor = (value: unknown, opt: Options = {}): boolean => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n    if (value && isString(value)) {\n      if (/^[a-z]+$/.test(value)) {\n        if (\n          /^(?:currentcolor|transparent)$/.test(value) ||\n          Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)\n        ) {\n          return true;\n        }\n      } else if (REG_COLOR.test(value) || REG_MIX.test(value)) {\n        return true;\n      } else if (REG_FN_COLOR.test(value)) {\n        opt.nullable = true;\n        if (!opt.format) {\n          opt.format = VAL_SPEC;\n        }\n        const resolvedValue = resolveColor(value, opt);\n        if (resolvedValue) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * value to JSON string\n * @param value - CSS value\n * @param [func] - stringify function\n * @returns stringified value in JSON notation\n */\nexport const valueToJsonString = (\n  value: unknown,\n  func: boolean = false\n): string => {\n  if (typeof value === 'undefined') {\n    return '';\n  }\n  const res = JSON.stringify(value, (_key, val) => {\n    let replacedValue;\n    if (typeof val === 'undefined') {\n      replacedValue = null;\n    } else if (typeof val === 'function') {\n      if (func) {\n        replacedValue = val.toString().replace(/\\s/g, '').substring(0, HEX);\n      } else {\n        replacedValue = val.name;\n      }\n    } else if (val instanceof Map || val instanceof Set) {\n      replacedValue = [...val];\n    } else if (typeof val === 'bigint') {\n      replacedValue = val.toString();\n    } else {\n      replacedValue = val;\n    }\n    return replacedValue;\n  });\n  return res;\n};\n\n/**\n * round to specified precision\n * @param value - numeric value\n * @param bit - minimum bits\n * @returns rounded value\n */\nexport const roundToPrecision = (value: number, bit: number = 0): number => {\n  if (!Number.isFinite(value)) {\n    throw new TypeError(`${value} is not a finite number.`);\n  }\n  if (!Number.isFinite(bit)) {\n    throw new TypeError(`${bit} is not a finite number.`);\n  } else if (bit < 0 || bit > HEX) {\n    throw new RangeError(`${bit} is not between 0 and ${HEX}.`);\n  }\n  if (bit === 0) {\n    return Math.round(value);\n  }\n  let val;\n  if (bit === HEX) {\n    val = value.toPrecision(6);\n  } else if (bit < DEC) {\n    val = value.toPrecision(4);\n  } else {\n    val = value.toPrecision(5);\n  }\n  return parseFloat(val);\n};\n\n/**\n * interpolate hue\n * @param hueA - hue value\n * @param hueB - hue value\n * @param arc - shorter | longer | increasing | decreasing\n * @returns result - [hueA, hueB]\n */\nexport const interpolateHue = (\n  hueA: number,\n  hueB: number,\n  arc: string = 'shorter'\n): [number, number] => {\n  if (!Number.isFinite(hueA)) {\n    throw new TypeError(`${hueA} is not a finite number.`);\n  }\n  if (!Number.isFinite(hueB)) {\n    throw new TypeError(`${hueB} is not a finite number.`);\n  }\n  switch (arc) {\n    case 'decreasing': {\n      if (hueB > hueA) {\n        hueA += DEG;\n      }\n      break;\n    }\n    case 'increasing': {\n      if (hueB < hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case 'longer': {\n      if (hueB > hueA && hueB < hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB > hueA + DEG_HALF * -1 && hueB <= hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case 'shorter':\n    default: {\n      if (hueB > hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB < hueA + DEG_HALF * -1) {\n        hueB += DEG;\n      }\n    }\n  }\n  return [hueA, hueB];\n};\n","/**\n * common\n */\n\n/* numeric constants */\nconst TYPE_FROM = 8;\nconst TYPE_TO = -1;\n\n/**\n * get type\n * @param o - object to check\n * @returns type of object\n */\nexport const getType = (o: unknown): string =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * is string\n * @param o - object to check\n * @returns result\n */\nexport const isString = (o: unknown): o is string =>\n  typeof o === 'string' || o instanceof String;\n\n/**\n * is string or number\n * @param o - object to check\n * @returns result\n */\nexport const isStringOrNumber = (o: unknown): boolean =>\n  isString(o) || typeof o === 'number';\n","/**\n * constant\n */\n\n/* values and units */\nconst _DIGIT = '(?:0|[1-9]\\\\d*)';\nconst _COMPARE = 'clamp|max|min';\nconst _EXPO = 'exp|hypot|log|pow|sqrt';\nconst _SIGN = 'abs|sign';\nconst _STEP = 'mod|rem|round';\nconst _TRIG = 'a?(?:cos|sin|tan)|atan2';\nconst _MATH = `${_COMPARE}|${_EXPO}|${_SIGN}|${_STEP}|${_TRIG}`;\nconst _CALC = `calc|${_MATH}`;\nconst _VAR = `var|${_CALC}`;\nexport const ANGLE = 'deg|g?rad|turn';\nexport const LENGTH =\n  '[cm]m|[dls]?v(?:[bhiw]|max|min)|in|p[ctx]|q|r?(?:[cl]h|cap|e[mx]|ic)';\nexport const NUM = `[+-]?(?:${_DIGIT}(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e-?${_DIGIT})?`;\nexport const NUM_POSITIVE = `\\\\+?(?:${_DIGIT}(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e-?${_DIGIT})?`;\nexport const NONE = 'none';\nexport const PCT = `${NUM}%`;\nexport const SYN_FN_CALC = `^(?:${_CALC})\\\\(|(?<=[*\\\\/\\\\s\\\\(])(?:${_CALC})\\\\(`;\nexport const SYN_FN_MATH_START = `^(?:${_MATH})\\\\($`;\nexport const SYN_FN_VAR = '^var\\\\(|(?<=[*\\\\/\\\\s\\\\(])var\\\\(';\nexport const SYN_FN_VAR_START = `^(?:${_VAR})\\\\(`;\n\n/* colors */\nconst _ALPHA = `(?:\\\\s*\\\\/\\\\s*(?:${NUM}|${PCT}|${NONE}))?`;\nconst _ALPHA_LV3 = `(?:\\\\s*,\\\\s*(?:${NUM}|${PCT}))?`;\nconst _COLOR_FUNC = '(?:ok)?l(?:ab|ch)|color|hsla?|hwb|rgba?';\nconst _COLOR_KEY = '[a-z]+|#[\\\\da-f]{3}|#[\\\\da-f]{4}|#[\\\\da-f]{6}|#[\\\\da-f]{8}';\nconst _CS_HUE = '(?:ok)?lch|hsl|hwb';\nconst _CS_HUE_ARC = '(?:de|in)creasing|longer|shorter';\nconst _NUM_ANGLE = `${NUM}(?:${ANGLE})?`;\nconst _NUM_ANGLE_NONE = `(?:${NUM}(?:${ANGLE})?|${NONE})`;\nconst _NUM_PCT_NONE = `(?:${NUM}|${PCT}|${NONE})`;\nexport const CS_HUE = `(?:${_CS_HUE})(?:\\\\s(?:${_CS_HUE_ARC})\\\\shue)?`;\nexport const CS_HUE_CAPT = `(${_CS_HUE})(?:\\\\s(${_CS_HUE_ARC})\\\\shue)?`;\nexport const CS_LAB = '(?:ok)?lab';\nexport const CS_LCH = '(?:ok)?lch';\nexport const CS_SRGB = 'srgb(?:-linear)?';\nexport const CS_RGB = `(?:a98|prophoto)-rgb|display-p3|rec2020|${CS_SRGB}`;\nexport const CS_XYZ = 'xyz(?:-d(?:50|65))?';\nexport const CS_RECT = `${CS_LAB}|${CS_RGB}|${CS_XYZ}`;\nexport const CS_MIX = `${CS_HUE}|${CS_RECT}`;\nexport const FN_COLOR = 'color(';\nexport const FN_MIX = 'color-mix(';\nexport const FN_REL = `(?:${_COLOR_FUNC})\\\\(\\\\s*from\\\\s+`;\nexport const FN_REL_CAPT = `(${_COLOR_FUNC})\\\\(\\\\s*from\\\\s+`;\nexport const FN_VAR = 'var(';\nexport const SYN_FN_COLOR = `(?:${CS_RGB}|${CS_XYZ})(?:\\\\s+${_NUM_PCT_NONE}){3}${_ALPHA}`;\nexport const SYN_FN_REL = `^${FN_REL}|(?<=[\\\\s])${FN_REL}`;\nexport const SYN_HSL = `${_NUM_ANGLE_NONE}(?:\\\\s+${_NUM_PCT_NONE}){2}${_ALPHA}`;\nexport const SYN_HSL_LV3 = `${_NUM_ANGLE}(?:\\\\s*,\\\\s*${PCT}){2}${_ALPHA_LV3}`;\nexport const SYN_LCH = `(?:${_NUM_PCT_NONE}\\\\s+){2}${_NUM_ANGLE_NONE}${_ALPHA}`;\nexport const SYN_MOD = `${_NUM_PCT_NONE}(?:\\\\s+${_NUM_PCT_NONE}){2}${_ALPHA}`;\nexport const SYN_RGB_LV3 = `(?:${NUM}(?:\\\\s*,\\\\s*${NUM}){2}|${PCT}(?:\\\\s*,\\\\s*${PCT}){2})${_ALPHA_LV3}`;\nexport const SYN_COLOR_TYPE = `${_COLOR_KEY}|hsla?\\\\(\\\\s*${SYN_HSL_LV3}\\\\s*\\\\)|rgba?\\\\(\\\\s*${SYN_RGB_LV3}\\\\s*\\\\)|(?:hsla?|hwb)\\\\(\\\\s*${SYN_HSL}\\\\s*\\\\)|(?:(?:ok)?lab|rgba?)\\\\(\\\\s*${SYN_MOD}\\\\s*\\\\)|(?:ok)?lch\\\\(\\\\s*${SYN_LCH}\\\\s*\\\\)|color\\\\(\\\\s*${SYN_FN_COLOR}\\\\s*\\\\)`;\nexport const SYN_MIX_PART = `(?:${SYN_COLOR_TYPE})(?:\\\\s+${PCT})?`;\nexport const SYN_MIX = `color-mix\\\\(\\\\s*in\\\\s+(?:${CS_MIX})\\\\s*,\\\\s*${SYN_MIX_PART}\\\\s*,\\\\s*${SYN_MIX_PART}\\\\s*\\\\)`;\nexport const SYN_MIX_CAPT = `color-mix\\\\(\\\\s*in\\\\s+(${CS_MIX})\\\\s*,\\\\s*(${SYN_MIX_PART})\\\\s*,\\\\s*(${SYN_MIX_PART})\\\\s*\\\\)`;\n\n/* formats */\nexport const VAL_COMP = 'computedValue';\nexport const VAL_MIX = 'mixValue';\nexport const VAL_SPEC = 'specifiedValue';\n","/**\n * color\n *\n * Ref: CSS Color Module Level 4\n *      Sample code for Color Conversions\n *      https://w3c.github.io/csswg-drafts/css-color-4/#color-conversion-code\n */\n\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport { isString } from './common';\nimport { interpolateHue, roundToPrecision } from './util';\nimport {\n  ColorChannels,\n  ComputedColorChannels,\n  Options,\n  MatchedRegExp,\n  SpecifiedColorChannels,\n  StringColorChannels,\n  StringColorSpacedChannels\n} from './typedef';\n\n/* constants */\nimport {\n  ANGLE,\n  CS_HUE_CAPT,\n  CS_MIX,\n  CS_RGB,\n  CS_XYZ,\n  FN_COLOR,\n  FN_MIX,\n  NONE,\n  NUM,\n  PCT,\n  SYN_COLOR_TYPE,\n  SYN_FN_COLOR,\n  SYN_HSL,\n  SYN_HSL_LV3,\n  SYN_LCH,\n  SYN_MIX,\n  SYN_MIX_CAPT,\n  SYN_MIX_PART,\n  SYN_MOD,\n  SYN_RGB_LV3,\n  VAL_COMP,\n  VAL_MIX,\n  VAL_SPEC\n} from './constant';\nconst NAMESPACE = 'color';\n\n/* numeric constants */\nconst PPTH = 0.001;\nconst HALF = 0.5;\nconst DUO = 2;\nconst TRIA = 3;\nconst QUAD = 4;\nconst OCT = 8;\nconst DEC = 10;\nconst DOZ = 12;\nconst HEX = 16;\nconst SEXA = 60;\nconst DEG_HALF = 180;\nconst DEG = 360;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\nconst POW_SQR = 2;\nconst POW_CUBE = 3;\nconst POW_LINEAR = 2.4;\nconst LINEAR_COEF = 12.92;\nconst LINEAR_OFFSET = 0.055;\nconst LAB_L = 116;\nconst LAB_A = 500;\nconst LAB_B = 200;\nconst LAB_EPSILON = 216 / 24389;\nconst LAB_KAPPA = 24389 / 27;\n\n/* type definitions */\n/**\n * @type NumStrColorChannels - string or numeric color channels\n */\ntype NumStrColorChannels = [\n  x: number | string,\n  y: number | string,\n  z: number | string,\n  alpha: number | string\n];\n\n/**\n * @type TriColorChannels - color channels without alpha\n */\ntype TriColorChannels = [x: number, y: number, z: number];\n\n/**\n * @type ColorMatrix - color matrix\n */\ntype ColorMatrix = [\n  r1: TriColorChannels,\n  r2: TriColorChannels,\n  r3: TriColorChannels\n];\n\n/* white point */\nconst D50: TriColorChannels = [\n  0.3457 / 0.3585,\n  1.0,\n  (1.0 - 0.3457 - 0.3585) / 0.3585\n];\nconst MATRIX_D50_TO_D65: ColorMatrix = [\n  [0.955473421488075, -0.02309845494876471, 0.06325924320057072],\n  [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],\n  [0.012314014864481998, -0.020507649298898964, 1.330365926242124]\n];\nconst MATRIX_D65_TO_D50: ColorMatrix = [\n  [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],\n  [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],\n  [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]\n];\n\n/* color space */\nconst MATRIX_L_RGB_TO_XYZ: ColorMatrix = [\n  [506752 / 1228815, 87881 / 245763, 12673 / 70218],\n  [87098 / 409605, 175762 / 245763, 12673 / 175545],\n  [7918 / 409605, 87881 / 737289, 1001167 / 1053270]\n];\nconst MATRIX_XYZ_TO_L_RGB: ColorMatrix = [\n  [12831 / 3959, -329 / 214, -1974 / 3959],\n  [-851781 / 878810, 1648619 / 878810, 36519 / 878810],\n  [705 / 12673, -2585 / 12673, 705 / 667]\n];\nconst MATRIX_XYZ_TO_LMS: ColorMatrix = [\n  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],\n  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],\n  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]\n];\nconst MATRIX_LMS_TO_XYZ: ColorMatrix = [\n  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],\n  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],\n  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]\n];\nconst MATRIX_OKLAB_TO_LMS: ColorMatrix = [\n  [1.0, 0.3963377773761749, 0.2158037573099136],\n  [1.0, -0.1055613458156586, -0.0638541728258133],\n  [1.0, -0.0894841775298119, -1.2914855480194092]\n];\nconst MATRIX_LMS_TO_OKLAB: ColorMatrix = [\n  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],\n  [1.9779985324311684, -2.4285922420485799, 0.450593709617411],\n  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]\n];\nconst MATRIX_P3_TO_XYZ: ColorMatrix = [\n  [608311 / 1250200, 189793 / 714400, 198249 / 1000160],\n  [35783 / 156275, 247089 / 357200, 198249 / 2500400],\n  [0 / 1, 32229 / 714400, 5220557 / 5000800]\n];\nconst MATRIX_REC2020_TO_XYZ: ColorMatrix = [\n  [63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314],\n  [26158966 / 99577255, 472592308 / 697040785, 8267143 / 139408157],\n  [0 / 1, 19567812 / 697040785, 295819943 / 278816314]\n];\nconst MATRIX_A98_TO_XYZ: ColorMatrix = [\n  [573536 / 994567, 263643 / 1420810, 187206 / 994567],\n  [591459 / 1989134, 6239551 / 9945670, 374412 / 4972835],\n  [53769 / 1989134, 351524 / 4972835, 4929758 / 4972835]\n];\nconst MATRIX_PROPHOTO_TO_XYZ_D50: ColorMatrix = [\n  [0.7977666449006423, 0.13518129740053308, 0.0313477341283922],\n  [0.2880748288194013, 0.711835234241873, 0.00008993693872564],\n  [0.0, 0.0, 0.8251046025104602]\n];\n\n/* regexp */\nconst REG_COLOR = new RegExp(`^(?:${SYN_COLOR_TYPE})$`);\nconst REG_CS_HUE = new RegExp(`^${CS_HUE_CAPT}$`);\nconst REG_CS_XYZ = /^xyz(?:-d(?:50|65))?$/;\nconst REG_CURRENT = /^currentColor$/i;\nconst REG_FN_COLOR = new RegExp(`^color\\\\(\\\\s*(${SYN_FN_COLOR})\\\\s*\\\\)$`);\nconst REG_HSL = new RegExp(`^hsla?\\\\(\\\\s*(${SYN_HSL}|${SYN_HSL_LV3})\\\\s*\\\\)$`);\nconst REG_HWB = new RegExp(`^hwb\\\\(\\\\s*(${SYN_HSL})\\\\s*\\\\)$`);\nconst REG_LAB = new RegExp(`^lab\\\\(\\\\s*(${SYN_MOD})\\\\s*\\\\)$`);\nconst REG_LCH = new RegExp(`^lch\\\\(\\\\s*(${SYN_LCH})\\\\s*\\\\)$`);\nconst REG_MIX = new RegExp(`^${SYN_MIX}$`);\nconst REG_MIX_CAPT = new RegExp(`^${SYN_MIX_CAPT}$`);\nconst REG_MIX_NEST = new RegExp(`${SYN_MIX}`, 'g');\nconst REG_OKLAB = new RegExp(`^oklab\\\\(\\\\s*(${SYN_MOD})\\\\s*\\\\)$`);\nconst REG_OKLCH = new RegExp(`^oklch\\\\(\\\\s*(${SYN_LCH})\\\\s*\\\\)$`);\nconst REG_SPEC = /^(?:specifi|comput)edValue$/;\n\n/**\n * named colors\n */\nexport const NAMED_COLORS = {\n  aliceblue: [0xf0, 0xf8, 0xff],\n  antiquewhite: [0xfa, 0xeb, 0xd7],\n  aqua: [0x00, 0xff, 0xff],\n  aquamarine: [0x7f, 0xff, 0xd4],\n  azure: [0xf0, 0xff, 0xff],\n  beige: [0xf5, 0xf5, 0xdc],\n  bisque: [0xff, 0xe4, 0xc4],\n  black: [0x00, 0x00, 0x00],\n  blanchedalmond: [0xff, 0xeb, 0xcd],\n  blue: [0x00, 0x00, 0xff],\n  blueviolet: [0x8a, 0x2b, 0xe2],\n  brown: [0xa5, 0x2a, 0x2a],\n  burlywood: [0xde, 0xb8, 0x87],\n  cadetblue: [0x5f, 0x9e, 0xa0],\n  chartreuse: [0x7f, 0xff, 0x00],\n  chocolate: [0xd2, 0x69, 0x1e],\n  coral: [0xff, 0x7f, 0x50],\n  cornflowerblue: [0x64, 0x95, 0xed],\n  cornsilk: [0xff, 0xf8, 0xdc],\n  crimson: [0xdc, 0x14, 0x3c],\n  cyan: [0x00, 0xff, 0xff],\n  darkblue: [0x00, 0x00, 0x8b],\n  darkcyan: [0x00, 0x8b, 0x8b],\n  darkgoldenrod: [0xb8, 0x86, 0x0b],\n  darkgray: [0xa9, 0xa9, 0xa9],\n  darkgreen: [0x00, 0x64, 0x00],\n  darkgrey: [0xa9, 0xa9, 0xa9],\n  darkkhaki: [0xbd, 0xb7, 0x6b],\n  darkmagenta: [0x8b, 0x00, 0x8b],\n  darkolivegreen: [0x55, 0x6b, 0x2f],\n  darkorange: [0xff, 0x8c, 0x00],\n  darkorchid: [0x99, 0x32, 0xcc],\n  darkred: [0x8b, 0x00, 0x00],\n  darksalmon: [0xe9, 0x96, 0x7a],\n  darkseagreen: [0x8f, 0xbc, 0x8f],\n  darkslateblue: [0x48, 0x3d, 0x8b],\n  darkslategray: [0x2f, 0x4f, 0x4f],\n  darkslategrey: [0x2f, 0x4f, 0x4f],\n  darkturquoise: [0x00, 0xce, 0xd1],\n  darkviolet: [0x94, 0x00, 0xd3],\n  deeppink: [0xff, 0x14, 0x93],\n  deepskyblue: [0x00, 0xbf, 0xff],\n  dimgray: [0x69, 0x69, 0x69],\n  dimgrey: [0x69, 0x69, 0x69],\n  dodgerblue: [0x1e, 0x90, 0xff],\n  firebrick: [0xb2, 0x22, 0x22],\n  floralwhite: [0xff, 0xfa, 0xf0],\n  forestgreen: [0x22, 0x8b, 0x22],\n  fuchsia: [0xff, 0x00, 0xff],\n  gainsboro: [0xdc, 0xdc, 0xdc],\n  ghostwhite: [0xf8, 0xf8, 0xff],\n  gold: [0xff, 0xd7, 0x00],\n  goldenrod: [0xda, 0xa5, 0x20],\n  gray: [0x80, 0x80, 0x80],\n  green: [0x00, 0x80, 0x00],\n  greenyellow: [0xad, 0xff, 0x2f],\n  grey: [0x80, 0x80, 0x80],\n  honeydew: [0xf0, 0xff, 0xf0],\n  hotpink: [0xff, 0x69, 0xb4],\n  indianred: [0xcd, 0x5c, 0x5c],\n  indigo: [0x4b, 0x00, 0x82],\n  ivory: [0xff, 0xff, 0xf0],\n  khaki: [0xf0, 0xe6, 0x8c],\n  lavender: [0xe6, 0xe6, 0xfa],\n  lavenderblush: [0xff, 0xf0, 0xf5],\n  lawngreen: [0x7c, 0xfc, 0x00],\n  lemonchiffon: [0xff, 0xfa, 0xcd],\n  lightblue: [0xad, 0xd8, 0xe6],\n  lightcoral: [0xf0, 0x80, 0x80],\n  lightcyan: [0xe0, 0xff, 0xff],\n  lightgoldenrodyellow: [0xfa, 0xfa, 0xd2],\n  lightgray: [0xd3, 0xd3, 0xd3],\n  lightgreen: [0x90, 0xee, 0x90],\n  lightgrey: [0xd3, 0xd3, 0xd3],\n  lightpink: [0xff, 0xb6, 0xc1],\n  lightsalmon: [0xff, 0xa0, 0x7a],\n  lightseagreen: [0x20, 0xb2, 0xaa],\n  lightskyblue: [0x87, 0xce, 0xfa],\n  lightslategray: [0x77, 0x88, 0x99],\n  lightslategrey: [0x77, 0x88, 0x99],\n  lightsteelblue: [0xb0, 0xc4, 0xde],\n  lightyellow: [0xff, 0xff, 0xe0],\n  lime: [0x00, 0xff, 0x00],\n  limegreen: [0x32, 0xcd, 0x32],\n  linen: [0xfa, 0xf0, 0xe6],\n  magenta: [0xff, 0x00, 0xff],\n  maroon: [0x80, 0x00, 0x00],\n  mediumaquamarine: [0x66, 0xcd, 0xaa],\n  mediumblue: [0x00, 0x00, 0xcd],\n  mediumorchid: [0xba, 0x55, 0xd3],\n  mediumpurple: [0x93, 0x70, 0xdb],\n  mediumseagreen: [0x3c, 0xb3, 0x71],\n  mediumslateblue: [0x7b, 0x68, 0xee],\n  mediumspringgreen: [0x00, 0xfa, 0x9a],\n  mediumturquoise: [0x48, 0xd1, 0xcc],\n  mediumvioletred: [0xc7, 0x15, 0x85],\n  midnightblue: [0x19, 0x19, 0x70],\n  mintcream: [0xf5, 0xff, 0xfa],\n  mistyrose: [0xff, 0xe4, 0xe1],\n  moccasin: [0xff, 0xe4, 0xb5],\n  navajowhite: [0xff, 0xde, 0xad],\n  navy: [0x00, 0x00, 0x80],\n  oldlace: [0xfd, 0xf5, 0xe6],\n  olive: [0x80, 0x80, 0x00],\n  olivedrab: [0x6b, 0x8e, 0x23],\n  orange: [0xff, 0xa5, 0x00],\n  orangered: [0xff, 0x45, 0x00],\n  orchid: [0xda, 0x70, 0xd6],\n  palegoldenrod: [0xee, 0xe8, 0xaa],\n  palegreen: [0x98, 0xfb, 0x98],\n  paleturquoise: [0xaf, 0xee, 0xee],\n  palevioletred: [0xdb, 0x70, 0x93],\n  papayawhip: [0xff, 0xef, 0xd5],\n  peachpuff: [0xff, 0xda, 0xb9],\n  peru: [0xcd, 0x85, 0x3f],\n  pink: [0xff, 0xc0, 0xcb],\n  plum: [0xdd, 0xa0, 0xdd],\n  powderblue: [0xb0, 0xe0, 0xe6],\n  purple: [0x80, 0x00, 0x80],\n  rebeccapurple: [0x66, 0x33, 0x99],\n  red: [0xff, 0x00, 0x00],\n  rosybrown: [0xbc, 0x8f, 0x8f],\n  royalblue: [0x41, 0x69, 0xe1],\n  saddlebrown: [0x8b, 0x45, 0x13],\n  salmon: [0xfa, 0x80, 0x72],\n  sandybrown: [0xf4, 0xa4, 0x60],\n  seagreen: [0x2e, 0x8b, 0x57],\n  seashell: [0xff, 0xf5, 0xee],\n  sienna: [0xa0, 0x52, 0x2d],\n  silver: [0xc0, 0xc0, 0xc0],\n  skyblue: [0x87, 0xce, 0xeb],\n  slateblue: [0x6a, 0x5a, 0xcd],\n  slategray: [0x70, 0x80, 0x90],\n  slategrey: [0x70, 0x80, 0x90],\n  snow: [0xff, 0xfa, 0xfa],\n  springgreen: [0x00, 0xff, 0x7f],\n  steelblue: [0x46, 0x82, 0xb4],\n  tan: [0xd2, 0xb4, 0x8c],\n  teal: [0x00, 0x80, 0x80],\n  thistle: [0xd8, 0xbf, 0xd8],\n  tomato: [0xff, 0x63, 0x47],\n  turquoise: [0x40, 0xe0, 0xd0],\n  violet: [0xee, 0x82, 0xee],\n  wheat: [0xf5, 0xde, 0xb3],\n  white: [0xff, 0xff, 0xff],\n  whitesmoke: [0xf5, 0xf5, 0xf5],\n  yellow: [0xff, 0xff, 0x00],\n  yellowgreen: [0x9a, 0xcd, 0x32]\n} as const satisfies {\n  [key: string]: TriColorChannels;\n};\n\n/**\n * cache invalid color value\n * @param key - cache key\n * @param nullable - is nullable\n * @returns cached value\n */\nexport const cacheInvalidColorValue = (\n  cacheKey: string,\n  format: string,\n  nullable: boolean = false\n): SpecifiedColorChannels | string | NullObject => {\n  if (format === VAL_SPEC) {\n    const res = '';\n    setCache(cacheKey, res);\n    return res;\n  }\n  if (nullable) {\n    setCache(cacheKey, null);\n    return new NullObject();\n  }\n  const res: SpecifiedColorChannels = ['rgb', 0, 0, 0, 0];\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * resolve invalid color value\n * @param format - output format\n * @param nullable - is nullable\n * @returns resolved value\n */\nexport const resolveInvalidColorValue = (\n  format: string,\n  nullable: boolean = false\n): SpecifiedColorChannels | string | NullObject => {\n  switch (format) {\n    case 'hsl':\n    case 'hwb':\n    case VAL_MIX: {\n      return new NullObject();\n    }\n    case VAL_SPEC: {\n      return '';\n    }\n    default: {\n      if (nullable) {\n        return new NullObject();\n      }\n      return ['rgb', 0, 0, 0, 0] as SpecifiedColorChannels;\n    }\n  }\n};\n\n/**\n * validate color components\n * @param arr - color components\n * @param [opt] - options\n * @param [opt.alpha] - alpha channel\n * @param [opt.minLength] - min length\n * @param [opt.maxLength] - max length\n * @param [opt.minRange] - min range\n * @param [opt.maxRange] - max range\n * @param [opt.validateRange] - validate range\n * @returns result - validated color components\n */\nexport const validateColorComponents = (\n  arr: ColorChannels | TriColorChannels,\n  opt: {\n    alpha?: boolean;\n    minLength?: number;\n    maxLength?: number;\n    minRange?: number;\n    maxRange?: number;\n    validateRange?: boolean;\n  } = {}\n): ColorChannels | TriColorChannels => {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(`${arr} is not an array.`);\n  }\n  const {\n    alpha = false,\n    minLength = TRIA,\n    maxLength = QUAD,\n    minRange = 0,\n    maxRange = 1,\n    validateRange = true\n  } = opt;\n  if (!Number.isFinite(minLength)) {\n    throw new TypeError(`${minLength} is not a number.`);\n  }\n  if (!Number.isFinite(maxLength)) {\n    throw new TypeError(`${maxLength} is not a number.`);\n  }\n  if (!Number.isFinite(minRange)) {\n    throw new TypeError(`${minRange} is not a number.`);\n  }\n  if (!Number.isFinite(maxRange)) {\n    throw new TypeError(`${maxRange} is not a number.`);\n  }\n  const l = arr.length;\n  if (l < minLength || l > maxLength) {\n    throw new Error(`Unexpected array length ${l}.`);\n  }\n  let i = 0;\n  while (i < l) {\n    const v = arr[i] as number;\n    if (!Number.isFinite(v)) {\n      throw new TypeError(`${v} is not a number.`);\n    } else if (i < TRIA && validateRange && (v < minRange || v > maxRange)) {\n      throw new RangeError(`${v} is not between ${minRange} and ${maxRange}.`);\n    } else if (i === TRIA && (v < 0 || v > 1)) {\n      throw new RangeError(`${v} is not between 0 and 1.`);\n    }\n    i++;\n  }\n  if (alpha && l === TRIA) {\n    arr.push(1);\n  }\n  return arr;\n};\n\n/**\n * transform matrix\n * @param mtx - 3 * 3 matrix\n * @param vct - vector\n * @param [skip] - skip validate\n * @returns TriColorChannels - [p1, p2, p3]\n */\nexport const transformMatrix = (\n  mtx: ColorMatrix,\n  vct: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!Array.isArray(mtx)) {\n    throw new TypeError(`${mtx} is not an array.`);\n  } else if (mtx.length !== TRIA) {\n    throw new Error(`Unexpected array length ${mtx.length}.`);\n  } else if (!skip) {\n    for (let i of mtx) {\n      i = validateColorComponents(i as TriColorChannels, {\n        maxLength: TRIA,\n        validateRange: false\n      }) as TriColorChannels;\n    }\n  }\n  const [[r1c1, r1c2, r1c3], [r2c1, r2c2, r2c3], [r3c1, r3c2, r3c3]] = mtx;\n  let v1, v2, v3;\n  if (skip) {\n    [v1, v2, v3] = vct;\n  } else {\n    [v1, v2, v3] = validateColorComponents(vct, {\n      maxLength: TRIA,\n      validateRange: false\n    });\n  }\n  const p1 = r1c1 * v1 + r1c2 * v2 + r1c3 * v3;\n  const p2 = r2c1 * v1 + r2c2 * v2 + r2c3 * v3;\n  const p3 = r3c1 * v1 + r3c2 * v2 + r3c3 * v3;\n  return [p1, p2, p3];\n};\n\n/**\n * normalize color components\n * @param colorA - color components [v1, v2, v3, v4]\n * @param colorB - color components [v1, v2, v3, v4]\n * @param [skip] - skip validate\n * @returns result - [colorA, colorB]\n */\nexport const normalizeColorComponents = (\n  colorA: [number | string, number | string, number | string, number | string],\n  colorB: [number | string, number | string, number | string, number | string],\n  skip: boolean = false\n): [ColorChannels, ColorChannels] => {\n  if (!Array.isArray(colorA)) {\n    throw new TypeError(`${colorA} is not an array.`);\n  } else if (colorA.length !== QUAD) {\n    throw new Error(`Unexpected array length ${colorA.length}.`);\n  }\n  if (!Array.isArray(colorB)) {\n    throw new TypeError(`${colorB} is not an array.`);\n  } else if (colorB.length !== QUAD) {\n    throw new Error(`Unexpected array length ${colorB.length}.`);\n  }\n  let i = 0;\n  while (i < QUAD) {\n    if (colorA[i] === NONE && colorB[i] === NONE) {\n      colorA[i] = 0;\n      colorB[i] = 0;\n    } else if (colorA[i] === NONE) {\n      colorA[i] = colorB[i] as number;\n    } else if (colorB[i] === NONE) {\n      colorB[i] = colorA[i] as number;\n    }\n    i++;\n  }\n  if (skip) {\n    return [colorA as ColorChannels, colorB as ColorChannels];\n  }\n  const validatedColorA = validateColorComponents(colorA as ColorChannels, {\n    minLength: QUAD,\n    validateRange: false\n  });\n  const validatedColorB = validateColorComponents(colorB as ColorChannels, {\n    minLength: QUAD,\n    validateRange: false\n  });\n  return [validatedColorA as ColorChannels, validatedColorB as ColorChannels];\n};\n\n/**\n * number to hex string\n * @param value - numeric value\n * @returns hex string\n */\nexport const numberToHexString = (value: number): string => {\n  if (!Number.isFinite(value)) {\n    throw new TypeError(`${value} is not a number.`);\n  } else {\n    value = Math.round(value);\n    if (value < 0 || value > MAX_RGB) {\n      throw new RangeError(`${value} is not between 0 and ${MAX_RGB}.`);\n    }\n  }\n  let hex = value.toString(HEX);\n  if (hex.length === 1) {\n    hex = `0${hex}`;\n  }\n  return hex;\n};\n\n/**\n * angle to deg\n * @param angle\n * @returns deg: 0..360\n */\nexport const angleToDeg = (angle: string): number => {\n  if (isString(angle)) {\n    angle = angle.trim();\n  } else {\n    throw new TypeError(`${angle} is not a string.`);\n  }\n  const GRAD = DEG / 400;\n  const RAD = DEG / (Math.PI * DUO);\n  const reg = new RegExp(`^(${NUM})(${ANGLE})?$`);\n  if (!reg.test(angle)) {\n    throw new SyntaxError(`Invalid property value: ${angle}`);\n  }\n  const [, value, unit] = angle.match(reg) as MatchedRegExp;\n  let deg;\n  switch (unit) {\n    case 'grad':\n      deg = parseFloat(value) * GRAD;\n      break;\n    case 'rad':\n      deg = parseFloat(value) * RAD;\n      break;\n    case 'turn':\n      deg = parseFloat(value) * DEG;\n      break;\n    default:\n      deg = parseFloat(value);\n  }\n  deg %= DEG;\n  if (deg < 0) {\n    deg += DEG;\n  } else if (Object.is(deg, -0)) {\n    deg = 0;\n  }\n  return deg;\n};\n\n/**\n * parse alpha\n * @param [alpha] - alpha value\n * @returns alpha: 0..1\n */\nexport const parseAlpha = (alpha: string = ''): number => {\n  if (isString(alpha)) {\n    alpha = alpha.trim();\n    if (!alpha) {\n      alpha = '1';\n    } else if (alpha === NONE) {\n      alpha = '0';\n    } else {\n      let a;\n      if (alpha.endsWith('%')) {\n        a = parseFloat(alpha) / MAX_PCT;\n      } else {\n        a = parseFloat(alpha);\n      }\n      if (!Number.isFinite(a)) {\n        throw new TypeError(`${a} is not a finite number.`);\n      }\n      if (a < PPTH) {\n        alpha = '0';\n      } else if (a > 1) {\n        alpha = '1';\n      } else {\n        alpha = a.toFixed(TRIA);\n      }\n    }\n  } else {\n    alpha = '1';\n  }\n  return parseFloat(alpha);\n};\n\n/**\n * parse hex alpha\n * @param value - alpha value in hex string\n * @returns alpha: 0..1\n */\nexport const parseHexAlpha = (value: string): number => {\n  if (isString(value)) {\n    if (value === '') {\n      throw new SyntaxError('Invalid property value: (empty string)');\n    }\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  let alpha = parseInt(value, HEX);\n  if (alpha <= 0) {\n    return 0;\n  }\n  if (alpha >= MAX_RGB) {\n    return 1;\n  }\n  const alphaMap = new Map();\n  for (let i = 1; i < MAX_PCT; i++) {\n    alphaMap.set(Math.round((i * MAX_RGB) / MAX_PCT), i);\n  }\n  if (alphaMap.has(alpha)) {\n    alpha = alphaMap.get(alpha) / MAX_PCT;\n  } else {\n    alpha = Math.round(alpha / MAX_RGB / PPTH) * PPTH;\n  }\n  return parseFloat(alpha.toFixed(TRIA));\n};\n\n/**\n * transform rgb to linear rgb\n * @param rgb - [r, g, b] r|g|b: 0..255\n * @param [skip] - skip validate\n * @returns TriColorChannels - [r, g, b] r|g|b: 0..1\n */\nexport const transformRgbToLinearRgb = (\n  rgb: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  let rr, gg, bb;\n  if (skip) {\n    [rr, gg, bb] = rgb;\n  } else {\n    [rr, gg, bb] = validateColorComponents(rgb, {\n      maxLength: TRIA,\n      maxRange: MAX_RGB\n    });\n  }\n  let r = rr / MAX_RGB;\n  let g = gg / MAX_RGB;\n  let b = bb / MAX_RGB;\n  const COND_POW = 0.04045;\n  if (r > COND_POW) {\n    r = Math.pow((r + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    r /= LINEAR_COEF;\n  }\n  if (g > COND_POW) {\n    g = Math.pow((g + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    g /= LINEAR_COEF;\n  }\n  if (b > COND_POW) {\n    b = Math.pow((b + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    b /= LINEAR_COEF;\n  }\n  return [r, g, b];\n};\n\n/**\n * transform rgb to xyz\n * @param rgb - [r, g, b] r|g|b: 0..255\n * @param [skip] - skip validate\n * @returns TriColorChannels - [x, y, z]\n */\nexport const transformRgbToXyz = (\n  rgb: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!skip) {\n    rgb = validateColorComponents(rgb, {\n      maxLength: TRIA,\n      maxRange: MAX_RGB\n    }) as TriColorChannels;\n  }\n  rgb = transformRgbToLinearRgb(rgb, true);\n  const xyz = transformMatrix(MATRIX_L_RGB_TO_XYZ, rgb, true);\n  return xyz;\n};\n\n/**\n * transform rgb to xyz-d50\n * @param rgb - [r, g, b] r|g|b: 0..255 alpha: 0..1\n * @returns TriColorChannels - [x, y, z]\n */\nexport const transformRgbToXyzD50 = (\n  rgb: TriColorChannels\n): TriColorChannels => {\n  let xyz = transformRgbToXyz(rgb);\n  xyz = transformMatrix(MATRIX_D65_TO_D50, xyz, true);\n  return xyz;\n};\n\n/**\n * transform linear rgb to rgb\n * @param rgb - [r, g, b] r|g|b: 0..1\n * @param [round] - round result\n * @returns TriColorChannels - [r, g, b] r|g|b: 0..255\n */\nexport const transformLinearRgbToRgb = (\n  rgb: TriColorChannels,\n  round: boolean = false\n): TriColorChannels => {\n  let [r, g, b] = validateColorComponents(rgb, {\n    maxLength: TRIA\n  });\n  const COND_POW = 809 / 258400;\n  if (r > COND_POW) {\n    r = Math.pow(r, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    r *= LINEAR_COEF;\n  }\n  r *= MAX_RGB;\n  if (g > COND_POW) {\n    g = Math.pow(g, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    g *= LINEAR_COEF;\n  }\n  g *= MAX_RGB;\n  if (b > COND_POW) {\n    b = Math.pow(b, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    b *= LINEAR_COEF;\n  }\n  b *= MAX_RGB;\n  return [\n    round ? Math.round(r) : r,\n    round ? Math.round(g) : g,\n    round ? Math.round(b) : b\n  ];\n};\n\n/**\n * transform xyz to rgb\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [r, g, b] r|g|b: 0..255\n */\nexport const transformXyzToRgb = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!skip) {\n    xyz = validateColorComponents(xyz, {\n      maxLength: TRIA,\n      validateRange: false\n    }) as TriColorChannels;\n  }\n  let [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, xyz, true);\n  [r, g, b] = transformLinearRgbToRgb(\n    [\n      Math.min(Math.max(r, 0), 1),\n      Math.min(Math.max(g, 0), 1),\n      Math.min(Math.max(b, 0), 1)\n    ],\n    true\n  );\n  return [r, g, b];\n};\n\n/**\n * transform xyz to xyz-d50\n * @param xyz - [x, y, z]\n * @returns TriColorChannels - [x, y, z]\n */\nexport const transformXyzToXyzD50 = (\n  xyz: TriColorChannels\n): TriColorChannels => {\n  xyz = validateColorComponents(xyz, {\n    maxLength: TRIA,\n    validateRange: false\n  }) as TriColorChannels;\n  xyz = transformMatrix(MATRIX_D65_TO_D50, xyz, true);\n  return xyz;\n};\n\n/**\n * transform xyz to hsl\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [h, s, l]\n */\nexport const transformXyzToHsl = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  const [rr, gg, bb] = transformXyzToRgb(xyz, skip);\n  const r = rr / MAX_RGB;\n  const g = gg / MAX_RGB;\n  const b = bb / MAX_RGB;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const d = max - min;\n  const l = (max + min) * HALF * MAX_PCT;\n  let h, s;\n  if (Math.round(l) === 0 || Math.round(l) === MAX_PCT) {\n    h = 0;\n    s = 0;\n  } else {\n    s = (d / (1 - Math.abs(max + min - 1))) * MAX_PCT;\n    if (s === 0) {\n      h = 0;\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d;\n          break;\n        case g:\n          h = (b - r) / d + DUO;\n          break;\n        case b:\n        default:\n          h = (r - g) / d + QUAD;\n          break;\n      }\n      h = (h * SEXA) % DEG;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [h, s, l];\n};\n\n/**\n * transform xyz to hwb\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [h, w, b]\n */\nexport const transformXyzToHwb = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  const [r, g, b] = transformXyzToRgb(xyz, skip);\n  const wh = Math.min(r, g, b) / MAX_RGB;\n  const bk = 1 - Math.max(r, g, b) / MAX_RGB;\n  let h;\n  if (wh + bk === 1) {\n    h = 0;\n  } else {\n    [h] = transformXyzToHsl(xyz);\n  }\n  return [h, wh * MAX_PCT, bk * MAX_PCT];\n};\n\n/**\n * transform xyz to oklab\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [l, a, b]\n */\nexport const transformXyzToOklab = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!skip) {\n    xyz = validateColorComponents(xyz, {\n      maxLength: TRIA,\n      validateRange: false\n    }) as TriColorChannels;\n  }\n  const lms = transformMatrix(MATRIX_XYZ_TO_LMS, xyz, true);\n  const xyzLms = lms.map(c => Math.cbrt(c)) as TriColorChannels;\n  let [l, a, b] = transformMatrix(MATRIX_LMS_TO_OKLAB, xyzLms, true);\n  l = Math.min(Math.max(l, 0), 1);\n  const lPct = Math.round(parseFloat(l.toFixed(QUAD)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    a = 0;\n    b = 0;\n  }\n  return [l, a, b];\n};\n\n/**\n * transform xyz to oklch\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [l, c, h]\n */\nexport const transformXyzToOklch = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  const [l, a, b] = transformXyzToOklab(xyz, skip);\n  let c, h;\n  const lPct = Math.round(parseFloat(l.toFixed(QUAD)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    c = 0;\n    h = 0;\n  } else {\n    c = Math.max(Math.sqrt(Math.pow(a, POW_SQR) + Math.pow(b, POW_SQR)), 0);\n    if (parseFloat(c.toFixed(QUAD)) === 0) {\n      h = 0;\n    } else {\n      h = (Math.atan2(b, a) * DEG_HALF) / Math.PI;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [l, c, h];\n};\n\n/**\n * transform xyz D50 to rgb\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [r, g, b] r|g|b: 0..255\n */\nexport const transformXyzD50ToRgb = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!skip) {\n    xyz = validateColorComponents(xyz, {\n      maxLength: TRIA,\n      validateRange: false\n    }) as TriColorChannels;\n  }\n  const xyzD65 = transformMatrix(MATRIX_D50_TO_D65, xyz, true);\n  const rgb = transformXyzToRgb(xyzD65, true);\n  return rgb;\n};\n\n/**\n * transform xyz-d50 to lab\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [l, a, b]\n */\nexport const transformXyzD50ToLab = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  if (!skip) {\n    xyz = validateColorComponents(xyz, {\n      maxLength: TRIA,\n      validateRange: false\n    }) as TriColorChannels;\n  }\n  const xyzD50 = xyz.map((val, i) => val / (D50[i] as number));\n  const [f0, f1, f2] = xyzD50.map(val =>\n    val > LAB_EPSILON ? Math.cbrt(val) : (val * LAB_KAPPA + HEX) / LAB_L\n  ) as TriColorChannels;\n  const l = Math.min(Math.max(LAB_L * f1 - HEX, 0), MAX_PCT);\n  let a, b;\n  if (l === 0 || l === MAX_PCT) {\n    a = 0;\n    b = 0;\n  } else {\n    a = (f0 - f1) * LAB_A;\n    b = (f1 - f2) * LAB_B;\n  }\n  return [l, a, b];\n};\n\n/**\n * transform xyz-d50 to lch\n * @param xyz - [x, y, z]\n * @param [skip] - skip validate\n * @returns TriColorChannels - [l, c, h]\n */\nexport const transformXyzD50ToLch = (\n  xyz: TriColorChannels,\n  skip: boolean = false\n): TriColorChannels => {\n  const [l, a, b] = transformXyzD50ToLab(xyz, skip);\n  let c, h;\n  if (l === 0 || l === MAX_PCT) {\n    c = 0;\n    h = 0;\n  } else {\n    c = Math.max(Math.sqrt(Math.pow(a, POW_SQR) + Math.pow(b, POW_SQR)), 0);\n    h = (Math.atan2(b, a) * DEG_HALF) / Math.PI;\n    if (h < 0) {\n      h += DEG;\n    }\n  }\n  return [l, c, h];\n};\n\n/**\n * convert rgb to hex color\n * @param rgb - [r, g, b, alpha] r|g|b: 0..255 alpha: 0..1\n * @returns hex color\n */\nexport const convertRgbToHex = (rgb: ColorChannels): string => {\n  const [r, g, b, alpha] = validateColorComponents(rgb, {\n    alpha: true,\n    maxRange: MAX_RGB\n  }) as ColorChannels;\n  const rr = numberToHexString(r);\n  const gg = numberToHexString(g);\n  const bb = numberToHexString(b);\n  const aa = numberToHexString(alpha * MAX_RGB);\n  let hex;\n  if (aa === 'ff') {\n    hex = `#${rr}${gg}${bb}`;\n  } else {\n    hex = `#${rr}${gg}${bb}${aa}`;\n  }\n  return hex;\n};\n\n/**\n * convert linear rgb to hex color\n * @param rgb - [r, g, b, alpha] r|g|b|alpha: 0..1\n * @param [skip] - skip validate\n * @returns hex color\n */\nexport const convertLinearRgbToHex = (\n  rgb: ColorChannels,\n  skip: boolean = false\n): string => {\n  let r, g, b, alpha;\n  if (skip) {\n    [r, g, b, alpha] = rgb;\n  } else {\n    [r, g, b, alpha] = validateColorComponents(rgb, {\n      minLength: QUAD\n    }) as ColorChannels;\n  }\n  [r, g, b] = transformLinearRgbToRgb([r, g, b], true);\n  const rr = numberToHexString(r);\n  const gg = numberToHexString(g);\n  const bb = numberToHexString(b);\n  const aa = numberToHexString(alpha * MAX_RGB);\n  let hex;\n  if (aa === 'ff') {\n    hex = `#${rr}${gg}${bb}`;\n  } else {\n    hex = `#${rr}${gg}${bb}${aa}`;\n  }\n  return hex;\n};\n\n/**\n * convert xyz to hex color\n * @param xyz - [x, y, z, alpha]\n * @returns hex color\n */\nexport const convertXyzToHex = (xyz: ColorChannels): string => {\n  const [x, y, z, alpha] = validateColorComponents(xyz, {\n    minLength: QUAD,\n    validateRange: false\n  }) as ColorChannels;\n  const [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  const hex = convertLinearRgbToHex(\n    [\n      Math.min(Math.max(r, 0), 1),\n      Math.min(Math.max(g, 0), 1),\n      Math.min(Math.max(b, 0), 1),\n      alpha\n    ],\n    true\n  );\n  return hex;\n};\n\n/**\n * convert xyz D50 to hex color\n * @param xyz - [x, y, z, alpha]\n * @returns hex color\n */\nexport const convertXyzD50ToHex = (xyz: ColorChannels): string => {\n  const [x, y, z, alpha] = validateColorComponents(xyz, {\n    minLength: QUAD,\n    validateRange: false\n  }) as ColorChannels;\n  const xyzD65 = transformMatrix(MATRIX_D50_TO_D65, [x, y, z], true);\n  const [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, xyzD65, true);\n  const hex = convertLinearRgbToHex([\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1),\n    alpha\n  ]);\n  return hex;\n};\n\n/**\n * convert hex color to rgb\n * @param value - hex color value\n * @returns ColorChannels - [r, g, b, alpha] r|g|b: 0..255 alpha: 0..1\n */\nexport const convertHexToRgb = (value: string): ColorChannels => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  if (\n    !(\n      /^#[\\da-f]{6}$/.test(value) ||\n      /^#[\\da-f]{3}$/.test(value) ||\n      /^#[\\da-f]{8}$/.test(value) ||\n      /^#[\\da-f]{4}$/.test(value)\n    )\n  ) {\n    throw new SyntaxError(`Invalid property value: ${value}`);\n  }\n  const arr: number[] = [];\n  if (/^#[\\da-f]{3}$/.test(value)) {\n    const [, r, g, b] = value.match(\n      /^#([\\da-f])([\\da-f])([\\da-f])$/\n    ) as MatchedRegExp;\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      1\n    );\n  } else if (/^#[\\da-f]{4}$/.test(value)) {\n    const [, r, g, b, alpha] = value.match(\n      /^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])$/\n    ) as MatchedRegExp;\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      parseHexAlpha(`${alpha}${alpha}`)\n    );\n  } else if (/^#[\\da-f]{8}$/.test(value)) {\n    const [, r, g, b, alpha] = value.match(\n      /^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/\n    ) as MatchedRegExp;\n    arr.push(\n      parseInt(r, HEX),\n      parseInt(g, HEX),\n      parseInt(b, HEX),\n      parseHexAlpha(alpha)\n    );\n  } else {\n    const [, r, g, b] = value.match(\n      /^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/\n    ) as MatchedRegExp;\n    arr.push(parseInt(r, HEX), parseInt(g, HEX), parseInt(b, HEX), 1);\n  }\n  return arr as ColorChannels;\n};\n\n/**\n * convert hex color to linear rgb\n * @param value - hex color value\n * @returns ColorChannels - [r, g, b, alpha] r|g|b|alpha: 0..1\n */\nexport const convertHexToLinearRgb = (value: string): ColorChannels => {\n  const [rr, gg, bb, alpha] = convertHexToRgb(value);\n  const [r, g, b] = transformRgbToLinearRgb([rr, gg, bb], true);\n  return [r, g, b, alpha];\n};\n\n/**\n * convert hex color to xyz\n * @param value - hex color value\n * @returns ColorChannels - [x, y, z, alpha]\n */\nexport const convertHexToXyz = (value: string): ColorChannels => {\n  const [r, g, b, alpha] = convertHexToLinearRgb(value);\n  const [x, y, z] = transformMatrix(MATRIX_L_RGB_TO_XYZ, [r, g, b], true);\n  return [x, y, z, alpha];\n};\n\n/**\n * parse rgb()\n * @param value - rgb color value\n * @param [opt] - options\n * @returns parsed color - ['rgb', r, g, b, alpha], '(empty)', NullObject\n */\nexport const parseRgb = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  const reg = new RegExp(`^rgba?\\\\(\\\\s*(${SYN_MOD}|${SYN_RGB_LV3})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const [, val] = value.match(reg) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace(/[,/]/g, ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let r, g, b;\n  if (v1 === NONE) {\n    r = 0;\n  } else {\n    if (v1.endsWith('%')) {\n      r = (parseFloat(v1) * MAX_RGB) / MAX_PCT;\n    } else {\n      r = parseFloat(v1);\n    }\n    r = Math.min(Math.max(roundToPrecision(r, OCT), 0), MAX_RGB);\n  }\n  if (v2 === NONE) {\n    g = 0;\n  } else {\n    if (v2.endsWith('%')) {\n      g = (parseFloat(v2) * MAX_RGB) / MAX_PCT;\n    } else {\n      g = parseFloat(v2);\n    }\n    g = Math.min(Math.max(roundToPrecision(g, OCT), 0), MAX_RGB);\n  }\n  if (v3 === NONE) {\n    b = 0;\n  } else {\n    if (v3.endsWith('%')) {\n      b = (parseFloat(v3) * MAX_RGB) / MAX_PCT;\n    } else {\n      b = parseFloat(v3);\n    }\n    b = Math.min(Math.max(roundToPrecision(b, OCT), 0), MAX_RGB);\n  }\n  const alpha = parseAlpha(v4);\n  return ['rgb', r, g, b, format === VAL_MIX && v4 === NONE ? NONE : alpha];\n};\n\n/**\n * parse hsl()\n * @param value - hsl color value\n * @param [opt] - options\n * @returns parsed color - ['rgb', r, g, b, alpha], '(empty)', NullObject\n */\nexport const parseHsl = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_HSL.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const [, val] = value.match(REG_HSL) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace(/[,/]/g, ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let h, s, l;\n  if (v1 === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(v1);\n  }\n  if (v2 === NONE) {\n    s = 0;\n  } else {\n    s = Math.min(Math.max(parseFloat(v2), 0), MAX_PCT);\n  }\n  if (v3 === NONE) {\n    l = 0;\n  } else {\n    l = Math.min(Math.max(parseFloat(v3), 0), MAX_PCT);\n  }\n  const alpha = parseAlpha(v4);\n  if (format === 'hsl') {\n    return [\n      format,\n      v1 === NONE ? v1 : h,\n      v2 === NONE ? v2 : s,\n      v3 === NONE ? v3 : l,\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  h = (h / DEG) * DOZ;\n  l /= MAX_PCT;\n  const sa = (s / MAX_PCT) * Math.min(l, 1 - l);\n  const rk = h % DOZ;\n  const gk = (8 + h) % DOZ;\n  const bk = (4 + h) % DOZ;\n  const r = l - sa * Math.max(-1, Math.min(rk - TRIA, TRIA ** POW_SQR - rk, 1));\n  const g = l - sa * Math.max(-1, Math.min(gk - TRIA, TRIA ** POW_SQR - gk, 1));\n  const b = l - sa * Math.max(-1, Math.min(bk - TRIA, TRIA ** POW_SQR - bk, 1));\n  return [\n    'rgb',\n    Math.min(Math.max(roundToPrecision(r * MAX_RGB, OCT), 0), MAX_RGB),\n    Math.min(Math.max(roundToPrecision(g * MAX_RGB, OCT), 0), MAX_RGB),\n    Math.min(Math.max(roundToPrecision(b * MAX_RGB, OCT), 0), MAX_RGB),\n    alpha\n  ];\n};\n\n/**\n * parse hwb()\n * @param value - hwb color value\n * @param [opt] - options\n * @returns parsed color - ['rgb', r, g, b, alpha], '(empty)', NullObject\n */\nexport const parseHwb = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_HWB.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const [, val] = value.match(REG_HWB) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let h, wh, bk;\n  if (v1 === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(v1);\n  }\n  if (v2 === NONE) {\n    wh = 0;\n  } else {\n    wh = Math.min(Math.max(parseFloat(v2), 0), MAX_PCT) / MAX_PCT;\n  }\n  if (v3 === NONE) {\n    bk = 0;\n  } else {\n    bk = Math.min(Math.max(parseFloat(v3), 0), MAX_PCT) / MAX_PCT;\n  }\n  const alpha = parseAlpha(v4);\n  if (format === 'hwb') {\n    return [\n      format,\n      v1 === NONE ? v1 : h,\n      v2 === NONE ? v2 : wh * MAX_PCT,\n      v3 === NONE ? v3 : bk * MAX_PCT,\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  if (wh + bk >= 1) {\n    const v = roundToPrecision((wh / (wh + bk)) * MAX_RGB, OCT);\n    return ['rgb', v, v, v, alpha];\n  }\n  const factor = (1 - wh - bk) / MAX_RGB;\n  let [, r, g, b] = parseHsl(`hsl(${h} 100 50)`) as ComputedColorChannels;\n  r = roundToPrecision((r * factor + wh) * MAX_RGB, OCT);\n  g = roundToPrecision((g * factor + wh) * MAX_RGB, OCT);\n  b = roundToPrecision((b * factor + wh) * MAX_RGB, OCT);\n  return [\n    'rgb',\n    Math.min(Math.max(r, 0), MAX_RGB),\n    Math.min(Math.max(g, 0), MAX_RGB),\n    Math.min(Math.max(b, 0), MAX_RGB),\n    alpha\n  ];\n};\n\n/**\n * parse lab()\n * @param value - lab color value\n * @param [opt] - options\n * @returns parsed color\n *   - [xyz-d50, x, y, z, alpha], ['lab', l, a, b, alpha], '(empty)', NullObject\n */\nexport const parseLab = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_LAB.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const COEF_PCT = 1.25;\n  const COND_POW = 8;\n  const [, val] = value.match(REG_LAB) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let l, a, b;\n  if (v1 === NONE) {\n    l = 0;\n  } else {\n    if (v1.endsWith('%')) {\n      l = parseFloat(v1);\n      if (l > MAX_PCT) {\n        l = MAX_PCT;\n      }\n    } else {\n      l = parseFloat(v1);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (v2 === NONE) {\n    a = 0;\n  } else {\n    a = v2.endsWith('%') ? parseFloat(v2) * COEF_PCT : parseFloat(v2);\n  }\n  if (v3 === NONE) {\n    b = 0;\n  } else {\n    b = v3.endsWith('%') ? parseFloat(v3) * COEF_PCT : parseFloat(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format)) {\n    return [\n      'lab',\n      v1 === NONE ? v1 : roundToPrecision(l, HEX),\n      v2 === NONE ? v2 : roundToPrecision(a, HEX),\n      v3 === NONE ? v3 : roundToPrecision(b, HEX),\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  const fl = (l + HEX) / LAB_L;\n  const fa = a / LAB_A + fl;\n  const fb = fl - b / LAB_B;\n  const powFl = Math.pow(fl, POW_CUBE);\n  const powFa = Math.pow(fa, POW_CUBE);\n  const powFb = Math.pow(fb, POW_CUBE);\n  const xyz = [\n    powFa > LAB_EPSILON ? powFa : (fa * LAB_L - HEX) / LAB_KAPPA,\n    l > COND_POW ? powFl : l / LAB_KAPPA,\n    powFb > LAB_EPSILON ? powFb : (fb * LAB_L - HEX) / LAB_KAPPA\n  ];\n  const [x, y, z] = xyz.map(\n    (val, i) => val * (D50[i] as number)\n  ) as TriColorChannels;\n  return [\n    'xyz-d50',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    alpha\n  ];\n};\n\n/**\n * parse lch()\n * @param value - lch color value\n * @param [opt] - options\n * @returns parsed color\n *   - ['xyz-d50', x, y, z, alpha], ['lch', l, c, h, alpha]\n *   - '(empty)', NullObject\n */\nexport const parseLch = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_LCH.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const COEF_PCT = 1.5;\n  const [, val] = value.match(REG_LCH) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let l, c, h;\n  if (v1 === NONE) {\n    l = 0;\n  } else {\n    l = parseFloat(v1);\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (v2 === NONE) {\n    c = 0;\n  } else {\n    c = v2.endsWith('%') ? parseFloat(v2) * COEF_PCT : parseFloat(v2);\n  }\n  if (v3 === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format)) {\n    return [\n      'lch',\n      v1 === NONE ? v1 : roundToPrecision(l, HEX),\n      v2 === NONE ? v2 : roundToPrecision(c, HEX),\n      v3 === NONE ? v3 : roundToPrecision(h, HEX),\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  const a = c * Math.cos((h * Math.PI) / DEG_HALF);\n  const b = c * Math.sin((h * Math.PI) / DEG_HALF);\n  const [, x, y, z] = parseLab(`lab(${l} ${a} ${b})`) as ComputedColorChannels;\n  return [\n    'xyz-d50',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    alpha as number\n  ];\n};\n\n/**\n * parse oklab()\n * @param value - oklab color value\n * @param [opt] - options\n * @returns parsed color\n *   - ['xyz-d65', x, y, z, alpha], ['oklab', l, a, b, alpha]\n *   - '(empty)', NullObject\n */\nexport const parseOklab = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_OKLAB.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(REG_OKLAB) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let l, a, b;\n  if (v1 === NONE) {\n    l = 0;\n  } else {\n    l = v1.endsWith('%') ? parseFloat(v1) / MAX_PCT : parseFloat(v1);\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (v2 === NONE) {\n    a = 0;\n  } else if (v2.endsWith('%')) {\n    a = (parseFloat(v2) * COEF_PCT) / MAX_PCT;\n  } else {\n    a = parseFloat(v2);\n  }\n  if (v3 === NONE) {\n    b = 0;\n  } else if (v3.endsWith('%')) {\n    b = (parseFloat(v3) * COEF_PCT) / MAX_PCT;\n  } else {\n    b = parseFloat(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format)) {\n    return [\n      'oklab',\n      v1 === NONE ? v1 : roundToPrecision(l, HEX),\n      v2 === NONE ? v2 : roundToPrecision(a, HEX),\n      v3 === NONE ? v3 : roundToPrecision(b, HEX),\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [l, a, b]);\n  const xyzLms = lms.map(c => Math.pow(c, POW_CUBE)) as TriColorChannels;\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms, true);\n  return [\n    'xyz-d65',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    alpha as number\n  ];\n};\n\n/**\n * parse oklch()\n * @param value - oklch color value\n * @param [opt] - options\n * @returns parsed color\n *   - ['xyz-d65', x, y, z, alpha], ['oklch', l, c, h, alpha]\n *   - '(empty)', NullObject\n */\nexport const parseOklch = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  if (!REG_OKLCH.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(REG_OKLCH) as MatchedRegExp;\n  const [v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorChannels;\n  let l, c, h;\n  if (v1 === NONE) {\n    l = 0;\n  } else {\n    l = v1.endsWith('%') ? parseFloat(v1) / MAX_PCT : parseFloat(v1);\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (v2 === NONE) {\n    c = 0;\n  } else {\n    if (v2.endsWith('%')) {\n      c = (parseFloat(v2) * COEF_PCT) / MAX_PCT;\n    } else {\n      c = parseFloat(v2);\n    }\n    if (c < 0) {\n      c = 0;\n    }\n  }\n  if (v3 === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format)) {\n    return [\n      'oklch',\n      v1 === NONE ? v1 : roundToPrecision(l, HEX),\n      v2 === NONE ? v2 : roundToPrecision(c, HEX),\n      v3 === NONE ? v3 : roundToPrecision(h, HEX),\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  const a = c * Math.cos((h * Math.PI) / DEG_HALF);\n  const b = c * Math.sin((h * Math.PI) / DEG_HALF);\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [l, a, b]);\n  const xyzLms = lms.map(cc => Math.pow(cc, POW_CUBE)) as TriColorChannels;\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms, true);\n  return [\n    'xyz-d65',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    alpha\n  ];\n};\n\n/**\n * parse color()\n * @param value - color function value\n * @param [opt] - options\n * @returns parsed color\n *   - ['xyz-(d50|d65)', x, y, z, alpha], [cs, r, g, b, alpha]\n *   - '(empty)', NullObject\n */\nexport const parseColorFunc = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace = '', d50 = false, format = '', nullable = false } = opt;\n  if (!REG_FN_COLOR.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const [, val] = value.match(REG_FN_COLOR) as MatchedRegExp;\n  let [cs, v1, v2, v3, v4 = ''] = val\n    .replace('/', ' ')\n    .split(/\\s+/) as StringColorSpacedChannels;\n  let r, g, b;\n  if (cs === 'xyz') {\n    cs = 'xyz-d65';\n  }\n  if (v1 === NONE) {\n    r = 0;\n  } else {\n    r = v1.endsWith('%') ? parseFloat(v1) / MAX_PCT : parseFloat(v1);\n  }\n  if (v2 === NONE) {\n    g = 0;\n  } else {\n    g = v2.endsWith('%') ? parseFloat(v2) / MAX_PCT : parseFloat(v2);\n  }\n  if (v3 === NONE) {\n    b = 0;\n  } else {\n    b = v3.endsWith('%') ? parseFloat(v3) / MAX_PCT : parseFloat(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format) || (format === VAL_MIX && cs === colorSpace)) {\n    return [\n      cs,\n      v1 === NONE ? v1 : roundToPrecision(r, DEC),\n      v2 === NONE ? v2 : roundToPrecision(g, DEC),\n      v3 === NONE ? v3 : roundToPrecision(b, DEC),\n      v4 === NONE ? v4 : alpha\n    ];\n  }\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  // srgb-linear\n  if (cs === 'srgb-linear') {\n    [x, y, z] = transformMatrix(MATRIX_L_RGB_TO_XYZ, [r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // display-p3\n  } else if (cs === 'display-p3') {\n    const linearRgb = transformRgbToLinearRgb([\n      r * MAX_RGB,\n      g * MAX_RGB,\n      b * MAX_RGB\n    ]);\n    [x, y, z] = transformMatrix(MATRIX_P3_TO_XYZ, linearRgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // rec2020\n  } else if (cs === 'rec2020') {\n    const ALPHA = 1.09929682680944;\n    const BETA = 0.018053968510807;\n    const REC_COEF = 0.45;\n    const rgb = [r, g, b].map(c => {\n      let cl;\n      if (c < BETA * REC_COEF * DEC) {\n        cl = c / (REC_COEF * DEC);\n      } else {\n        cl = Math.pow((c + ALPHA - 1) / ALPHA, 1 / REC_COEF);\n      }\n      return cl;\n    }) as TriColorChannels;\n    [x, y, z] = transformMatrix(MATRIX_REC2020_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // a98-rgb\n  } else if (cs === 'a98-rgb') {\n    const POW_A98 = 563 / 256;\n    const rgb = [r, g, b].map(c => {\n      const cl = Math.pow(c, POW_A98);\n      return cl;\n    }) as TriColorChannels;\n    [x, y, z] = transformMatrix(MATRIX_A98_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // prophoto-rgb\n  } else if (cs === 'prophoto-rgb') {\n    const POW_PROPHOTO = 1.8;\n    const rgb = [r, g, b].map(c => {\n      let cl;\n      if (c > 1 / (HEX * DUO)) {\n        cl = Math.pow(c, POW_PROPHOTO);\n      } else {\n        cl = c / HEX;\n      }\n      return cl;\n    }) as TriColorChannels;\n    [x, y, z] = transformMatrix(MATRIX_PROPHOTO_TO_XYZ_D50, rgb);\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z], true);\n    }\n    // xyz, xyz-d50, xyz-d65\n  } else if (/^xyz(?:-d(?:50|65))?$/.test(cs)) {\n    [x, y, z] = [r, g, b];\n    if (cs === 'xyz-d50') {\n      if (!d50) {\n        [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n      }\n    } else if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // srgb\n  } else {\n    [x, y, z] = transformRgbToXyz([r * MAX_RGB, g * MAX_RGB, b * MAX_RGB]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n  }\n  return [\n    d50 ? 'xyz-d50' : 'xyz-d65',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    format === VAL_MIX && v4 === NONE ? v4 : alpha\n  ];\n};\n\n/**\n * parse color value\n * @param value - CSS color value\n * @param [opt] - options\n * @returns parsed color\n *   - ['xyz-(d50|d65)', x, y, z, alpha], ['rgb', r, g, b, alpha]\n *   - value, '(empty)', NullObject\n */\nexport const parseColorValue = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { d50 = false, format = '', nullable = false } = opt;\n  if (!REG_COLOR.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      return res;\n    }\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let alpha = 0;\n  // complement currentcolor as a missing color\n  if (REG_CURRENT.test(value)) {\n    if (format === VAL_COMP) {\n      return ['rgb', 0, 0, 0, 0];\n    }\n    if (format === VAL_SPEC) {\n      return value;\n    }\n    // named-color\n  } else if (/^[a-z]+$/.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      if (format === VAL_SPEC) {\n        return value;\n      }\n      const [r, g, b] = NAMED_COLORS[\n        value as keyof typeof NAMED_COLORS\n      ] as TriColorChannels;\n      alpha = 1;\n      if (format === VAL_COMP) {\n        return ['rgb', r, g, b, alpha];\n      }\n      [x, y, z] = transformRgbToXyz([r, g, b], true);\n      if (d50) {\n        [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n      }\n    } else {\n      switch (format) {\n        case VAL_COMP: {\n          if (nullable && value !== 'transparent') {\n            return new NullObject();\n          }\n          return ['rgb', 0, 0, 0, 0];\n        }\n        case VAL_SPEC: {\n          if (value === 'transparent') {\n            return value;\n          }\n          return '';\n        }\n        case VAL_MIX: {\n          if (value === 'transparent') {\n            return ['rgb', 0, 0, 0, 0];\n          }\n          return new NullObject();\n        }\n        default:\n      }\n    }\n    // hex-color\n  } else if (value[0] === '#') {\n    if (REG_SPEC.test(format)) {\n      const rgb = convertHexToRgb(value);\n      return ['rgb', ...rgb];\n    }\n    [x, y, z, alpha] = convertHexToXyz(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // lab()\n  } else if (value.startsWith('lab')) {\n    if (REG_SPEC.test(format)) {\n      return parseLab(value, opt);\n    }\n    [, x, y, z, alpha] = parseLab(value) as ComputedColorChannels;\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z], true);\n    }\n    // lch()\n  } else if (value.startsWith('lch')) {\n    if (REG_SPEC.test(format)) {\n      return parseLch(value, opt);\n    }\n    [, x, y, z, alpha] = parseLch(value) as ComputedColorChannels;\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z], true);\n    }\n    // oklab()\n  } else if (value.startsWith('oklab')) {\n    if (REG_SPEC.test(format)) {\n      return parseOklab(value, opt);\n    }\n    [, x, y, z, alpha] = parseOklab(value) as ComputedColorChannels;\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n    // oklch()\n  } else if (value.startsWith('oklch')) {\n    if (REG_SPEC.test(format)) {\n      return parseOklch(value, opt);\n    }\n    [, x, y, z, alpha] = parseOklch(value) as ComputedColorChannels;\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n  } else {\n    let r, g, b;\n    // hsl()\n    if (value.startsWith('hsl')) {\n      [, r, g, b, alpha] = parseHsl(value) as ComputedColorChannels;\n      // hwb()\n    } else if (value.startsWith('hwb')) {\n      [, r, g, b, alpha] = parseHwb(value) as ComputedColorChannels;\n      // rgb()\n    } else {\n      [, r, g, b, alpha] = parseRgb(value, opt) as ComputedColorChannels;\n    }\n    if (REG_SPEC.test(format)) {\n      return ['rgb', Math.round(r), Math.round(g), Math.round(b), alpha];\n    }\n    [x, y, z] = transformRgbToXyz([r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n  }\n  return [\n    d50 ? 'xyz-d50' : 'xyz-d65',\n    roundToPrecision(x, HEX),\n    roundToPrecision(y, HEX),\n    roundToPrecision(z, HEX),\n    alpha\n  ];\n};\n\n/**\n * resolve color value\n * @param value - CSS color value\n * @param [opt] - options\n * @returns resolved color\n *   - [cs, v1, v2, v3, alpha], value, '(empty)', NullObject\n */\nexport const resolveColorValue = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace = '', format = '', nullable = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveColorValue',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    const cachedItem = cachedResult.item;\n    if (isString(cachedItem)) {\n      return cachedItem as string;\n    }\n    return cachedItem as SpecifiedColorChannels;\n  }\n  if (!REG_COLOR.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      setCache(cacheKey, null);\n      return res;\n    }\n    setCache(cacheKey, res);\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  let cs = '';\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let alpha = 0;\n  // complement currentcolor as a missing color\n  if (REG_CURRENT.test(value)) {\n    if (format === VAL_SPEC) {\n      setCache(cacheKey, value);\n      return value;\n    }\n    // named-color\n  } else if (/^[a-z]+$/.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      if (format === VAL_SPEC) {\n        setCache(cacheKey, value);\n        return value;\n      }\n      [r, g, b] = NAMED_COLORS[\n        value as keyof typeof NAMED_COLORS\n      ] as TriColorChannels;\n      alpha = 1;\n    } else {\n      switch (format) {\n        case VAL_SPEC: {\n          if (value === 'transparent') {\n            setCache(cacheKey, value);\n            return value;\n          }\n          const res = '';\n          setCache(cacheKey, res);\n          return res;\n        }\n        case VAL_MIX: {\n          if (value === 'transparent') {\n            const res: SpecifiedColorChannels = ['rgb', 0, 0, 0, 0];\n            setCache(cacheKey, res);\n            return res;\n          }\n          setCache(cacheKey, null);\n          return new NullObject();\n        }\n        case VAL_COMP:\n        default: {\n          if (nullable && value !== 'transparent') {\n            setCache(cacheKey, null);\n            return new NullObject();\n          }\n          const res: SpecifiedColorChannels = ['rgb', 0, 0, 0, 0];\n          setCache(cacheKey, res);\n          return res;\n        }\n      }\n    }\n    // hex-color\n  } else if (value[0] === '#') {\n    [r, g, b, alpha] = convertHexToRgb(value);\n    // hsl()\n  } else if (value.startsWith('hsl')) {\n    [, r, g, b, alpha] = parseHsl(value, opt) as ComputedColorChannels;\n    // hwb()\n  } else if (value.startsWith('hwb')) {\n    [, r, g, b, alpha] = parseHwb(value, opt) as ComputedColorChannels;\n    // lab(), lch()\n  } else if (/^l(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith('lab')) {\n      [cs, x, y, z, alpha] = parseLab(value, opt) as ComputedColorChannels;\n    } else {\n      [cs, x, y, z, alpha] = parseLch(value, opt) as ComputedColorChannels;\n    }\n    if (REG_SPEC.test(format)) {\n      const res: SpecifiedColorChannels = [cs, x, y, z, alpha];\n      setCache(cacheKey, res);\n      return res;\n    }\n    [r, g, b] = transformXyzD50ToRgb([x, y, z]);\n    // oklab(), oklch()\n  } else if (/^okl(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith('oklab')) {\n      [cs, x, y, z, alpha] = parseOklab(value, opt) as ComputedColorChannels;\n    } else {\n      [cs, x, y, z, alpha] = parseOklch(value, opt) as ComputedColorChannels;\n    }\n    if (REG_SPEC.test(format)) {\n      const res: SpecifiedColorChannels = [cs, x, y, z, alpha];\n      setCache(cacheKey, res);\n      return res;\n    }\n    [r, g, b] = transformXyzToRgb([x, y, z]);\n    // rgb()\n  } else {\n    [, r, g, b, alpha] = parseRgb(value, opt) as ComputedColorChannels;\n  }\n  if (format === VAL_MIX && colorSpace === 'srgb') {\n    const res: SpecifiedColorChannels = [\n      'srgb',\n      r / MAX_RGB,\n      g / MAX_RGB,\n      b / MAX_RGB,\n      alpha\n    ];\n    setCache(cacheKey, res);\n    return res;\n  }\n  const res: SpecifiedColorChannels = [\n    'rgb',\n    Math.round(r),\n    Math.round(g),\n    Math.round(b),\n    alpha\n  ];\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * resolve color()\n * @param value - color function value\n * @param [opt] - options\n * @returns resolved color - [cs, v1, v2, v3, alpha], '(empty)', NullObject\n */\nexport const resolveColorFunc = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace = '', format = '', nullable = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveColorFunc',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    const cachedItem = cachedResult.item;\n    if (isString(cachedItem)) {\n      return cachedItem as string;\n    }\n    return cachedItem as SpecifiedColorChannels;\n  }\n  if (!REG_FN_COLOR.test(value)) {\n    const res = resolveInvalidColorValue(format, nullable);\n    if (res instanceof NullObject) {\n      setCache(cacheKey, null);\n      return res;\n    }\n    setCache(cacheKey, res);\n    if (isString(res)) {\n      return res as string;\n    }\n    return res as SpecifiedColorChannels;\n  }\n  const [cs, v1, v2, v3, v4] = parseColorFunc(\n    value,\n    opt\n  ) as SpecifiedColorChannels;\n  if (REG_SPEC.test(format) || (format === VAL_MIX && cs === colorSpace)) {\n    const res: SpecifiedColorChannels = [cs, v1, v2, v3, v4];\n    setCache(cacheKey, res);\n    return res;\n  }\n  const x = parseFloat(`${v1}`);\n  const y = parseFloat(`${v2}`);\n  const z = parseFloat(`${v3}`);\n  const alpha = parseAlpha(`${v4}`);\n  const [r, g, b] = transformXyzToRgb([x, y, z], true);\n  const res: SpecifiedColorChannels = ['rgb', r, g, b, alpha];\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * convert color value to linear rgb\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [r, g, b, alpha] r|g|b|alpha: 0..1\n */\nexport const convertColorToLinearRgb = (\n  value: string,\n  opt: {\n    colorSpace?: string;\n    format?: string;\n  } = {}\n): ColorChannels | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace = '', format = '' } = opt;\n  let cs = '';\n  let r, g, b, alpha, x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [cs, x, y, z, alpha] = xyz as ComputedColorChannels;\n    if (cs === colorSpace) {\n      return [x, y, z, alpha];\n    }\n    [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  } else if (value.startsWith(FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR) as MatchedRegExp;\n    const [cs] = val\n      .replace('/', ' ')\n      .split(/\\s+/) as StringColorSpacedChannels;\n    if (cs === 'srgb-linear') {\n      [, r, g, b, alpha] = resolveColorFunc(value, {\n        format: VAL_COMP\n      }) as ComputedColorChannels;\n    } else {\n      [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n      [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n    }\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value) as ComputedColorChannels;\n    [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  }\n  return [\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1),\n    alpha\n  ];\n};\n\n/**\n * convert color value to rgb\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject\n *   - [r, g, b, alpha] r|g|b: 0..255 alpha: 0..1\n */\nexport const convertColorToRgb = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let r, g, b, alpha;\n  if (format === VAL_MIX) {\n    let rgb;\n    if (value.startsWith(FN_COLOR)) {\n      rgb = resolveColorFunc(value, opt);\n    } else {\n      rgb = resolveColorValue(value, opt);\n    }\n    if (rgb instanceof NullObject) {\n      return rgb;\n    }\n    [, r, g, b, alpha] = rgb as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR) as MatchedRegExp;\n    const [cs] = val\n      .replace('/', ' ')\n      .split(/\\s+/) as StringColorSpacedChannels;\n    if (cs === 'srgb') {\n      [, r, g, b, alpha] = resolveColorFunc(value, {\n        format: VAL_COMP\n      }) as ComputedColorChannels;\n      r *= MAX_RGB;\n      g *= MAX_RGB;\n      b *= MAX_RGB;\n    } else {\n      [, r, g, b, alpha] = resolveColorFunc(value) as ComputedColorChannels;\n    }\n  } else if (/^(?:ok)?l(?:ab|ch)/.test(value)) {\n    [r, g, b, alpha] = convertColorToLinearRgb(value) as ColorChannels;\n    [r, g, b] = transformLinearRgbToRgb([r, g, b]);\n  } else {\n    [, r, g, b, alpha] = resolveColorValue(value, {\n      format: VAL_COMP\n    }) as ComputedColorChannels;\n  }\n  return [r, g, b, alpha];\n};\n\n/**\n * convert color value to xyz\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [x, y, z, alpha]\n */\nexport const convertColorToXyz = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { d50 = false, format = '' } = opt;\n  let x, y, z, alpha;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR) as MatchedRegExp;\n    const [cs] = val\n      .replace('/', ' ')\n      .split(/\\s+/) as StringColorSpacedChannels;\n    if (d50) {\n      if (cs === 'xyz-d50') {\n        [, x, y, z, alpha] = resolveColorFunc(value, {\n          format: VAL_COMP\n        }) as ComputedColorChannels;\n      } else {\n        [, x, y, z, alpha] = parseColorFunc(\n          value,\n          opt\n        ) as ComputedColorChannels;\n      }\n    } else if (/^xyz(?:-d65)?$/.test(cs)) {\n      [, x, y, z, alpha] = resolveColorFunc(value, {\n        format: VAL_COMP\n      }) as ComputedColorChannels;\n    } else {\n      [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n    }\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, opt) as ComputedColorChannels;\n  }\n  return [x, y, z, alpha];\n};\n\n/**\n * convert color value to hsl\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [h, s, l, alpha], hue may be powerless\n */\nexport const convertColorToHsl = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | [number | string, number, number, number] | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let h, s, l, alpha;\n  if (REG_HSL.test(value)) {\n    [, h, s, l, alpha] = parseHsl(value, {\n      format: 'hsl'\n    }) as ComputedColorChannels;\n    if (format === 'hsl') {\n      return [Math.round(h), Math.round(s), Math.round(l), alpha];\n    }\n    return [h, s, l, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value) as ComputedColorChannels;\n  }\n  [h, s, l] = transformXyzToHsl([x, y, z], true) as TriColorChannels;\n  if (format === 'hsl') {\n    return [Math.round(h), Math.round(s), Math.round(l), alpha];\n  }\n  return [format === VAL_MIX && s === 0 ? NONE : h, s, l, alpha];\n};\n\n/**\n * convert color value to hwb\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [h, w, b, alpha], hue may be powerless\n */\nexport const convertColorToHwb = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | [number | string, number, number, number] | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let h, w, b, alpha;\n  if (REG_HWB.test(value)) {\n    [, h, w, b, alpha] = parseHwb(value, {\n      format: 'hwb'\n    }) as ComputedColorChannels;\n    if (format === 'hwb') {\n      return [Math.round(h), Math.round(w), Math.round(b), alpha];\n    }\n    return [h, w, b, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value) as ComputedColorChannels;\n  }\n  [h, w, b] = transformXyzToHwb([x, y, z], true) as TriColorChannels;\n  if (format === 'hwb') {\n    return [Math.round(h), Math.round(w), Math.round(b), alpha];\n  }\n  return [format === VAL_MIX && w + b >= 100 ? NONE : h, w, b, alpha];\n};\n\n/**\n * convert color value to lab\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [l, a, b, alpha]\n */\nexport const convertColorToLab = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let l, a, b, alpha;\n  if (REG_LAB.test(value)) {\n    [, l, a, b, alpha] = parseLab(value, {\n      format: VAL_COMP\n    }) as ComputedColorChannels;\n    return [l, a, b, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    opt.d50 = true;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value, {\n      d50: true\n    }) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, {\n      d50: true\n    }) as ComputedColorChannels;\n  }\n  [l, a, b] = transformXyzD50ToLab([x, y, z], true);\n  return [l, a, b, alpha];\n};\n\n/**\n * convert color value to lch\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [l, c, h, alpha], hue may be powerless\n */\nexport const convertColorToLch = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | [number, number, number | string, number] | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let l, c, h, alpha;\n  if (REG_LCH.test(value)) {\n    [, l, c, h, alpha] = parseLch(value, {\n      format: VAL_COMP\n    }) as ComputedColorChannels;\n    return [l, c, h, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    opt.d50 = true;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value, {\n      d50: true\n    }) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, {\n      d50: true\n    }) as ComputedColorChannels;\n  }\n  [l, c, h] = transformXyzD50ToLch([x, y, z], true);\n  return [l, c, format === VAL_MIX && c === 0 ? NONE : h, alpha];\n};\n\n/**\n * convert color value to oklab\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [l, a, b, alpha]\n */\nexport const convertColorToOklab = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let l, a, b, alpha;\n  if (REG_OKLAB.test(value)) {\n    [, l, a, b, alpha] = parseOklab(value, {\n      format: VAL_COMP\n    }) as ComputedColorChannels;\n    return [l, a, b, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value) as ComputedColorChannels;\n  }\n  [l, a, b] = transformXyzToOklab([x, y, z], true);\n  return [l, a, b, alpha];\n};\n\n/**\n * convert color value to oklch\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels | NullObject - [l, c, h, alpha], hue may be powerless\n */\nexport const convertColorToOklch = (\n  value: string,\n  opt: Options = {}\n): ColorChannels | [number, number, number | string, number] | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '' } = opt;\n  let l, c, h, alpha;\n  if (REG_OKLCH.test(value)) {\n    [, l, c, h, alpha] = parseOklch(value, {\n      format: VAL_COMP\n    }) as ComputedColorChannels;\n    return [l, c, h, alpha];\n  }\n  let x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz instanceof NullObject) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value) as ComputedColorChannels;\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value) as ComputedColorChannels;\n  }\n  [l, c, h] = transformXyzToOklch([x, y, z], true) as TriColorChannels;\n  return [l, c, format === VAL_MIX && c === 0 ? NONE : h, alpha];\n};\n\n/**\n * resolve color-mix()\n * @param value - color-mix color value\n * @param [opt] - options\n * @returns resolved color - [cs, v1, v2, v3, alpha], '(empty)'\n */\nexport const resolveColorMix = (\n  value: string,\n  opt: Options = {}\n): SpecifiedColorChannels | string | NullObject => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format = '', nullable = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveColorMix',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    const cachedItem = cachedResult.item;\n    if (isString(cachedItem)) {\n      return cachedItem as string;\n    }\n    return cachedItem as SpecifiedColorChannels;\n  }\n  const nestedItems = [];\n  if (!REG_MIX.test(value)) {\n    if (value.startsWith(FN_MIX) && REG_MIX_NEST.test(value)) {\n      const regColorSpace = new RegExp(`^(?:${CS_RGB}|${CS_XYZ})$`);\n      const items = value.match(REG_MIX_NEST) as RegExpMatchArray;\n      for (const item of items) {\n        if (item) {\n          let val = resolveColorMix(item, {\n            format: format === VAL_SPEC ? format : VAL_COMP\n          }) as ComputedColorChannels | string;\n          // computed value\n          if (Array.isArray(val)) {\n            const [cs, v1, v2, v3, v4] = val as ComputedColorChannels;\n            if (v1 === 0 && v2 === 0 && v3 === 0 && v4 === 0) {\n              value = '';\n              break;\n            }\n            if (regColorSpace.test(cs)) {\n              if (v4 === 1) {\n                val = `color(${cs} ${v1} ${v2} ${v3})`;\n              } else {\n                val = `color(${cs} ${v1} ${v2} ${v3} / ${v4})`;\n              }\n            } else if (v4 === 1) {\n              val = `${cs}(${v1} ${v2} ${v3})`;\n            } else {\n              val = `${cs}(${v1} ${v2} ${v3} / ${v4})`;\n            }\n          } else if (!REG_MIX.test(val)) {\n            value = '';\n            break;\n          }\n          nestedItems.push(val);\n          value = value.replace(item, val);\n        }\n      }\n      if (!value) {\n        const res = cacheInvalidColorValue(cacheKey, format, nullable);\n        return res;\n      }\n    } else {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n  }\n  let colorSpace = '';\n  let hueArc = '';\n  let colorA = '';\n  let pctA = '';\n  let colorB = '';\n  let pctB = '';\n  if (nestedItems.length && format === VAL_SPEC) {\n    const regColorSpace = new RegExp(`^color-mix\\\\(\\\\s*in\\\\s+(${CS_MIX})\\\\s*,`);\n    const [, cs] = value.match(regColorSpace) as MatchedRegExp;\n    if (REG_CS_HUE.test(cs)) {\n      [, colorSpace, hueArc] = cs.match(REG_CS_HUE) as MatchedRegExp;\n    } else {\n      colorSpace = cs;\n    }\n    if (nestedItems.length === 2) {\n      let [itemA, itemB] = nestedItems as [string, string];\n      itemA = itemA.replace(/(?=[()])/g, '\\\\');\n      itemB = itemB.replace(/(?=[()])/g, '\\\\');\n      const regA = new RegExp(`(${itemA})(?:\\\\s+(${PCT}))?`);\n      const regB = new RegExp(`(${itemB})(?:\\\\s+(${PCT}))?`);\n      [, colorA, pctA] = value.match(regA) as MatchedRegExp;\n      [, colorB, pctB] = value.match(regB) as MatchedRegExp;\n    } else {\n      let [item] = nestedItems as [string];\n      item = item.replace(/(?=[()])/g, '\\\\');\n      const itemPart = `${item}(?:\\\\s+${PCT})?`;\n      const itemPartCapt = `(${item})(?:\\\\s+(${PCT}))?`;\n      const regItemPart = new RegExp(`^${itemPartCapt}$`);\n      const regLastItem = new RegExp(`${itemPartCapt}\\\\s*\\\\)$`);\n      const regColorPart = new RegExp(`^(${SYN_COLOR_TYPE})(?:\\\\s+(${PCT}))?$`);\n      // item is at the end\n      if (regLastItem.test(value)) {\n        const reg = new RegExp(\n          `(${SYN_MIX_PART})\\\\s*,\\\\s*(${itemPart})\\\\s*\\\\)$`\n        );\n        const [, colorPartA, colorPartB] = value.match(reg) as MatchedRegExp;\n        [, colorA, pctA] = colorPartA.match(regColorPart) as MatchedRegExp;\n        [, colorB, pctB] = colorPartB.match(regItemPart) as MatchedRegExp;\n      } else {\n        const reg = new RegExp(\n          `(${itemPart})\\\\s*,\\\\s*(${SYN_MIX_PART})\\\\s*\\\\)$`\n        );\n        const [, colorPartA, colorPartB] = value.match(reg) as MatchedRegExp;\n        [, colorA, pctA] = colorPartA.match(regItemPart) as MatchedRegExp;\n        [, colorB, pctB] = colorPartB.match(regColorPart) as MatchedRegExp;\n      }\n    }\n  } else {\n    const [, cs, colorPartA, colorPartB] = value.match(\n      REG_MIX_CAPT\n    ) as MatchedRegExp;\n    const reg = new RegExp(`^(${SYN_COLOR_TYPE})(?:\\\\s+(${PCT}))?$`);\n    [, colorA, pctA] = colorPartA.match(reg) as MatchedRegExp;\n    [, colorB, pctB] = colorPartB.match(reg) as MatchedRegExp;\n    if (REG_CS_HUE.test(cs)) {\n      [, colorSpace, hueArc] = cs.match(REG_CS_HUE) as MatchedRegExp;\n    } else {\n      colorSpace = cs;\n    }\n  }\n  // normalize percentages and set multipler\n  let pA, pB, m;\n  if (pctA && pctB) {\n    const p1 = parseFloat(pctA) / MAX_PCT;\n    const p2 = parseFloat(pctB) / MAX_PCT;\n    if (p1 < 0 || p1 > 1 || p2 < 0 || p2 > 1) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const factor = p1 + p2;\n    if (factor === 0) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    pA = p1 / factor;\n    pB = p2 / factor;\n    m = factor < 1 ? factor : 1;\n  } else {\n    if (pctA) {\n      pA = parseFloat(pctA) / MAX_PCT;\n      if (pA < 0 || pA > 1) {\n        const res = cacheInvalidColorValue(cacheKey, format, nullable);\n        return res;\n      }\n      pB = 1 - pA;\n    } else if (pctB) {\n      pB = parseFloat(pctB) / MAX_PCT;\n      if (pB < 0 || pB > 1) {\n        const res = cacheInvalidColorValue(cacheKey, format, nullable);\n        return res;\n      }\n      pA = 1 - pB;\n    } else {\n      pA = HALF;\n      pB = HALF;\n    }\n    m = 1;\n  }\n  if (colorSpace === 'xyz') {\n    colorSpace = 'xyz-d65';\n  }\n  // specified value\n  if (format === VAL_SPEC) {\n    let valueA = '';\n    let valueB = '';\n    if (colorA.startsWith(FN_MIX)) {\n      valueA = colorA;\n    } else if (colorA.startsWith(FN_COLOR)) {\n      const [cs, v1, v2, v3, v4] = parseColorFunc(\n        colorA,\n        opt\n      ) as SpecifiedColorChannels;\n      if (v4 === 1) {\n        valueA = `color(${cs} ${v1} ${v2} ${v3})`;\n      } else {\n        valueA = `color(${cs} ${v1} ${v2} ${v3} / ${v4})`;\n      }\n    } else {\n      const val = parseColorValue(colorA, opt);\n      if (Array.isArray(val)) {\n        const [cs, v1, v2, v3, v4] = val;\n        if (v4 === 1) {\n          if (cs === 'rgb') {\n            valueA = `${cs}(${v1}, ${v2}, ${v3})`;\n          } else {\n            valueA = `${cs}(${v1} ${v2} ${v3})`;\n          }\n        } else if (cs === 'rgb') {\n          valueA = `${cs}a(${v1}, ${v2}, ${v3}, ${v4})`;\n        } else {\n          valueA = `${cs}(${v1} ${v2} ${v3} / ${v4})`;\n        }\n      } else {\n        if (!isString(val) || !val) {\n          setCache(cacheKey, '');\n          return '';\n        }\n        valueA = val;\n      }\n    }\n    if (colorB.startsWith(FN_MIX)) {\n      valueB = colorB;\n    } else if (colorB.startsWith(FN_COLOR)) {\n      const [cs, v1, v2, v3, v4] = parseColorFunc(\n        colorB,\n        opt\n      ) as SpecifiedColorChannels;\n      if (v4 === 1) {\n        valueB = `color(${cs} ${v1} ${v2} ${v3})`;\n      } else {\n        valueB = `color(${cs} ${v1} ${v2} ${v3} / ${v4})`;\n      }\n    } else {\n      const val = parseColorValue(colorB, opt);\n      if (Array.isArray(val)) {\n        const [cs, v1, v2, v3, v4] = val;\n        if (v4 === 1) {\n          if (cs === 'rgb') {\n            valueB = `${cs}(${v1}, ${v2}, ${v3})`;\n          } else {\n            valueB = `${cs}(${v1} ${v2} ${v3})`;\n          }\n        } else if (cs === 'rgb') {\n          valueB = `${cs}a(${v1}, ${v2}, ${v3}, ${v4})`;\n        } else {\n          valueB = `${cs}(${v1} ${v2} ${v3} / ${v4})`;\n        }\n      } else {\n        if (!isString(val) || !val) {\n          setCache(cacheKey, '');\n          return '';\n        }\n        valueB = val;\n      }\n    }\n    if (pctA && pctB) {\n      valueA += ` ${parseFloat(pctA)}%`;\n      valueB += ` ${parseFloat(pctB)}%`;\n    } else if (pctA) {\n      const pA = parseFloat(pctA);\n      if (pA !== MAX_PCT * HALF) {\n        valueA += ` ${pA}%`;\n      }\n    } else if (pctB) {\n      const pA = MAX_PCT - parseFloat(pctB);\n      if (pA !== MAX_PCT * HALF) {\n        valueA += ` ${pA}%`;\n      }\n    }\n    if (hueArc) {\n      const res = `color-mix(in ${colorSpace} ${hueArc} hue, ${valueA}, ${valueB})`;\n      setCache(cacheKey, res);\n      return res;\n    } else {\n      const res = `color-mix(in ${colorSpace}, ${valueA}, ${valueB})`;\n      setCache(cacheKey, res);\n      return res;\n    }\n  }\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let alpha = 0;\n  // in srgb, srgb-linear\n  if (/^srgb(?:-linear)?$/.test(colorSpace)) {\n    let rgbA, rgbB;\n    if (colorSpace === 'srgb') {\n      if (REG_CURRENT.test(colorA)) {\n        rgbA = [NONE, NONE, NONE, NONE];\n      } else {\n        rgbA = convertColorToRgb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        rgbB = [NONE, NONE, NONE, NONE];\n      } else {\n        rgbB = convertColorToRgb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        rgbA = [NONE, NONE, NONE, NONE];\n      } else {\n        rgbA = convertColorToLinearRgb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        rgbB = [NONE, NONE, NONE, NONE];\n      } else {\n        rgbB = convertColorToLinearRgb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (rgbA instanceof NullObject || rgbB instanceof NullObject) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const [rrA, ggA, bbA, aaA] = rgbA as NumStrColorChannels;\n    const [rrB, ggB, bbB, aaB] = rgbB as NumStrColorChannels;\n    const rNone = rrA === NONE && rrB === NONE;\n    const gNone = ggA === NONE && ggB === NONE;\n    const bNone = bbA === NONE && bbB === NONE;\n    const alphaNone = aaA === NONE && aaB === NONE;\n    const [[rA, gA, bA, alphaA], [rB, gB, bB, alphaB]] =\n      normalizeColorComponents(\n        [rrA, ggA, bbA, aaA],\n        [rrB, ggB, bbB, aaB],\n        true\n      );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    if (alpha === 0) {\n      r = rA * pA + rB * pB;\n      g = gA * pA + gB * pB;\n      b = bA * pA + bB * pB;\n    } else {\n      r = (rA * factorA + rB * factorB) / alpha;\n      g = (gA * factorA + gB * factorB) / alpha;\n      b = (bA * factorA + bB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === VAL_COMP) {\n      const res: SpecifiedColorChannels = [\n        colorSpace,\n        rNone ? NONE : roundToPrecision(r, HEX),\n        gNone ? NONE : roundToPrecision(g, HEX),\n        bNone ? NONE : roundToPrecision(b, HEX),\n        alphaNone ? NONE : alpha * m\n      ];\n      setCache(cacheKey, res);\n      return res;\n    }\n    r *= MAX_RGB;\n    g *= MAX_RGB;\n    b *= MAX_RGB;\n    // in xyz, xyz-d65, xyz-d50\n  } else if (REG_CS_XYZ.test(colorSpace)) {\n    let xyzA, xyzB;\n    if (REG_CURRENT.test(colorA)) {\n      xyzA = [NONE, NONE, NONE, NONE];\n    } else {\n      xyzA = convertColorToXyz(colorA, {\n        colorSpace,\n        d50: colorSpace === 'xyz-d50',\n        format: VAL_MIX\n      });\n    }\n    if (REG_CURRENT.test(colorB)) {\n      xyzB = [NONE, NONE, NONE, NONE];\n    } else {\n      xyzB = convertColorToXyz(colorB, {\n        colorSpace,\n        d50: colorSpace === 'xyz-d50',\n        format: VAL_MIX\n      });\n    }\n    if (xyzA instanceof NullObject || xyzB instanceof NullObject) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const [xxA, yyA, zzA, aaA] = xyzA;\n    const [xxB, yyB, zzB, aaB] = xyzB;\n    const xNone = xxA === NONE && xxB === NONE;\n    const yNone = yyA === NONE && yyB === NONE;\n    const zNone = zzA === NONE && zzB === NONE;\n    const alphaNone = aaA === NONE && aaB === NONE;\n    const [[xA, yA, zA, alphaA], [xB, yB, zB, alphaB]] =\n      normalizeColorComponents(\n        [xxA, yyA, zzA, aaA],\n        [xxB, yyB, zzB, aaB],\n        true\n      );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    let x, y, z;\n    if (alpha === 0) {\n      x = xA * pA + xB * pB;\n      y = yA * pA + yB * pB;\n      z = zA * pA + zB * pB;\n    } else {\n      x = (xA * factorA + xB * factorB) / alpha;\n      y = (yA * factorA + yB * factorB) / alpha;\n      z = (zA * factorA + zB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === VAL_COMP) {\n      const res: SpecifiedColorChannels = [\n        colorSpace,\n        xNone ? NONE : roundToPrecision(x, HEX),\n        yNone ? NONE : roundToPrecision(y, HEX),\n        zNone ? NONE : roundToPrecision(z, HEX),\n        alphaNone ? NONE : alpha * m\n      ];\n      setCache(cacheKey, res);\n      return res;\n    }\n    if (colorSpace === 'xyz-d50') {\n      [r, g, b] = transformXyzD50ToRgb([x, y, z], true);\n    } else {\n      [r, g, b] = transformXyzToRgb([x, y, z], true);\n    }\n    // in hsl, hwb\n  } else if (/^h(?:sl|wb)$/.test(colorSpace)) {\n    let hslA, hslB;\n    if (colorSpace === 'hsl') {\n      if (REG_CURRENT.test(colorA)) {\n        hslA = [NONE, NONE, NONE, NONE];\n      } else {\n        hslA = convertColorToHsl(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        hslB = [NONE, NONE, NONE, NONE];\n      } else {\n        hslB = convertColorToHsl(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        hslA = [NONE, NONE, NONE, NONE];\n      } else {\n        hslA = convertColorToHwb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        hslB = [NONE, NONE, NONE, NONE];\n      } else {\n        hslB = convertColorToHwb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (hslA instanceof NullObject || hslB instanceof NullObject) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const [hhA, ssA, llA, aaA] = hslA;\n    const [hhB, ssB, llB, aaB] = hslB;\n    const alphaNone = aaA === NONE && aaB === NONE;\n    let [[hA, sA, lA, alphaA], [hB, sB, lB, alphaB]] = normalizeColorComponents(\n      [hhA, ssA, llA, aaA],\n      [hhB, ssB, llB, aaB],\n      true\n    );\n    if (hueArc) {\n      [hA, hB] = interpolateHue(hA, hB, hueArc);\n    }\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    const h = (hA * pA + hB * pB) % DEG;\n    let s, l;\n    if (alpha === 0) {\n      s = sA * pA + sB * pB;\n      l = lA * pA + lB * pB;\n    } else {\n      s = (sA * factorA + sB * factorB) / alpha;\n      l = (lA * factorA + lB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    [r, g, b] = convertColorToRgb(\n      `${colorSpace}(${h} ${s} ${l})`\n    ) as ColorChannels;\n    if (format === VAL_COMP) {\n      const res: SpecifiedColorChannels = [\n        'srgb',\n        roundToPrecision(r / MAX_RGB, HEX),\n        roundToPrecision(g / MAX_RGB, HEX),\n        roundToPrecision(b / MAX_RGB, HEX),\n        alphaNone ? NONE : alpha * m\n      ];\n      setCache(cacheKey, res);\n      return res;\n    }\n    // in lch, oklch\n  } else if (/^(?:ok)?lch$/.test(colorSpace)) {\n    let lchA, lchB;\n    if (colorSpace === 'lch') {\n      if (REG_CURRENT.test(colorA)) {\n        lchA = [NONE, NONE, NONE, NONE];\n      } else {\n        lchA = convertColorToLch(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        lchB = [NONE, NONE, NONE, NONE];\n      } else {\n        lchB = convertColorToLch(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        lchA = [NONE, NONE, NONE, NONE];\n      } else {\n        lchA = convertColorToOklch(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        lchB = [NONE, NONE, NONE, NONE];\n      } else {\n        lchB = convertColorToOklch(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (lchA instanceof NullObject || lchB instanceof NullObject) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const [llA, ccA, hhA, aaA] = lchA;\n    const [llB, ccB, hhB, aaB] = lchB;\n    const lNone = llA === NONE && llB === NONE;\n    const cNone = ccA === NONE && ccB === NONE;\n    const hNone = hhA === NONE && hhB === NONE;\n    const alphaNone = aaA === NONE && aaB === NONE;\n    let [[lA, cA, hA, alphaA], [lB, cB, hB, alphaB]] = normalizeColorComponents(\n      [llA, ccA, hhA, aaA],\n      [llB, ccB, hhB, aaB],\n      true\n    );\n    if (hueArc) {\n      [hA, hB] = interpolateHue(hA, hB, hueArc);\n    }\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    const h = (hA * pA + hB * pB) % DEG;\n    let l, c;\n    if (alpha === 0) {\n      l = lA * pA + lB * pB;\n      c = cA * pA + cB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) / alpha;\n      c = (cA * factorA + cB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === VAL_COMP) {\n      const res: SpecifiedColorChannels = [\n        colorSpace,\n        lNone ? NONE : roundToPrecision(l, HEX),\n        cNone ? NONE : roundToPrecision(c, HEX),\n        hNone ? NONE : roundToPrecision(h, HEX),\n        alphaNone ? NONE : alpha * m\n      ];\n      setCache(cacheKey, res);\n      return res;\n    }\n    [, r, g, b] = resolveColorValue(\n      `${colorSpace}(${l} ${c} ${h})`\n    ) as ComputedColorChannels;\n    // in lab, oklab\n  } else {\n    let labA, labB;\n    if (colorSpace === 'lab') {\n      if (REG_CURRENT.test(colorA)) {\n        labA = [NONE, NONE, NONE, NONE];\n      } else {\n        labA = convertColorToLab(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        labB = [NONE, NONE, NONE, NONE];\n      } else {\n        labB = convertColorToLab(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        labA = [NONE, NONE, NONE, NONE];\n      } else {\n        labA = convertColorToOklab(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        labB = [NONE, NONE, NONE, NONE];\n      } else {\n        labB = convertColorToOklab(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (labA instanceof NullObject || labB instanceof NullObject) {\n      const res = cacheInvalidColorValue(cacheKey, format, nullable);\n      return res;\n    }\n    const [llA, aaA, bbA, alA] = labA;\n    const [llB, aaB, bbB, alB] = labB;\n    const lNone = llA === NONE && llB === NONE;\n    const aNone = aaA === NONE && aaB === NONE;\n    const bNone = bbA === NONE && bbB === NONE;\n    const alphaNone = alA === NONE && alB === NONE;\n    const [[lA, aA, bA, alphaA], [lB, aB, bB, alphaB]] =\n      normalizeColorComponents(\n        [llA, aaA, bbA, alA],\n        [llB, aaB, bbB, alB],\n        true\n      );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    let l, aO, bO;\n    if (alpha === 0) {\n      l = lA * pA + lB * pB;\n      aO = aA * pA + aB * pB;\n      bO = bA * pA + bB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) / alpha;\n      aO = (aA * factorA + aB * factorB) / alpha;\n      bO = (bA * factorA + bB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === VAL_COMP) {\n      const res: SpecifiedColorChannels = [\n        colorSpace,\n        lNone ? NONE : roundToPrecision(l, HEX),\n        aNone ? NONE : roundToPrecision(aO, HEX),\n        bNone ? NONE : roundToPrecision(bO, HEX),\n        alphaNone ? NONE : alpha * m\n      ];\n      setCache(cacheKey, res);\n      return res;\n    }\n    [, r, g, b] = resolveColorValue(\n      `${colorSpace}(${l} ${aO} ${bO})`\n    ) as ComputedColorChannels;\n  }\n  const res: SpecifiedColorChannels = [\n    'rgb',\n    Math.round(r),\n    Math.round(g),\n    Math.round(b),\n    parseFloat((alpha * m).toFixed(3))\n  ];\n  setCache(cacheKey, res);\n  return res;\n};\n","/**\n * css-var\n */\n\nimport { CSSToken, TokenType, tokenize } from '@csstools/css-tokenizer';\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport { isString } from './common';\nimport { cssCalc } from './css-calc';\nimport { isColor } from './util';\nimport { Options } from './typedef';\n\n/* constants */\nimport { FN_VAR, SYN_FN_CALC, SYN_FN_VAR, VAL_SPEC } from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  EOF,\n  Ident: IDENT,\n  Whitespace: W_SPACE\n} = TokenType;\nconst NAMESPACE = 'css-var';\n\n/* regexp */\nconst REG_FN_CALC = new RegExp(SYN_FN_CALC);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\n\n/**\n * resolve custom property\n * @param tokens - CSS tokens\n * @param [opt] - options\n * @returns result - [tokens, resolvedValue]\n */\nexport function resolveCustomProperty(\n  tokens: CSSToken[],\n  opt: Options = {}\n): [CSSToken[], string] {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { customProperty = {} } = opt;\n  const items: string[] = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value] = token as [TokenType, string];\n    // end of var()\n    if (type === PAREN_CLOSE) {\n      break;\n    }\n    // nested var()\n    if (value === FN_VAR) {\n      const [restTokens, item] = resolveCustomProperty(tokens, opt);\n      tokens = restTokens;\n      if (item) {\n        items.push(item);\n      }\n    } else if (type === IDENT) {\n      if (value.startsWith('--')) {\n        let item;\n        if (Object.hasOwnProperty.call(customProperty, value)) {\n          item = customProperty[value] as string;\n        } else if (typeof customProperty.callback === 'function') {\n          item = customProperty.callback(value);\n        }\n        if (item) {\n          items.push(item);\n        }\n      } else if (value) {\n        items.push(value);\n      }\n    }\n  }\n  let resolveAsColor = false;\n  if (items.length > 1) {\n    const lastValue = items[items.length - 1];\n    resolveAsColor = isColor(lastValue);\n  }\n  let resolvedValue = '';\n  for (let item of items) {\n    item = item.trim();\n    if (REG_FN_VAR.test(item)) {\n      // recurse resolveVar()\n      const resolvedItem = resolveVar(item, opt);\n      if (isString(resolvedItem)) {\n        if (resolveAsColor) {\n          if (isColor(resolvedItem)) {\n            resolvedValue = resolvedItem;\n          }\n        } else {\n          resolvedValue = resolvedItem;\n        }\n      }\n    } else if (REG_FN_CALC.test(item)) {\n      item = cssCalc(item, opt);\n      if (resolveAsColor) {\n        if (isColor(item)) {\n          resolvedValue = item;\n        }\n      } else {\n        resolvedValue = item;\n      }\n    } else if (\n      item &&\n      !/^(?:inherit|initial|revert(?:-layer)?|unset)$/.test(item)\n    ) {\n      if (resolveAsColor) {\n        if (isColor(item)) {\n          resolvedValue = item;\n        }\n      } else {\n        resolvedValue = item;\n      }\n    }\n    if (resolvedValue) {\n      break;\n    }\n  }\n  return [tokens, resolvedValue];\n}\n\n/**\n * parse tokens\n * @param tokens - CSS tokens\n * @param [opt] - options\n * @returns parsed tokens\n */\nexport function parseTokens(\n  tokens: CSSToken[],\n  opt: Options = {}\n): string[] | NullObject {\n  const res: string[] = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    const [type = '', value = ''] = token as [TokenType, string];\n    if (value === FN_VAR) {\n      const [restTokens, resolvedValue] = resolveCustomProperty(tokens, opt);\n      if (!resolvedValue) {\n        return new NullObject();\n      }\n      tokens = restTokens;\n      res.push(resolvedValue);\n    } else {\n      switch (type) {\n        case PAREN_CLOSE: {\n          if (res.length) {\n            const lastValue = res[res.length - 1];\n            if (lastValue === ' ') {\n              res.splice(-1, 1, value);\n            } else {\n              res.push(value);\n            }\n          } else {\n            res.push(value);\n          }\n          break;\n        }\n        case W_SPACE: {\n          if (res.length) {\n            const lastValue = res[res.length - 1];\n            if (\n              isString(lastValue) &&\n              !lastValue.endsWith('(') &&\n              lastValue !== ' '\n            ) {\n              res.push(value);\n            }\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF) {\n            res.push(value);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * resolve CSS var()\n * @param value - CSS value including var()\n * @param [opt] - options\n * @returns resolved value\n */\nexport function resolveVar(\n  value: string,\n  opt: Options = {}\n): string | NullObject {\n  const { format = '' } = opt;\n  if (isString(value)) {\n    if (!REG_FN_VAR.test(value) || format === VAL_SPEC) {\n      return value;\n    }\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveVar',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  const tokens = tokenize({ css: value });\n  const values = parseTokens(tokens, opt);\n  if (Array.isArray(values)) {\n    let color = values.join('');\n    if (REG_FN_CALC.test(color)) {\n      color = cssCalc(color, opt);\n    }\n    setCache(cacheKey, color);\n    return color;\n  } else {\n    setCache(cacheKey, null);\n    return new NullObject();\n  }\n}\n\n/**\n * CSS var()\n * @param value - CSS value including var()\n * @param [opt] - options\n * @returns resolved value\n */\nexport const cssVar = (value: string, opt: Options = {}): string => {\n  const resolvedValue = resolveVar(value, opt);\n  if (isString(resolvedValue)) {\n    return resolvedValue;\n  }\n  return '';\n};\n","/**\n * relative-color\n */\n\nimport { SyntaxFlag, color as colorParser } from '@csstools/css-color-parser';\nimport {\n  ComponentValue,\n  parseComponentValue\n} from '@csstools/css-parser-algorithms';\nimport { CSSToken, TokenType, tokenize } from '@csstools/css-tokenizer';\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport { NAMED_COLORS, convertColorToRgb } from './color';\nimport { isString, isStringOrNumber } from './common';\nimport { resolveDimension, serializeCalc } from './css-calc';\nimport { resolveColor } from './resolve';\nimport { roundToPrecision } from './util';\nimport {\n  ColorChannels,\n  MatchedRegExp,\n  Options,\n  StringColorChannels\n} from './typedef';\n\n/* constants */\nimport {\n  CS_LAB,\n  CS_LCH,\n  FN_REL,\n  FN_REL_CAPT,\n  FN_VAR,\n  NONE,\n  SYN_COLOR_TYPE,\n  SYN_FN_MATH_START,\n  SYN_FN_VAR,\n  SYN_MIX,\n  VAL_SPEC\n} from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  Number: NUM,\n  OpenParen: PAREN_OPEN,\n  Percentage: PCT,\n  Whitespace: W_SPACE\n} = TokenType;\nconst { HasNoneKeywords: KEY_NONE } = SyntaxFlag;\nconst NAMESPACE = 'relative-color';\n\n/* numeric constants */\nconst OCT = 8;\nconst DEC = 10;\nconst HEX = 16;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\n\n/* type definitions */\n/**\n * @type NumberOrStringColorChannels - color channel\n */\ntype NumberOrStringColorChannels = ColorChannels & StringColorChannels;\n\n/* regexp */\nconst REG_COLOR_CAPT = new RegExp(\n  `^${FN_REL}(${SYN_COLOR_TYPE}|${SYN_MIX})\\\\s+`\n);\nconst REG_CS_HSL = /(?:hsla?|hwb)$/;\nconst REG_CS_CIE = new RegExp(`^(?:${CS_LAB}|${CS_LCH})$`);\nconst REG_FN_MATH_START = new RegExp(SYN_FN_MATH_START);\nconst REG_FN_REL = new RegExp(FN_REL);\nconst REG_FN_REL_CAPT = new RegExp(`^${FN_REL_CAPT}`);\nconst REG_FN_REL_START = new RegExp(`^${FN_REL}`);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\n\n/**\n * resolve relative color channels\n * @param tokens - CSS tokens\n * @param [opt] - options\n * @returns resolved color channels\n */\nexport function resolveColorChannels(\n  tokens: CSSToken[],\n  opt: Options = {}\n): NumberOrStringColorChannels | NullObject {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { colorSpace = '', format = '' } = opt;\n  const colorChannels = new Map([\n    ['color', ['r', 'g', 'b', 'alpha']],\n    ['hsl', ['h', 's', 'l', 'alpha']],\n    ['hsla', ['h', 's', 'l', 'alpha']],\n    ['hwb', ['h', 'w', 'b', 'alpha']],\n    ['lab', ['l', 'a', 'b', 'alpha']],\n    ['lch', ['l', 'c', 'h', 'alpha']],\n    ['oklab', ['l', 'a', 'b', 'alpha']],\n    ['oklch', ['l', 'c', 'h', 'alpha']],\n    ['rgb', ['r', 'g', 'b', 'alpha']],\n    ['rgba', ['r', 'g', 'b', 'alpha']]\n  ]);\n  const colorChannel = colorChannels.get(colorSpace);\n  // invalid color channel\n  if (!colorChannel) {\n    return new NullObject();\n  }\n  const mathFunc = new Set();\n  const channels: [\n    (number | string)[],\n    (number | string)[],\n    (number | string)[],\n    (number | string)[]\n  ] = [[], [], [], []];\n  let i = 0;\n  let nest = 0;\n  let func = false;\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value, , , detail] = token as [\n      TokenType,\n      string,\n      number,\n      number,\n      { value: string | number } | undefined\n    ];\n    const channel = channels[i];\n    if (Array.isArray(channel)) {\n      switch (type) {\n        case DIM: {\n          const resolvedValue = resolveDimension(token, opt);\n          if (isString(resolvedValue)) {\n            channel.push(resolvedValue);\n          } else {\n            channel.push(value);\n          }\n          break;\n        }\n        case FUNC: {\n          channel.push(value);\n          func = true;\n          nest++;\n          if (REG_FN_MATH_START.test(value)) {\n            mathFunc.add(nest);\n          }\n          break;\n        }\n        case IDENT: {\n          // invalid channel key\n          if (!colorChannel.includes(value)) {\n            return new NullObject();\n          }\n          channel.push(value);\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case NUM: {\n          channel.push(Number(detail?.value));\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case PAREN_OPEN: {\n          channel.push(value);\n          nest++;\n          break;\n        }\n        case PAREN_CLOSE: {\n          if (func) {\n            const lastValue = channel[channel.length - 1];\n            if (lastValue === ' ') {\n              channel.splice(-1, 1, value);\n            } else {\n              channel.push(value);\n            }\n            if (mathFunc.has(nest)) {\n              mathFunc.delete(nest);\n            }\n            nest--;\n            if (nest === 0) {\n              func = false;\n              i++;\n            }\n          }\n          break;\n        }\n        case PCT: {\n          channel.push(Number(detail?.value) / MAX_PCT);\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case W_SPACE: {\n          if (channel.length && func) {\n            const lastValue = channel[channel.length - 1];\n            if (typeof lastValue === 'number') {\n              channel.push(value);\n            } else if (\n              isString(lastValue) &&\n              !lastValue.endsWith('(') &&\n              lastValue !== ' '\n            ) {\n              channel.push(value);\n            }\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF && func) {\n            channel.push(value);\n          }\n        }\n      }\n    }\n  }\n  const channelValues = [];\n  for (const channel of channels) {\n    if (channel.length === 1) {\n      const [resolvedValue] = channel;\n      if (isStringOrNumber(resolvedValue)) {\n        channelValues.push(resolvedValue);\n      }\n    } else if (channel.length) {\n      const resolvedValue = serializeCalc(channel.join(''), {\n        format\n      });\n      channelValues.push(resolvedValue);\n    }\n  }\n  return channelValues as NumberOrStringColorChannels;\n}\n\n/**\n * extract origin color\n * @param value - CSS color value\n * @param [opt] - options\n * @returns origin color value\n */\nexport function extractOriginColor(\n  value: string,\n  opt: Options = {}\n): string | NullObject {\n  const { currentColor = '', format = '' } = opt;\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n    if (!value) {\n      return new NullObject();\n    }\n    if (!REG_FN_REL_START.test(value)) {\n      return value;\n    }\n  } else {\n    return new NullObject();\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'extractOriginColor',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  if (/currentcolor/.test(value)) {\n    if (currentColor) {\n      value = value.replace(/currentcolor/g, currentColor);\n    } else {\n      setCache(cacheKey, null);\n      return new NullObject();\n    }\n  }\n  let colorSpace = '';\n  if (REG_FN_REL_CAPT.test(value)) {\n    [, colorSpace] = value.match(REG_FN_REL_CAPT) as MatchedRegExp;\n  }\n  opt.colorSpace = colorSpace;\n  if (REG_COLOR_CAPT.test(value)) {\n    const [, originColor] = value.match(REG_COLOR_CAPT) as MatchedRegExp;\n    const [, restValue] = value.split(originColor) as MatchedRegExp;\n    if (/^[a-z]+$/.test(originColor)) {\n      if (\n        !/^transparent$/.test(originColor) &&\n        !Object.prototype.hasOwnProperty.call(NAMED_COLORS, originColor)\n      ) {\n        setCache(cacheKey, null);\n        return new NullObject();\n      }\n    } else if (format === VAL_SPEC) {\n      const resolvedOriginColor = resolveColor(originColor, opt);\n      if (isString(resolvedOriginColor)) {\n        value = value.replace(originColor, resolvedOriginColor);\n      }\n    }\n    if (format === VAL_SPEC) {\n      const tokens = tokenize({ css: restValue });\n      const channelValues = resolveColorChannels(tokens, opt);\n      if (channelValues instanceof NullObject) {\n        setCache(cacheKey, null);\n        return channelValues;\n      }\n      const [v1, v2, v3, v4] = channelValues;\n      let channelValue = '';\n      if (isStringOrNumber(v4)) {\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      } else {\n        channelValue = ` ${channelValues.join(' ')})`;\n      }\n      if (restValue !== channelValue) {\n        value = value.replace(restValue, channelValue);\n      }\n    }\n    // nested relative color\n  } else {\n    const [, restValue] = value.split(REG_FN_REL_START) as MatchedRegExp;\n    const tokens = tokenize({ css: restValue });\n    const originColor: string[] = [];\n    let nest = 0;\n    while (tokens.length) {\n      const [type, tokenValue] = tokens.shift() as [TokenType, string];\n      switch (type) {\n        case FUNC:\n        case PAREN_OPEN: {\n          originColor.push(tokenValue);\n          nest++;\n          break;\n        }\n        case PAREN_CLOSE: {\n          const lastValue = originColor[originColor.length - 1];\n          if (lastValue === ' ') {\n            originColor.splice(-1, 1, tokenValue);\n          } else if (isString(lastValue)) {\n            originColor.push(tokenValue);\n          }\n          nest--;\n          break;\n        }\n        case W_SPACE: {\n          const lastValue = originColor[originColor.length - 1];\n          if (\n            isString(lastValue) &&\n            !lastValue.endsWith('(') &&\n            lastValue !== ' '\n          ) {\n            originColor.push(tokenValue);\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF) {\n            originColor.push(tokenValue);\n          }\n        }\n      }\n      if (nest === 0) {\n        break;\n      }\n    }\n    const resolvedOriginColor = resolveRelativeColor(\n      originColor.join('').trim(),\n      opt\n    );\n    if (resolvedOriginColor instanceof NullObject) {\n      setCache(cacheKey, null);\n      return resolvedOriginColor;\n    }\n    const channelValues = resolveColorChannels(tokens, opt);\n    if (channelValues instanceof NullObject) {\n      setCache(cacheKey, null);\n      return channelValues;\n    }\n    const [v1, v2, v3, v4] = channelValues;\n    let channelValue = '';\n    if (isStringOrNumber(v4)) {\n      channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n    } else {\n      channelValue = ` ${channelValues.join(' ')})`;\n    }\n    value = value.replace(restValue, `${resolvedOriginColor}${channelValue}`);\n  }\n  setCache(cacheKey, value);\n  return value;\n}\n\n/**\n * resolve relative color\n * @param value - CSS relative color value\n * @param [opt] - options\n * @returns resolved value\n */\nexport function resolveRelativeColor(\n  value: string,\n  opt: Options = {}\n): string | NullObject {\n  const { format = '' } = opt;\n  if (isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === VAL_SPEC) {\n        return value;\n        // var() must be resolved before resolveRelativeColor()\n      } else {\n        throw new SyntaxError(`Unexpected token ${FN_VAR} found.`);\n      }\n    } else if (!REG_FN_REL.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveRelativeColor',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  const originColor = extractOriginColor(value, opt);\n  if (originColor instanceof NullObject) {\n    setCache(cacheKey, null);\n    return originColor;\n  }\n  value = originColor;\n  if (format === VAL_SPEC) {\n    if (value.startsWith('rgba(')) {\n      value = value.replace(/^rgba\\(/, 'rgb(');\n    } else if (value.startsWith('hsla(')) {\n      value = value.replace(/^hsla\\(/, 'hsl(');\n    }\n    return value;\n  }\n  const tokens = tokenize({ css: value });\n  const components = parseComponentValue(tokens) as ComponentValue;\n  const parsedComponents = colorParser(components);\n  if (!parsedComponents) {\n    setCache(cacheKey, null);\n    return new NullObject();\n  }\n  const {\n    alpha: alphaComponent,\n    channels: channelsComponent,\n    colorNotation,\n    syntaxFlags\n  } = parsedComponents;\n  let alpha: number | string;\n  if (Number.isNaN(Number(alphaComponent))) {\n    if (syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE)) {\n      alpha = NONE;\n    } else {\n      alpha = 0;\n    }\n  } else {\n    alpha = roundToPrecision(Number(alphaComponent), OCT);\n  }\n  let v1: number | string;\n  let v2: number | string;\n  let v3: number | string;\n  [v1, v2, v3] = channelsComponent;\n  let resolvedValue;\n  if (REG_CS_CIE.test(colorNotation)) {\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, HEX);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, HEX);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, HEX);\n    }\n    if (alpha === 1) {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  } else if (REG_CS_HSL.test(colorNotation)) {\n    if (Number.isNaN(v1)) {\n      v1 = 0;\n    }\n    if (Number.isNaN(v2)) {\n      v2 = 0;\n    }\n    if (Number.isNaN(v3)) {\n      v3 = 0;\n    }\n    let [r, g, b] = convertColorToRgb(\n      `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`\n    ) as ColorChannels;\n    r = roundToPrecision(r / MAX_RGB, DEC);\n    g = roundToPrecision(g / MAX_RGB, DEC);\n    b = roundToPrecision(b / MAX_RGB, DEC);\n    if (alpha === 1) {\n      resolvedValue = `color(srgb ${r} ${g} ${b})`;\n    } else {\n      resolvedValue = `color(srgb ${r} ${g} ${b} / ${alpha})`;\n    }\n  } else {\n    const cs = colorNotation === 'rgb' ? 'srgb' : colorNotation;\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, DEC);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, DEC);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, DEC);\n    }\n    if (alpha === 1) {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  }\n  setCache(cacheKey, resolvedValue);\n  return resolvedValue;\n}\n","/**\n * resolve\n */\n\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport {\n  convertRgbToHex,\n  resolveColorFunc,\n  resolveColorMix,\n  resolveColorValue\n} from './color';\nimport { isString } from './common';\nimport { cssCalc } from './css-calc';\nimport { resolveVar } from './css-var';\nimport { resolveRelativeColor } from './relative-color';\nimport {\n  ComputedColorChannels,\n  Options,\n  SpecifiedColorChannels\n} from './typedef';\n\n/* constants */\nimport {\n  FN_COLOR,\n  FN_MIX,\n  SYN_FN_CALC,\n  SYN_FN_REL,\n  SYN_FN_VAR,\n  VAL_COMP,\n  VAL_SPEC\n} from './constant';\nconst NAMESPACE = 'resolve';\nconst RGB_TRANSPARENT = 'rgba(0, 0, 0, 0)';\n\n/* regexp */\nconst REG_FN_CALC = new RegExp(SYN_FN_CALC);\nconst REG_FN_REL = new RegExp(SYN_FN_REL);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\n\n/**\n * resolve color\n * @param value - CSS color value\n * @param [opt] - options\n * @returns resolved color\n */\nexport const resolveColor = (\n  value: string,\n  opt: Options = {}\n): string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { currentColor = '', format = VAL_COMP, nullable = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolve',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  if (REG_FN_VAR.test(value)) {\n    if (format === VAL_SPEC) {\n      setCache(cacheKey, value);\n      return value;\n    }\n    const resolvedValue = resolveVar(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      switch (format) {\n        case 'hex':\n        case 'hexAlpha': {\n          setCache(cacheKey, resolvedValue);\n          return resolvedValue;\n        }\n        default: {\n          if (nullable) {\n            setCache(cacheKey, resolvedValue);\n            return resolvedValue;\n          }\n          const res = RGB_TRANSPARENT;\n          setCache(cacheKey, res);\n          return res;\n        }\n      }\n    } else {\n      value = resolvedValue;\n    }\n  }\n  if (opt.format !== format) {\n    opt.format = format;\n  }\n  value = value.toLowerCase();\n  if (REG_FN_REL.test(value)) {\n    const resolvedValue = resolveRelativeColor(value, opt);\n    if (format === VAL_COMP) {\n      let res;\n      if (resolvedValue instanceof NullObject) {\n        if (nullable) {\n          res = resolvedValue;\n        } else {\n          res = RGB_TRANSPARENT;\n        }\n      } else {\n        res = resolvedValue;\n      }\n      setCache(cacheKey, res);\n      return res;\n    }\n    if (format === VAL_SPEC) {\n      let res = '';\n      if (resolvedValue instanceof NullObject) {\n        res = '';\n      } else {\n        res = resolvedValue;\n      }\n      setCache(cacheKey, res);\n      return res;\n    }\n    if (resolvedValue instanceof NullObject) {\n      value = '';\n    } else {\n      value = resolvedValue;\n    }\n  }\n  if (REG_FN_CALC.test(value)) {\n    value = cssCalc(value, opt);\n  }\n  let cs = '';\n  let r = NaN;\n  let g = NaN;\n  let b = NaN;\n  let alpha = NaN;\n  if (value === 'transparent') {\n    switch (format) {\n      case VAL_SPEC: {\n        setCache(cacheKey, value);\n        return value;\n      }\n      case 'hex': {\n        setCache(cacheKey, null);\n        return new NullObject();\n      }\n      case 'hexAlpha': {\n        const res = '#00000000';\n        setCache(cacheKey, res);\n        return res;\n      }\n      case VAL_COMP:\n      default: {\n        const res = RGB_TRANSPARENT;\n        setCache(cacheKey, res);\n        return res;\n      }\n    }\n  } else if (value === 'currentcolor') {\n    if (format === VAL_SPEC) {\n      setCache(cacheKey, value);\n      return value;\n    }\n    if (currentColor) {\n      let resolvedValue;\n      if (currentColor.startsWith(FN_MIX)) {\n        resolvedValue = resolveColorMix(currentColor, opt);\n      } else if (currentColor.startsWith(FN_COLOR)) {\n        resolvedValue = resolveColorFunc(currentColor, opt);\n      } else {\n        resolvedValue = resolveColorValue(currentColor, opt);\n      }\n      if (resolvedValue instanceof NullObject) {\n        setCache(cacheKey, resolvedValue);\n        return resolvedValue;\n      }\n      [cs, r, g, b, alpha] = resolvedValue as ComputedColorChannels;\n    } else if (format === VAL_COMP) {\n      const res = RGB_TRANSPARENT;\n      setCache(cacheKey, res);\n      return res;\n    }\n  } else if (format === VAL_SPEC) {\n    if (value.startsWith(FN_MIX)) {\n      const res = resolveColorMix(value, opt) as string;\n      setCache(cacheKey, res);\n      return res;\n    } else if (value.startsWith(FN_COLOR)) {\n      const [scs, rr, gg, bb, aa] = resolveColorFunc(\n        value,\n        opt\n      ) as SpecifiedColorChannels;\n      let res = '';\n      if (aa === 1) {\n        res = `color(${scs} ${rr} ${gg} ${bb})`;\n      } else {\n        res = `color(${scs} ${rr} ${gg} ${bb} / ${aa})`;\n      }\n      setCache(cacheKey, res);\n      return res;\n    } else {\n      const rgb = resolveColorValue(value, opt);\n      if (isString(rgb)) {\n        setCache(cacheKey, rgb);\n        return rgb;\n      }\n      const [scs, rr, gg, bb, aa] = rgb as SpecifiedColorChannels;\n      let res = '';\n      if (scs === 'rgb') {\n        if (aa === 1) {\n          res = `${scs}(${rr}, ${gg}, ${bb})`;\n        } else {\n          res = `${scs}a(${rr}, ${gg}, ${bb}, ${aa})`;\n        }\n      } else if (aa === 1) {\n        res = `${scs}(${rr} ${gg} ${bb})`;\n      } else {\n        res = `${scs}(${rr} ${gg} ${bb} / ${aa})`;\n      }\n      setCache(cacheKey, res);\n      return res;\n    }\n  } else if (value.startsWith(FN_MIX)) {\n    if (/currentcolor/.test(value)) {\n      if (currentColor) {\n        value = value.replace(/currentcolor/g, currentColor);\n      }\n    }\n    if (/transparent/.test(value)) {\n      value = value.replace(/transparent/g, RGB_TRANSPARENT);\n    }\n    const resolvedValue = resolveColorMix(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      setCache(cacheKey, resolvedValue);\n      return resolvedValue;\n    }\n    [cs, r, g, b, alpha] = resolvedValue as ComputedColorChannels;\n  } else if (value.startsWith(FN_COLOR)) {\n    const resolvedValue = resolveColorFunc(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      setCache(cacheKey, resolvedValue);\n      return resolvedValue;\n    }\n    [cs, r, g, b, alpha] = resolvedValue as ComputedColorChannels;\n  } else if (value) {\n    const resolvedValue = resolveColorValue(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      setCache(cacheKey, resolvedValue);\n      return resolvedValue;\n    }\n    [cs, r, g, b, alpha] = resolvedValue as ComputedColorChannels;\n  }\n  let res = '';\n  switch (format) {\n    case 'hex': {\n      if (\n        Number.isNaN(r) ||\n        Number.isNaN(g) ||\n        Number.isNaN(b) ||\n        Number.isNaN(alpha) ||\n        alpha === 0\n      ) {\n        setCache(cacheKey, null);\n        return new NullObject();\n      }\n      res = convertRgbToHex([r, g, b, 1]);\n      break;\n    }\n    case 'hexAlpha': {\n      if (\n        Number.isNaN(r) ||\n        Number.isNaN(g) ||\n        Number.isNaN(b) ||\n        Number.isNaN(alpha)\n      ) {\n        setCache(cacheKey, null);\n        return new NullObject();\n      }\n      res = convertRgbToHex([r, g, b, alpha]);\n      break;\n    }\n    case VAL_COMP:\n    default: {\n      switch (cs) {\n        case 'rgb': {\n          if (alpha === 1) {\n            res = `${cs}(${r}, ${g}, ${b})`;\n          } else {\n            res = `${cs}a(${r}, ${g}, ${b}, ${alpha})`;\n          }\n          break;\n        }\n        case 'lab':\n        case 'lch':\n        case 'oklab':\n        case 'oklch': {\n          if (alpha === 1) {\n            res = `${cs}(${r} ${g} ${b})`;\n          } else {\n            res = `${cs}(${r} ${g} ${b} / ${alpha})`;\n          }\n          break;\n        }\n        // color()\n        default: {\n          if (alpha === 1) {\n            res = `color(${cs} ${r} ${g} ${b})`;\n          } else {\n            res = `color(${cs} ${r} ${g} ${b} / ${alpha})`;\n          }\n        }\n      }\n    }\n  }\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * resolve CSS color\n * @param value\n *   - CSS color value\n *   - system colors are not supported\n * @param [opt] - options\n * @param [opt.currentColor]\n *   - color to use for `currentcolor` keyword\n *   - if omitted, it will be treated as a missing color\n *     i.e. `rgb(none none none / none)`\n * @param [opt.customProperty]\n *   - custom properties\n *   - pair of `--` prefixed property name and value,\n *     e.g. `customProperty: { '--some-color': '#0000ff' }`\n *   - and/or `callback` function to get the value of the custom property,\n *     e.g. `customProperty: { callback: someDeclaration.getPropertyValue }`\n * @param [opt.dimension]\n *   - dimension, convert relative length to pixels\n *   - pair of unit and it's value as a number in pixels,\n *     e.g. `dimension: { em: 12, rem: 16, vw: 10.26 }`\n *   - and/or `callback` function to get the value as a number in pixels,\n *     e.g. `dimension: { callback: convertUnitToPixel }`\n * @param [opt.format]\n *   - output format, one of below\n *   - `computedValue` (default), [computed value][139] of the color\n *   - `specifiedValue`, [specified value][140] of the color\n *   - `hex`, hex color notation, i.e. `rrggbb`\n *   - `hexAlpha`, hex color notation with alpha channel, i.e. `#rrggbbaa`\n * @returns\n *   - one of rgba?(), #rrggbb(aa)?, color-name, '(empty-string)',\n *     color(color-space r g b / alpha), color(color-space x y z / alpha),\n *     lab(l a b / alpha), lch(l c h / alpha), oklab(l a b / alpha),\n *     oklch(l c h / alpha), null\n *   - in `computedValue`, values are numbers, however `rgb()` values are\n *     integers\n *   - in `specifiedValue`, returns `empty string` for unknown and/or invalid\n *     color\n *   - in `hex`, returns `null` for `transparent`, and also returns `null` if\n *     any of `r`, `g`, `b`, `alpha` is not a number\n *   - in `hexAlpha`, returns `#00000000` for `transparent`,\n *     however returns `null` if any of `r`, `g`, `b`, `alpha` is not a number\n */\nexport const resolve = (value: string, opt: Options = {}): string | null => {\n  opt.nullable = false;\n  const resolvedValue = resolveColor(value, opt);\n  if (resolvedValue instanceof NullObject) {\n    return null;\n  }\n  return resolvedValue as string;\n};\n","/**\n * css-gradient\n */\n\nimport { CacheItem, createCacheKey, getCache, setCache } from './cache';\nimport { isString } from './common';\nimport { MatchedRegExp, Options } from './typedef';\nimport { isColor, splitValue } from './util';\n\n/* constants */\nimport {\n  ANGLE,\n  CS_HUE,\n  CS_RECT,\n  LENGTH,\n  NUM,\n  NUM_POSITIVE,\n  PCT\n} from './constant';\nconst NAMESPACE = 'css-gradient';\nconst DIM_ANGLE = `${NUM}(?:${ANGLE})`;\nconst DIM_ANGLE_PCT = `${DIM_ANGLE}|${PCT}`;\nconst DIM_LEN = `${NUM}(?:${LENGTH})|0`;\nconst DIM_LEN_PCT = `${DIM_LEN}|${PCT}`;\nconst DIM_LEN_PCT_POSI = `${NUM_POSITIVE}(?:${LENGTH}|%)|0`;\nconst DIM_LEN_POSI = `${NUM_POSITIVE}(?:${LENGTH})|0`;\nconst CTR = 'center';\nconst L_R = 'left|right';\nconst T_B = 'top|bottom';\nconst S_E = 'start|end';\nconst AXIS_X = `${L_R}|x-(?:${S_E})`;\nconst AXIS_Y = `${T_B}|y-(?:${S_E})`;\nconst BLOCK = `block-(?:${S_E})`;\nconst INLINE = `inline-(?:${S_E})`;\nconst POS_1 = `${CTR}|${AXIS_X}|${AXIS_Y}|${BLOCK}|${INLINE}|${DIM_LEN_PCT}`;\nconst POS_2 = [\n  `(?:${CTR}|${AXIS_X})\\\\s+(?:${CTR}|${AXIS_Y})`,\n  `(?:${CTR}|${AXIS_Y})\\\\s+(?:${CTR}|${AXIS_X})`,\n  `(?:${CTR}|${AXIS_X}|${DIM_LEN_PCT})\\\\s+(?:${CTR}|${AXIS_Y}|${DIM_LEN_PCT})`,\n  `(?:${CTR}|${BLOCK})\\\\s+(?:${CTR}|${INLINE})`,\n  `(?:${CTR}|${INLINE})\\\\s+(?:${CTR}|${BLOCK})`,\n  `(?:${CTR}|${S_E})\\\\s+(?:${CTR}|${S_E})`\n].join('|');\nconst POS_4 = [\n  `(?:${AXIS_X})\\\\s+(?:${DIM_LEN_PCT})\\\\s+(?:${AXIS_Y})\\\\s+(?:${DIM_LEN_PCT})`,\n  `(?:${AXIS_Y})\\\\s+(?:${DIM_LEN_PCT})\\\\s+(?:${AXIS_X})\\\\s+(?:${DIM_LEN_PCT})`,\n  `(?:${BLOCK})\\\\s+(?:${DIM_LEN_PCT})\\\\s+(?:${INLINE})\\\\s+(?:${DIM_LEN_PCT})`,\n  `(?:${INLINE})\\\\s+(?:${DIM_LEN_PCT})\\\\s+(?:${BLOCK})\\\\s+(?:${DIM_LEN_PCT})`,\n  `(?:${S_E})\\\\s+(?:${DIM_LEN_PCT})\\\\s+(?:${S_E})\\\\s+(?:${DIM_LEN_PCT})`\n].join('|');\nconst RAD_EXTENT = '(?:clos|farth)est-(?:corner|side)';\nconst RAD_SIZE = [\n  `${RAD_EXTENT}(?:\\\\s+${RAD_EXTENT})?`,\n  `${DIM_LEN_POSI}`,\n  `(?:${DIM_LEN_PCT_POSI})\\\\s+(?:${DIM_LEN_PCT_POSI})`\n].join('|');\nconst RAD_SHAPE = 'circle|ellipse';\nconst FROM_ANGLE = `from\\\\s+${DIM_ANGLE}`;\nconst AT_POSITION = `at\\\\s+(?:${POS_1}|${POS_2}|${POS_4})`;\nconst TO_SIDE_CORNER = `to\\\\s+(?:(?:${L_R})(?:\\\\s(?:${T_B}))?|(?:${T_B})(?:\\\\s(?:${L_R}))?)`;\nconst IN_COLOR_SPACE = `in\\\\s+(?:${CS_RECT}|${CS_HUE})`;\n\n/* type definitions */\n/**\n * @type ColorStopList - list of color stops\n */\ntype ColorStopList = [string, string, ...string[]];\n\n/**\n * @typedef Gradient - parsed CSS gradient\n * @property value - input value\n * @property type - gradient type\n * @property [gradientLine] - gradient line\n * @property colorStopList - list of color stops\n */\ninterface Gradient {\n  value: string;\n  type: string;\n  gradientLine?: string;\n  colorStopList: ColorStopList;\n}\n\n/* regexp */\nconst REG_GRAD = /^(?:repeating-)?(?:conic|linear|radial)-gradient\\(/;\nconst REG_GRAD_CAPT = /^((?:repeating-)?(?:conic|linear|radial)-gradient)\\(/;\n\n/**\n * get gradient type\n * @param value - gradient value\n * @returns gradient type\n */\nexport const getGradientType = (value: string): string => {\n  if (isString(value)) {\n    value = value.trim();\n    if (REG_GRAD.test(value)) {\n      const [, type] = value.match(REG_GRAD_CAPT) as MatchedRegExp;\n      return type;\n    }\n  }\n  return '';\n};\n\n/**\n * validate gradient line\n * @param value - gradient line value\n * @param type - gradient type\n * @returns result\n */\nexport const validateGradientLine = (value: string, type: string): boolean => {\n  if (isString(value) && isString(type)) {\n    value = value.trim();\n    type = type.trim();\n    let lineSyntax = '';\n    if (/^(?:repeating-)?linear-gradient$/.test(type)) {\n      /*\n       * <linear-gradient-line> = [\n       *   [ <angle> | to <side-or-corner> ] ||\n       *   <color-interpolation-method>\n       * ]\n       */\n      lineSyntax = [\n        `(?:${DIM_ANGLE}|${TO_SIDE_CORNER})(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `${IN_COLOR_SPACE}(?:\\\\s+(?:${DIM_ANGLE}|${TO_SIDE_CORNER}))?`\n      ].join('|');\n    } else if (/^(?:repeating-)?radial-gradient$/.test(type)) {\n      /*\n       * <radial-gradient-line> = [\n       *   [ [ <radial-shape> || <radial-size> ]? [ at <position> ]? ] ||\n       *   <color-interpolation-method>]?\n       */\n      lineSyntax = [\n        `(?:${RAD_SHAPE})(?:\\\\s+(?:${RAD_SIZE}))?(?:\\\\s+${AT_POSITION})?(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `(?:${RAD_SIZE})(?:\\\\s+(?:${RAD_SHAPE}))?(?:\\\\s+${AT_POSITION})?(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `${AT_POSITION}(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `${IN_COLOR_SPACE}(?:\\\\s+${RAD_SHAPE})(?:\\\\s+(?:${RAD_SIZE}))?(?:\\\\s+${AT_POSITION})?`,\n        `${IN_COLOR_SPACE}(?:\\\\s+${RAD_SIZE})(?:\\\\s+(?:${RAD_SHAPE}))?(?:\\\\s+${AT_POSITION})?`,\n        `${IN_COLOR_SPACE}(?:\\\\s+${AT_POSITION})?`\n      ].join('|');\n    } else if (/^(?:repeating-)?conic-gradient$/.test(type)) {\n      /*\n       * <conic-gradient-line> = [\n       *   [ [ from <angle> ]? [ at <position> ]? ] ||\n       *   <color-interpolation-method>\n       * ]\n       */\n      lineSyntax = [\n        `${FROM_ANGLE}(?:\\\\s+${AT_POSITION})?(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `${AT_POSITION}(?:\\\\s+${IN_COLOR_SPACE})?`,\n        `${IN_COLOR_SPACE}(?:\\\\s+${FROM_ANGLE})?(?:\\\\s+${AT_POSITION})?`\n      ].join('|');\n    }\n    if (lineSyntax) {\n      const reg = new RegExp(`^(?:${lineSyntax})$`);\n      return reg.test(value);\n    }\n  }\n  return false;\n};\n\n/**\n * validate color stop list\n * @param list\n * @param type\n * @param [opt]\n * @returns result\n */\nexport const validateColorStopList = (\n  list: string[],\n  type: string,\n  opt: Options = {}\n): boolean => {\n  if (Array.isArray(list) && list.length > 1) {\n    const dimension = /^(?:repeating-)?conic-gradient$/.test(type)\n      ? DIM_ANGLE_PCT\n      : DIM_LEN_PCT;\n    const regColorHint = new RegExp(`^(?:${dimension})$`);\n    const regDimension = new RegExp(`(?:\\\\s+(?:${dimension})){1,2}$`);\n    const arr = [];\n    for (const item of list) {\n      if (isString(item)) {\n        if (regColorHint.test(item)) {\n          arr.push('hint');\n        } else {\n          const color = item.replace(regDimension, '');\n          if (isColor(color, opt)) {\n            arr.push('color');\n          } else {\n            return false;\n          }\n        }\n      }\n    }\n    const value = arr.join(',');\n    return /^color(?:,(?:hint,)?color)+$/.test(value);\n  }\n  return false;\n};\n\n/**\n * parse CSS gradient\n * @param value - gradient value\n * @param [opt] - options\n * @returns parsed result\n */\nexport const parseGradient = (\n  value: string,\n  opt: Options = {}\n): Gradient | null => {\n  if (isString(value)) {\n    value = value.trim();\n    const cacheKey: string = createCacheKey(\n      {\n        namespace: NAMESPACE,\n        name: 'parseGradient',\n        value\n      },\n      opt\n    );\n    const cachedResult = getCache(cacheKey);\n    if (cachedResult instanceof CacheItem) {\n      if (cachedResult.isNull) {\n        return null;\n      }\n      return cachedResult.item as Gradient;\n    }\n    const type = getGradientType(value);\n    const gradValue = value.replace(REG_GRAD, '').replace(/\\)$/, '');\n    if (type && gradValue) {\n      const [lineOrColorStop = '', ...colorStops] = splitValue(gradValue, {\n        delimiter: ','\n      });\n      const dimension = /^(?:repeating-)?conic-gradient$/.test(type)\n        ? DIM_ANGLE_PCT\n        : DIM_LEN_PCT;\n      const regDimension = new RegExp(`(?:\\\\s+(?:${dimension})){1,2}$`);\n      let isColorStop = false;\n      if (regDimension.test(lineOrColorStop)) {\n        const colorStop = lineOrColorStop.replace(regDimension, '');\n        if (isColor(colorStop, opt)) {\n          isColorStop = true;\n        }\n      } else if (isColor(lineOrColorStop, opt)) {\n        isColorStop = true;\n      }\n      if (isColorStop) {\n        colorStops.unshift(lineOrColorStop);\n        const valid = validateColorStopList(colorStops, type, opt);\n        if (valid) {\n          const res: Gradient = {\n            value,\n            type,\n            colorStopList: colorStops as ColorStopList\n          };\n          setCache(cacheKey, res);\n          return res;\n        }\n      } else if (colorStops.length > 1) {\n        const gradientLine = lineOrColorStop;\n        const valid =\n          validateGradientLine(gradientLine, type) &&\n          validateColorStopList(colorStops, type, opt);\n        if (valid) {\n          const res: Gradient = {\n            value,\n            type,\n            gradientLine,\n            colorStopList: colorStops as ColorStopList\n          };\n          setCache(cacheKey, res);\n          return res;\n        }\n      }\n    }\n    setCache(cacheKey, null);\n    return null;\n  }\n  return null;\n};\n\n/**\n * is CSS gradient\n * @param value - CSS value\n * @param [opt] - options\n * @returns result\n */\nexport const isGradient = (value: string, opt: Options = {}): boolean => {\n  const gradient = parseGradient(value, opt);\n  return gradient !== null;\n};\n","/**\n * convert\n */\n\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport {\n  convertColorToHsl,\n  convertColorToHwb,\n  convertColorToLab,\n  convertColorToLch,\n  convertColorToOklab,\n  convertColorToOklch,\n  convertColorToRgb,\n  numberToHexString,\n  parseColorFunc,\n  parseColorValue\n} from './color';\nimport { isString } from './common';\nimport { cssCalc } from './css-calc';\nimport { resolveVar } from './css-var';\nimport { resolveRelativeColor } from './relative-color';\nimport { resolveColor } from './resolve';\nimport { ColorChannels, ComputedColorChannels, Options } from './typedef';\n\n/* constants */\nimport { SYN_FN_CALC, SYN_FN_REL, SYN_FN_VAR, VAL_COMP } from './constant';\nconst NAMESPACE = 'convert';\n\n/* regexp */\nconst REG_FN_CALC = new RegExp(SYN_FN_CALC);\nconst REG_FN_REL = new RegExp(SYN_FN_REL);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\n\n/**\n * pre process\n * @param value - CSS color value\n * @param [opt] - options\n * @returns value\n */\nexport const preProcess = (\n  value: string,\n  opt: Options = {}\n): string | NullObject => {\n  if (isString(value)) {\n    value = value.trim();\n    if (!value) {\n      return new NullObject();\n    }\n  } else {\n    return new NullObject();\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'preProcess',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  if (REG_FN_VAR.test(value)) {\n    const resolvedValue = resolveVar(value, opt);\n    if (isString(resolvedValue)) {\n      value = resolvedValue;\n    } else {\n      setCache(cacheKey, null);\n      return new NullObject();\n    }\n  }\n  if (REG_FN_REL.test(value)) {\n    const resolvedValue = resolveRelativeColor(value, opt);\n    if (isString(resolvedValue)) {\n      value = resolvedValue;\n    } else {\n      setCache(cacheKey, null);\n      return new NullObject();\n    }\n  } else if (REG_FN_CALC.test(value)) {\n    value = cssCalc(value, opt);\n  }\n  if (value.startsWith('color-mix')) {\n    const clonedOpt = structuredClone(opt);\n    clonedOpt.format = VAL_COMP;\n    clonedOpt.nullable = true;\n    const resolvedValue = resolveColor(value, clonedOpt);\n    setCache(cacheKey, resolvedValue);\n    return resolvedValue;\n  }\n  setCache(cacheKey, value);\n  return value;\n};\n\n/**\n * convert number to hex string\n * @param value - numeric value\n * @returns hex string: 00..ff\n */\nexport const numberToHex = (value: number): string => {\n  const hex = numberToHexString(value);\n  return hex;\n};\n\n/**\n * convert color to hex\n * @param value - CSS color value\n * @param [opt] - options\n * @param [opt.alpha] - enable alpha channel\n * @returns #rrggbb | #rrggbbaa | null\n */\nexport const colorToHex = (value: string, opt: Options = {}): string | null => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return null;\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { alpha = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToHex',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return null;\n    }\n    return cachedResult.item as string;\n  }\n  let hex;\n  opt.nullable = true;\n  if (alpha) {\n    opt.format = 'hexAlpha';\n    hex = resolveColor(value, opt);\n  } else {\n    opt.format = 'hex';\n    hex = resolveColor(value, opt);\n  }\n  if (isString(hex)) {\n    setCache(cacheKey, hex);\n    return hex;\n  }\n  setCache(cacheKey, null);\n  return null;\n};\n\n/**\n * convert color to hsl\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [h, s, l, alpha]\n */\nexport const colorToHsl = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToHsl',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  opt.format = 'hsl';\n  const hsl = convertColorToHsl(value, opt) as ColorChannels;\n  setCache(cacheKey, hsl);\n  return hsl;\n};\n\n/**\n * convert color to hwb\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [h, w, b, alpha]\n */\nexport const colorToHwb = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToHwb',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  opt.format = 'hwb';\n  const hwb = convertColorToHwb(value, opt) as ColorChannels;\n  setCache(cacheKey, hwb);\n  return hwb;\n};\n\n/**\n * convert color to lab\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [l, a, b, alpha]\n */\nexport const colorToLab = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToLab',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  const lab = convertColorToLab(value, opt) as ColorChannels;\n  setCache(cacheKey, lab);\n  return lab;\n};\n\n/**\n * convert color to lch\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [l, c, h, alpha]\n */\nexport const colorToLch = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToLch',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  const lch = convertColorToLch(value, opt) as ColorChannels;\n  setCache(cacheKey, lch);\n  return lch;\n};\n\n/**\n * convert color to oklab\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [l, a, b, alpha]\n */\nexport const colorToOklab = (\n  value: string,\n  opt: Options = {}\n): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToOklab',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  const lab = convertColorToOklab(value, opt) as ColorChannels;\n  setCache(cacheKey, lab);\n  return lab;\n};\n\n/**\n * convert color to oklch\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [l, c, h, alpha]\n */\nexport const colorToOklch = (\n  value: string,\n  opt: Options = {}\n): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToOklch',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  const lch = convertColorToOklch(value, opt) as ColorChannels;\n  setCache(cacheKey, lch);\n  return lch;\n};\n\n/**\n * convert color to rgb\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [r, g, b, alpha]\n */\nexport const colorToRgb = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToRgb',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  const rgb = convertColorToRgb(value, opt) as ColorChannels;\n  setCache(cacheKey, rgb);\n  return rgb;\n};\n\n/**\n * convert color to xyz\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [x, y, z, alpha]\n */\nexport const colorToXyz = (value: string, opt: Options = {}): ColorChannels => {\n  if (isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue instanceof NullObject) {\n      return [0, 0, 0, 0];\n    }\n    value = resolvedValue.toLowerCase();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'colorToXyz',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as ColorChannels;\n  }\n  let xyz;\n  if (value.startsWith('color(')) {\n    [, ...xyz] = parseColorFunc(value, opt) as ComputedColorChannels;\n  } else {\n    [, ...xyz] = parseColorValue(value, opt) as ComputedColorChannels;\n  }\n  setCache(cacheKey, xyz);\n  return xyz as ColorChannels;\n};\n\n/**\n * convert color to xyz-d50\n * @param value - CSS color value\n * @param [opt] - options\n * @returns ColorChannels - [x, y, z, alpha]\n */\nexport const colorToXyzD50 = (\n  value: string,\n  opt: Options = {}\n): ColorChannels => {\n  opt.d50 = true;\n  return colorToXyz(value, opt);\n};\n\n/* convert */\nexport const convert = {\n  colorToHex,\n  colorToHsl,\n  colorToHwb,\n  colorToLab,\n  colorToLch,\n  colorToOklab,\n  colorToOklch,\n  colorToRgb,\n  colorToXyz,\n  colorToXyzD50,\n  numberToHex\n};\n"],"names":["cssCalc","isColor","import_css_calc","import_css_tokenizer","import_css_tokenizer","res","val","res","cs","pA","NAMESPACE","import_css_tokenizer","PAREN_CLOSE","COMMENT","EOF","IDENT","NUM","PCT","W_SPACE","NAMESPACE","OCT","DEC","HEX","MAX_PCT","MAX_RGB","REG_FN_VAR","colorParser","NAMESPACE","REG_FN_CALC","REG_FN_REL","REG_FN_VAR","res","PAREN_CLOSE","COMMENT","EOF","FUNC","IDENT","PAREN_OPEN","W_SPACE","NAMESPACE","DEC","HEX","DEG","DEG_HALF","REG_COLOR","REG_FN_COLOR","REG_MIX","value","PAREN_CLOSE","COMMENT","DIM","EOF","FUNC","PAREN_OPEN","W_SPACE","NAMESPACE","TRIA","HEX","MAX_PCT","REG_FN_CALC","REG_FN_MATH_START","REG_FN_VAR","l","value","parseTokens","resolvedValue","NAMESPACE","NAMESPACE","REG_FN_CALC","REG_FN_REL","REG_FN_VAR","isColor","cssCalc"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}}]
}