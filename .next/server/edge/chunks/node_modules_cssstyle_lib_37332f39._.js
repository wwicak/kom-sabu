(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/node_modules_cssstyle_lib_37332f39._.js", {

"[project]/node_modules/cssstyle/lib/allWebkitProperties.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * This file contains all implemented properties that are not a part of any
 * current specifications or drafts, but are handled by browsers nevertheless.
 */ module.exports = [
    "background-composite",
    "border-after",
    "border-after-color",
    "border-after-style",
    "border-after-width",
    "border-before",
    "border-before-color",
    "border-before-style",
    "border-before-width",
    "border-end",
    "border-end-color",
    "border-end-style",
    "border-end-width",
    "border-fit",
    "border-horizontal-spacing",
    "border-start",
    "border-start-color",
    "border-start-style",
    "border-start-width",
    "border-vertical-spacing",
    "color-correction",
    "column-axis",
    "column-break-after",
    "column-break-before",
    "column-break-inside",
    "column-rule-color",
    "flex-align",
    "flex-item-align",
    "flex-line-pack",
    "flex-order",
    "flex-pack",
    "flex-wrap",
    "font-size-delta",
    "font-smoothing",
    "highlight",
    "hyphenate-limit-after",
    "hyphenate-limit-before",
    "locale",
    "logical-height",
    "logical-width",
    "margin-after",
    "margin-after-collapse",
    "margin-before",
    "margin-before-collapse",
    "margin-bottom-collapse",
    "margin-collapse",
    "margin-end",
    "margin-start",
    "margin-top-collapse",
    "marquee",
    "marquee-direction",
    "marquee-increment",
    "marquee-repetition",
    "marquee-speed",
    "marquee-style",
    "mask-attachment",
    "mask-box-image-outset",
    "mask-box-image-repeat",
    "mask-box-image-slice",
    "mask-box-image-source",
    "mask-box-image-width",
    "mask-position-x",
    "mask-position-y",
    "mask-repeat-x",
    "mask-repeat-y",
    "match-nearest-mail-blockquote-color",
    "max-logical-height",
    "max-logical-width",
    "min-logical-height",
    "min-logical-width",
    "nbsp-mode",
    "overflow-scrolling",
    "padding-after",
    "padding-before",
    "padding-end",
    "padding-start",
    "perspective-origin-x",
    "perspective-origin-y",
    "region-break-after",
    "region-break-before",
    "region-break-inside",
    "region-overflow",
    "rtl-ordering",
    "svg-shadow",
    "tap-highlight-color",
    "text-decorations-in-effect",
    "text-emphasis-color",
    "text-fill-color",
    "text-security",
    "text-size-adjust",
    "text-stroke",
    "text-stroke-color",
    "text-stroke-width",
    "transform",
    "transform-origin-x",
    "transform-origin-y",
    "transform-origin-z",
    "user-drag",
    "user-modify",
    "wrap",
    "wrap-margin",
    "wrap-padding",
    "wrap-shape-inside",
    "wrap-shape-outside",
    "zoom"
].map((prop)=>`-webkit-${prop}`);
}}),
"[project]/node_modules/cssstyle/lib/allExtraProperties.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * This file contains all implemented properties that are not a part of any
 * current specifications or drafts, but are handled by browsers nevertheless.
 */ const allWebkitProperties = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/allWebkitProperties.js [middleware-edge] (ecmascript)");
module.exports = new Set([
    "background-position-x",
    "background-position-y",
    "background-repeat-x",
    "background-repeat-y",
    "color-interpolation",
    "color-profile",
    "color-rendering",
    "enable-background",
    "glyph-orientation-horizontal",
    "kerning",
    "marker-offset",
    "marks",
    "pointer-events",
    "shape-rendering",
    "size",
    "src",
    "stop-color",
    "stop-opacity",
    "text-anchor",
    "text-line-through",
    "text-line-through-color",
    "text-line-through-mode",
    "text-line-through-style",
    "text-line-through-width",
    "text-overline",
    "text-overline-color",
    "text-overline-mode",
    "text-overline-style",
    "text-overline-width",
    "text-rendering",
    "text-underline",
    "text-underline-color",
    "text-underline-mode",
    "text-underline-style",
    "text-underline-width",
    "unicode-range",
    "vector-effect",
    ...allWebkitProperties
]);
}}),
"[project]/node_modules/cssstyle/lib/generated/allProperties.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// autogenerated - 2025-05-14
// https://www.w3.org/Style/CSS/all-properties.en.html
module.exports = new Set([
    "-webkit-line-clamp",
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "anchor-scope",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "azimuth",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "baseline-source",
    "block-ellipsis",
    "block-size",
    "block-step",
    "block-step-align",
    "block-step-insert",
    "block-step-round",
    "block-step-size",
    "bookmark-label",
    "bookmark-level",
    "bookmark-state",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-boundary",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "box-snap",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret",
    "caret-color",
    "caret-shape",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-adjust",
    "color-interpolation-filters",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-break",
    "column-rule-color",
    "column-rule-outset",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "continue",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "direction",
    "display",
    "dominant-baseline",
    "dynamic-range-limit",
    "elevation",
    "empty-cells",
    "fill",
    "fill-break",
    "fill-color",
    "fill-image",
    "fill-opacity",
    "fill-origin",
    "fill-position",
    "fill-repeat",
    "fill-rule",
    "fill-size",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "float-defer",
    "float-offset",
    "float-reference",
    "flood-color",
    "flood-opacity",
    "flow-from",
    "flow-into",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "font-width",
    "footnote-display",
    "footnote-policy",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphenate-limit-last",
    "hyphenate-limit-lines",
    "hyphenate-limit-zone",
    "hyphens",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "initial-letter",
    "initial-letter-align",
    "initial-letter-wrap",
    "inline-size",
    "inline-sizing",
    "inset",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "interpolate-size",
    "isolation",
    "item-cross",
    "item-direction",
    "item-flow",
    "item-pack",
    "item-slack",
    "item-track",
    "item-wrap",
    "justify-content",
    "justify-items",
    "justify-self",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-clamp",
    "line-fit-edge",
    "line-grid",
    "line-height",
    "line-height-step",
    "line-padding",
    "line-snap",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-break",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-knockout-left",
    "marker-knockout-right",
    "marker-mid",
    "marker-pattern",
    "marker-segment",
    "marker-side",
    "marker-start",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-lines",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-intrinsic-sizing",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-left",
    "nav-right",
    "nav-up",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-clip-margin-block",
    "overflow-clip-margin-block-end",
    "overflow-clip-margin-block-start",
    "overflow-clip-margin-bottom",
    "overflow-clip-margin-inline",
    "overflow-clip-margin-inline-end",
    "overflow-clip-margin-inline-start",
    "overflow-clip-margin-left",
    "overflow-clip-margin-right",
    "overflow-clip-margin-top",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "pitch",
    "pitch-range",
    "place-content",
    "place-items",
    "place-self",
    "play-during",
    "position",
    "position-anchor",
    "position-area",
    "position-try",
    "position-try-fallbacks",
    "position-try-order",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "reading-flow",
    "region-fragment",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "richness",
    "right",
    "rotate",
    "row-gap",
    "row-rule",
    "row-rule-break",
    "row-rule-color",
    "row-rule-outset",
    "row-rule-style",
    "row-rule-width",
    "ruby-align",
    "ruby-merge",
    "ruby-overhang",
    "ruby-position",
    "rule",
    "rule-break",
    "rule-color",
    "rule-outset",
    "rule-paint-order",
    "rule-style",
    "rule-width",
    "running",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-marker-group",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-start-target",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-inside",
    "shape-margin",
    "shape-outside",
    "slider-orientation",
    "spatial-navigation-action",
    "spatial-navigation-contain",
    "spatial-navigation-function",
    "speak",
    "speak-as",
    "speak-header",
    "speak-numeral",
    "speak-punctuation",
    "speech-rate",
    "stress",
    "string-set",
    "stroke",
    "stroke-align",
    "stroke-alignment",
    "stroke-break",
    "stroke-color",
    "stroke-dash-corner",
    "stroke-dash-justify",
    "stroke-dashadjust",
    "stroke-dasharray",
    "stroke-dashcorner",
    "stroke-dashoffset",
    "stroke-image",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-origin",
    "stroke-position",
    "stroke-repeat",
    "stroke-size",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-autospace",
    "text-box",
    "text-box-edge",
    "text-box-trim",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-box",
    "text-decoration-skip-ink",
    "text-decoration-skip-inset",
    "text-decoration-skip-self",
    "text-decoration-skip-spaces",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-skip",
    "text-emphasis-style",
    "text-group-align",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-shadow",
    "text-spacing",
    "text-spacing-trim",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-select",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-class",
    "view-transition-group",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "volume",
    "white-space",
    "white-space-collapse",
    "white-space-trim",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-space-transform",
    "word-spacing",
    "word-wrap",
    "wrap-after",
    "wrap-before",
    "wrap-flow",
    "wrap-inside",
    "wrap-through",
    "writing-mode",
    "z-index"
]);
}}),
"[project]/node_modules/cssstyle/lib/generated/implementedProperties.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// autogenerated - 2025-06-08
// https://www.w3.org/Style/CSS/all-properties.en.html
module.exports = new Set([
    "background",
    "background-attachment",
    "background-color",
    "background-image",
    "background-position",
    "background-repeat",
    "border",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "clear",
    "clip",
    "color",
    "flex",
    "flex-basis",
    "flex-grow",
    "flex-shrink",
    "float",
    "flood-color",
    "font",
    "font-family",
    "font-size",
    "font-style",
    "font-variant",
    "font-weight",
    "height",
    "left",
    "lighting-color",
    "line-height",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "opacity",
    "outline-color",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "right",
    "stop-color",
    "top",
    "-webkit-border-after-color",
    "-webkit-border-before-color",
    "-webkit-border-end-color",
    "-webkit-border-start-color",
    "-webkit-column-rule-color",
    "-webkit-tap-highlight-color",
    "-webkit-text-emphasis-color",
    "-webkit-text-fill-color",
    "-webkit-text-stroke-color",
    "width"
]);
}}),
"[project]/node_modules/cssstyle/lib/parsers.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * These are commonly used parsers for CSS Values they take a string to parse
 * and return a string after it's been converted, if needed
 */ "use strict";
const { resolve: resolveColor, utils } = __turbopack_context__.r("[project]/node_modules/@asamuzakjp/css-color/dist/cjs/index.cjs [middleware-edge] (ecmascript)");
const { cssCalc, isColor, isGradient, splitValue } = utils;
// CSS global values
// @see https://drafts.csswg.org/css-cascade-5/#defaulting-keywords
const GLOBAL_VALUE = Object.freeze([
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
]);
// Numeric data types
const NUM_TYPE = Object.freeze({
    UNDEFINED: 0,
    VAR: 1,
    NUMBER: 2,
    PERCENT: 4,
    LENGTH: 8,
    ANGLE: 0x10,
    CALC: 0x20
});
// System colors
const SYS_COLOR = Object.freeze([
    "accentcolor",
    "accentcolortext",
    "activetext",
    "buttonborder",
    "buttonface",
    "buttontext",
    "canvas",
    "canvastext",
    "field",
    "fieldtext",
    "graytext",
    "highlight",
    "highlighttext",
    "linktext",
    "mark",
    "marktext",
    "visitedtext",
    "activeborder",
    "activecaption",
    "appworkspace",
    "background",
    "buttonhighlight",
    "buttonshadow",
    "captiontext",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infobackground",
    "infotext",
    "menu",
    "menutext",
    "scrollbar",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "window",
    "windowframe",
    "windowtext"
]);
// Regular expressions
const DIGIT = "(?:0|[1-9]\\d*)";
const NUMBER = `[+-]?(?:${DIGIT}(?:\\.\\d*)?|\\.\\d+)(?:e-?${DIGIT})?`;
const unitRegEx = new RegExp(`^(${NUMBER})([a-z]+|%)?$`, "i");
const urlRegEx = /^url\(\s*((?:[^)]|\\\))*)\s*\)$/;
const keywordRegEx = /^[a-z]+(?:-[a-z]+)*$/i;
const stringRegEx = /^("[^"]*"|'[^']*')$/;
const varRegEx = /^var\(/;
const varContainedRegEx = /(?<=[*/\s(])var\(/;
const calcRegEx = /^(?:a?(?:cos|sin|tan)|abs|atan2|calc|clamp|exp|hypot|log|max|min|mod|pow|rem|round|sign|sqrt)\(/;
const getNumericType = function getNumericType(val) {
    if (varRegEx.test(val)) {
        return NUM_TYPE.VAR;
    }
    if (calcRegEx.test(val)) {
        return NUM_TYPE.CALC;
    }
    if (unitRegEx.test(val)) {
        const [, , unit] = unitRegEx.exec(val);
        if (!unit) {
            return NUM_TYPE.NUMBER;
        }
        if (unit === "%") {
            return NUM_TYPE.PERCENT;
        }
        if (/^(?:[cm]m|[dls]?v(?:[bhiw]|max|min)|in|p[ctx]|q|r?(?:[cl]h|cap|e[mx]|ic))$/i.test(unit)) {
            return NUM_TYPE.LENGTH;
        }
        if (/^(?:deg|g?rad|turn)$/i.test(unit)) {
            return NUM_TYPE.ANGLE;
        }
    }
    return NUM_TYPE.UNDEFINED;
};
// Prepare stringified value.
exports.prepareValue = function prepareValue(value, globalObject = globalThis) {
    // `null` is converted to an empty string.
    // @see https://webidl.spec.whatwg.org/#LegacyNullToEmptyString
    if (value === null) {
        return "";
    }
    const type = typeof value;
    switch(type){
        case "string":
            return value.trim();
        case "number":
            return value.toString();
        case "undefined":
            return "undefined";
        case "symbol":
            throw new globalObject.TypeError("Can not convert symbol to string.");
        default:
            {
                const str = value.toString();
                if (typeof str === "string") {
                    return str;
                }
                throw new globalObject.TypeError(`Can not convert ${type} to string.`);
            }
    }
};
exports.hasVarFunc = function hasVarFunc(val) {
    return varRegEx.test(val) || varContainedRegEx.test(val);
};
exports.parseNumber = function parseNumber(val, restrictToPositive = false) {
    if (val === "") {
        return "";
    }
    const type = getNumericType(val);
    switch(type){
        case NUM_TYPE.VAR:
            return val;
        case NUM_TYPE.CALC:
            return cssCalc(val, {
                format: "specifiedValue"
            });
        case NUM_TYPE.NUMBER:
            {
                const num = parseFloat(val);
                if (restrictToPositive && num < 0) {
                    return;
                }
                return `${num}`;
            }
        default:
            if (varContainedRegEx.test(val)) {
                return val;
            }
    }
};
exports.parseLength = function parseLength(val, restrictToPositive = false) {
    if (val === "") {
        return "";
    }
    const type = getNumericType(val);
    switch(type){
        case NUM_TYPE.VAR:
            return val;
        case NUM_TYPE.CALC:
            return cssCalc(val, {
                format: "specifiedValue"
            });
        case NUM_TYPE.NUMBER:
            if (parseFloat(val) === 0) {
                return "0px";
            }
            return;
        case NUM_TYPE.LENGTH:
            {
                const [, numVal, unit] = unitRegEx.exec(val);
                const num = parseFloat(numVal);
                if (restrictToPositive && num < 0) {
                    return;
                }
                return `${num}${unit.toLowerCase()}`;
            }
        default:
            if (varContainedRegEx.test(val)) {
                return val;
            }
    }
};
exports.parsePercent = function parsePercent(val, restrictToPositive = false) {
    if (val === "") {
        return "";
    }
    const type = getNumericType(val);
    switch(type){
        case NUM_TYPE.VAR:
            return val;
        case NUM_TYPE.CALC:
            return cssCalc(val, {
                format: "specifiedValue"
            });
        case NUM_TYPE.NUMBER:
            if (parseFloat(val) === 0) {
                return "0%";
            }
            return;
        case NUM_TYPE.PERCENT:
            {
                const [, numVal, unit] = unitRegEx.exec(val);
                const num = parseFloat(numVal);
                if (restrictToPositive && num < 0) {
                    return;
                }
                return `${num}${unit.toLowerCase()}`;
            }
        default:
            if (varContainedRegEx.test(val)) {
                return val;
            }
    }
};
// Either a length or a percent.
exports.parseMeasurement = function parseMeasurement(val, restrictToPositive = false) {
    if (val === "") {
        return "";
    }
    const type = getNumericType(val);
    switch(type){
        case NUM_TYPE.VAR:
            return val;
        case NUM_TYPE.CALC:
            return cssCalc(val, {
                format: "specifiedValue"
            });
        case NUM_TYPE.NUMBER:
            if (parseFloat(val) === 0) {
                return "0px";
            }
            return;
        case NUM_TYPE.LENGTH:
        case NUM_TYPE.PERCENT:
            {
                const [, numVal, unit] = unitRegEx.exec(val);
                const num = parseFloat(numVal);
                if (restrictToPositive && num < 0) {
                    return;
                }
                return `${num}${unit.toLowerCase()}`;
            }
        default:
            if (varContainedRegEx.test(val)) {
                return val;
            }
    }
};
exports.parseAngle = function parseAngle(val, normalizeDeg = false) {
    if (val === "") {
        return "";
    }
    const type = getNumericType(val);
    switch(type){
        case NUM_TYPE.VAR:
            return val;
        case NUM_TYPE.CALC:
            return cssCalc(val, {
                format: "specifiedValue"
            });
        case NUM_TYPE.NUMBER:
            if (parseFloat(val) === 0) {
                return "0deg";
            }
            return;
        case NUM_TYPE.ANGLE:
            {
                let [, numVal, unit] = unitRegEx.exec(val);
                numVal = parseFloat(numVal);
                unit = unit.toLowerCase();
                if (unit === "deg") {
                    if (normalizeDeg && numVal < 0) {
                        while(numVal < 0){
                            numVal += 360;
                        }
                    }
                    numVal %= 360;
                }
                return `${numVal}${unit}`;
            }
        default:
            if (varContainedRegEx.test(val)) {
                return val;
            }
    }
};
exports.parseUrl = function parseUrl(val) {
    if (val === "") {
        return val;
    }
    const res = urlRegEx.exec(val);
    if (!res) {
        return;
    }
    let str = res[1];
    // If it starts with single or double quotes, does it end with the same?
    if ((str[0] === '"' || str[0] === "'") && str[0] !== str[str.length - 1]) {
        return;
    }
    if (str[0] === '"' || str[0] === "'") {
        str = str.substr(1, str.length - 2);
    }
    let urlstr = "";
    let escaped = false;
    for(let i = 0; i < str.length; i++){
        switch(str[i]){
            case "\\":
                if (escaped) {
                    urlstr += "\\\\";
                    escaped = false;
                } else {
                    escaped = true;
                }
                break;
            case "(":
            case ")":
            case " ":
            case "\t":
            case "\n":
            case "'":
                if (!escaped) {
                    return;
                }
                urlstr += str[i];
                escaped = false;
                break;
            case '"':
                if (!escaped) {
                    return;
                }
                urlstr += '\\"';
                escaped = false;
                break;
            default:
                urlstr += str[i];
                escaped = false;
        }
    }
    return `url("${urlstr}")`;
};
exports.parseString = function parseString(val) {
    if (val === "") {
        return "";
    }
    if (!stringRegEx.test(val)) {
        return;
    }
    val = val.substr(1, val.length - 2);
    let str = "";
    let escaped = false;
    for(let i = 0; i < val.length; i++){
        switch(val[i]){
            case "\\":
                if (escaped) {
                    str += "\\\\";
                    escaped = false;
                } else {
                    escaped = true;
                }
                break;
            case '"':
                str += '\\"';
                escaped = false;
                break;
            default:
                str += val[i];
                escaped = false;
        }
    }
    return `"${str}"`;
};
exports.parseKeyword = function parseKeyword(val, validKeywords = []) {
    if (val === "") {
        return "";
    }
    if (varRegEx.test(val)) {
        return val;
    }
    val = val.toString().toLowerCase();
    if (validKeywords.includes(val) || GLOBAL_VALUE.includes(val)) {
        return val;
    }
};
exports.parseColor = function parseColor(val) {
    if (val === "") {
        return "";
    }
    if (varRegEx.test(val)) {
        return val;
    }
    if (/^[a-z]+$/i.test(val) && SYS_COLOR.includes(val.toLowerCase())) {
        return val;
    }
    const res = resolveColor(val, {
        format: "specifiedValue"
    });
    if (res) {
        return res;
    }
    return exports.parseKeyword(val);
};
exports.parseImage = function parseImage(val) {
    if (val === "") {
        return "";
    }
    if (varRegEx.test(val)) {
        return val;
    }
    if (keywordRegEx.test(val)) {
        return exports.parseKeyword(val, [
            "none"
        ]);
    }
    const values = splitValue(val, {
        delimiter: ",",
        preserveComment: varContainedRegEx.test(val)
    });
    let isImage = Boolean(values.length);
    for(let i = 0; i < values.length; i++){
        const image = values[i];
        if (image === "") {
            return "";
        }
        if (isGradient(image) || /^(?:none|inherit)$/i.test(image)) {
            continue;
        }
        const imageUrl = exports.parseUrl(image);
        if (imageUrl) {
            values[i] = imageUrl;
        } else {
            isImage = false;
            break;
        }
    }
    if (isImage) {
        return values.join(", ");
    }
};
exports.parseShorthand = function parseShorthand(val, shorthandFor, preserve = false) {
    const obj = {};
    if (val === "" || exports.hasVarFunc(val)) {
        for (const [property] of shorthandFor){
            obj[property] = "";
        }
        return obj;
    }
    const key = exports.parseKeyword(val);
    if (key) {
        if (key === "inherit") {
            return obj;
        }
        return;
    }
    const parts = splitValue(val);
    const shorthandArr = [
        ...shorthandFor
    ];
    for (const part of parts){
        let partValid = false;
        for(let i = 0; i < shorthandArr.length; i++){
            const [property, value] = shorthandArr[i];
            if (value.isValid(part)) {
                partValid = true;
                obj[property] = value.parse(part);
                if (!preserve) {
                    shorthandArr.splice(i, 1);
                    break;
                }
            }
        }
        if (!partValid) {
            return;
        }
    }
    return obj;
};
// Returns `false` for global values, e.g. "inherit".
exports.isValidColor = function isValidColor(val) {
    if (SYS_COLOR.includes(val.toLowerCase())) {
        return true;
    }
    return isColor(val);
};
// Splits value into an array.
// @see https://github.com/asamuzaK/cssColor/blob/main/src/js/util.ts
exports.splitValue = splitValue;
}}),
"[project]/node_modules/cssstyle/lib/generated/properties.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// autogenerated - 2025-06-08
// https://www.w3.org/Style/CSS/all-properties.en.html
var external_dependency_parsers_0 = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/parsers.js [middleware-edge] (ecmascript)");
var backgroundImage_export_parse, backgroundImage_export_isValid, backgroundImage_export_definition;
backgroundImage_export_parse = function parse(v) {
    return external_dependency_parsers_0.parseImage(v);
};
backgroundImage_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v, [
        "none"
    ]) === "string") {
        return true;
    }
    return typeof backgroundImage_export_parse(v) === "string";
};
backgroundImage_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("background", "");
            this._setProperty("backgound-image", v);
        } else {
            this._setProperty("background-image", backgroundImage_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("background-image");
    },
    enumerable: true,
    configurable: true
};
var backgroundPosition_export_parse, backgroundPosition_export_isValid, backgroundPosition_export_definition;
backgroundPosition_export_parse = function parse(v) {
    const parts = external_dependency_parsers_0.splitValue(v);
    if (!parts.length || parts.length > 2) {
        return;
    }
    const validKeywordsX = [
        "left",
        "center",
        "right"
    ];
    const validKeywordsY = [
        "top",
        "center",
        "bottom"
    ];
    if (parts.length === 1) {
        const dim = external_dependency_parsers_0.parseMeasurement(parts[0]);
        if (dim) {
            return dim;
        }
        const validKeywords = new Set([
            ...validKeywordsX,
            ...validKeywordsY
        ]);
        return external_dependency_parsers_0.parseKeyword(v, [
            ...validKeywords
        ]);
    }
    const [partX, partY] = parts;
    const posX = external_dependency_parsers_0.parseMeasurement(partX) || external_dependency_parsers_0.parseKeyword(partX, validKeywordsX);
    if (posX) {
        const posY = external_dependency_parsers_0.parseMeasurement(partY) || external_dependency_parsers_0.parseKeyword(partY, validKeywordsY);
        if (posY) {
            return `${posX} ${posY}`;
        }
    }
};
backgroundPosition_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof backgroundPosition_export_parse(v) === "string";
};
backgroundPosition_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("background", "");
            this._setProperty("backgound-position", v);
        } else {
            this._setProperty("background-position", backgroundPosition_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("background-position");
    },
    enumerable: true,
    configurable: true
};
var backgroundRepeat_export_parse, backgroundRepeat_export_isValid, backgroundRepeat_export_definition;
backgroundRepeat_export_parse = function parse(v) {
    const keywords = [
        "repeat",
        "repeat-x",
        "repeat-y",
        "no-repeat",
        "space",
        "round"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
backgroundRepeat_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof backgroundRepeat_export_parse(v) === "string";
};
backgroundRepeat_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("background", "");
            this._setProperty("backgound-repeat", v);
        } else {
            this._setProperty("background-repeat", backgroundRepeat_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("background-repeat");
    },
    enumerable: true,
    configurable: true
};
var backgroundAttachment_export_parse, backgroundAttachment_export_isValid, backgroundAttachment_export_definition;
backgroundAttachment_export_parse = function parse(v) {
    const keywords = [
        "fixed",
        "scroll",
        "local"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
backgroundAttachment_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof backgroundAttachment_export_parse(v) === "string";
};
backgroundAttachment_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("background", "");
            this._setProperty("backgound-attachemnt", v);
        } else {
            this._setProperty("background-attachment", backgroundAttachment_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("background-attachment");
    },
    enumerable: true,
    configurable: true
};
var backgroundColor_export_parse, backgroundColor_export_isValid, backgroundColor_export_definition;
backgroundColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
backgroundColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
backgroundColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("background", "");
            this._setProperty("backgound-color", v);
        } else {
            this._setProperty("background-color", backgroundColor_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("background-color");
    },
    enumerable: true,
    configurable: true
};
var background_export_definition;
// FIXME:
// * support multiple backgrounds
// * also fix longhands
const background_local_var_shorthandFor = new Map([
    [
        "background-image",
        {
            parse: backgroundImage_export_parse,
            isValid: backgroundImage_export_isValid,
            definition: backgroundImage_export_definition
        }
    ],
    [
        "background-position",
        {
            parse: backgroundPosition_export_parse,
            isValid: backgroundPosition_export_isValid,
            definition: backgroundPosition_export_definition
        }
    ],
    [
        "background-repeat",
        {
            parse: backgroundRepeat_export_parse,
            isValid: backgroundRepeat_export_isValid,
            definition: backgroundRepeat_export_definition
        }
    ],
    [
        "background-attachment",
        {
            parse: backgroundAttachment_export_parse,
            isValid: backgroundAttachment_export_isValid,
            definition: backgroundAttachment_export_definition
        }
    ],
    [
        "background-color",
        {
            parse: backgroundColor_export_parse,
            isValid: backgroundColor_export_isValid,
            definition: backgroundColor_export_definition
        }
    ]
]);
background_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (v.toLowerCase() === "none" || external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of background_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("background", v);
        } else {
            this._shorthandSetter("background", v, background_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("background");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("background", background_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var borderWidth_export_parse, borderWidth_export_isValid, borderWidth_export_definition;
borderWidth_export_parse = function parse(v) {
    const keywords = [
        "thin",
        "medium",
        "thick"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    return external_dependency_parsers_0.parseLength(v, true);
};
borderWidth_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderWidth_export_parse(v) === "string";
};
borderWidth_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-width", v);
        } else {
            const positions = [
                "top",
                "right",
                "bottom",
                "left"
            ];
            this._implicitSetter("border", "width", v, borderWidth_export_isValid, borderWidth_export_parse, positions);
        }
    },
    get () {
        return this.getPropertyValue("border-width");
    },
    enumerable: true,
    configurable: true
};
var borderStyle_export_parse, borderStyle_export_isValid, borderStyle_export_definition;
borderStyle_export_parse = function parse(v) {
    const keywords = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderStyle_export_parse(v) === "string";
};
borderStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (v.toLowerCase() === "none") {
            v = "";
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-style", v);
            return;
        }
        const positions = [
            "top",
            "right",
            "bottom",
            "left"
        ];
        this._implicitSetter("border", "style", v, borderStyle_export_isValid, borderStyle_export_parse, positions);
    },
    get () {
        return this.getPropertyValue("border-style");
    },
    enumerable: true,
    configurable: true
};
var borderColor_export_parse, borderColor_export_isValid, borderColor_export_definition;
borderColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
borderColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
borderColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-color", v);
        } else {
            const positions = [
                "top",
                "right",
                "bottom",
                "left"
            ];
            this._implicitSetter("border", "color", v, borderColor_export_isValid, borderColor_export_parse, positions);
        }
    },
    get () {
        return this.getPropertyValue("border-color");
    },
    enumerable: true,
    configurable: true
};
var border_export_definition;
const border_local_var_shorthandFor = new Map([
    [
        "border-width",
        {
            parse: borderWidth_export_parse,
            isValid: borderWidth_export_isValid,
            definition: borderWidth_export_definition
        }
    ],
    [
        "border-style",
        {
            parse: borderStyle_export_parse,
            isValid: borderStyle_export_isValid,
            definition: borderStyle_export_definition
        }
    ],
    [
        "border-color",
        {
            parse: borderColor_export_parse,
            isValid: borderColor_export_isValid,
            definition: borderColor_export_definition
        }
    ]
]);
border_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (v.toLowerCase() === "none") {
            v = "";
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of border_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("border", v);
        } else {
            this._midShorthandSetter("border", v, border_local_var_shorthandFor, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        let val = this.getPropertyValue("border");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("border", border_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var borderTopWidth_export_parse, borderTopWidth_export_isValid, borderTopWidth_export_definition;
borderTopWidth_export_parse = function parse(v) {
    const keywords = [
        "thin",
        "medium",
        "thick"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    return external_dependency_parsers_0.parseLength(v, true);
};
borderTopWidth_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderTopWidth_export_parse(v) === "string";
};
borderTopWidth_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-top", "");
            this._setProperty("border-width", "");
        }
        this._setProperty("border-top-width", borderTopWidth_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-top-width");
    },
    enumerable: true,
    configurable: true
};
var borderTopStyle_export_parse, borderTopStyle_export_isValid, borderTopStyle_export_definition;
borderTopStyle_export_parse = function parse(v) {
    const keywords = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderTopStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderTopStyle_export_parse(v) === "string";
};
borderTopStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        const val = borderTopStyle_export_parse(v);
        if (val === "none" || val === "hidden" || v === "") {
            this._setProperty("border-top-style", "");
            this._setProperty("border-top-color", "");
            this._setProperty("border-top-width", "");
            return;
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-top", "");
            this._setProperty("border-style", "");
        }
        this._setProperty("border-top-style", val);
    },
    get () {
        return this.getPropertyValue("border-top-style");
    },
    enumerable: true,
    configurable: true
};
var borderTopColor_export_parse, borderTopColor_export_isValid, borderTopColor_export_definition;
borderTopColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
borderTopColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
borderTopColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-top", "");
            this._setProperty("border-color", "");
        }
        this._setProperty("border-top-color", borderTopColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-top-color");
    },
    enumerable: true,
    configurable: true
};
var borderBottom_export_definition;
const borderBottom_local_var_shorthandFor = new Map([
    [
        "border-bottom-width",
        {
            parse: borderTopWidth_export_parse,
            isValid: borderTopWidth_export_isValid,
            definition: borderTopWidth_export_definition
        }
    ],
    [
        "border-bottom-style",
        {
            parse: borderTopStyle_export_parse,
            isValid: borderTopStyle_export_isValid,
            definition: borderTopStyle_export_definition
        }
    ],
    [
        "border-bottom-color",
        {
            parse: borderTopColor_export_parse,
            isValid: borderTopColor_export_isValid,
            definition: borderTopColor_export_definition
        }
    ]
]);
borderBottom_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of borderBottom_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("border", "");
            this._setProperty("border-bottom", v);
        } else {
            this._shorthandSetter("border-bottom", v, borderBottom_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("border-bottom");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("border-bottom", borderBottom_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var borderBottomColor_export_parse, borderBottomColor_export_isValid, borderBottomColor_export_definition;
borderBottomColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
borderBottomColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
borderBottomColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-bottom", "");
            this._setProperty("border-color", "");
        }
        this._setProperty("border-bottom-color", borderBottomColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-bottom-color");
    },
    enumerable: true,
    configurable: true
};
var borderBottomStyle_export_parse, borderBottomStyle_export_isValid, borderBottomStyle_export_definition;
borderBottomStyle_export_parse = function parse(v) {
    const keywords = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderBottomStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderBottomStyle_export_parse(v) === "string";
};
borderBottomStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        const val = borderBottomStyle_export_parse(v);
        if (val === "none" || val === "hidden") {
            this._setProperty("border-bottom-style", "");
            this._setProperty("border-bottom-color", "");
            this._setProperty("border-bottom-width", "");
            return;
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-bottom", "");
            this._setProperty("border-style", "");
        }
        this._setProperty("border-bottom-style", val);
    },
    get () {
        return this.getPropertyValue("border-bottom-style");
    },
    enumerable: true,
    configurable: true
};
var borderBottomWidth_export_parse, borderBottomWidth_export_isValid, borderBottomWidth_export_definition;
borderBottomWidth_export_parse = function parse(v) {
    const keywords = [
        "thin",
        "medium",
        "thick"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    return external_dependency_parsers_0.parseLength(v, true);
};
borderBottomWidth_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderBottomWidth_export_parse(v) === "string";
};
borderBottomWidth_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-bottom", "");
            this._setProperty("border-width", "");
        }
        this._setProperty("border-bottom-width", borderBottomWidth_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-bottom-width");
    },
    enumerable: true,
    configurable: true
};
var borderCollapse_export_parse, borderCollapse_export_isValid, borderCollapse_export_definition;
borderCollapse_export_parse = function parse(v) {
    return external_dependency_parsers_0.parseKeyword(v, [
        "collapse",
        "separate"
    ]);
};
borderCollapse_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderCollapse_export_parse(v) === "string";
};
borderCollapse_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("border-collapse", borderCollapse_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-collapse");
    },
    enumerable: true,
    configurable: true
};
var borderLeft_export_definition;
const borderLeft_local_var_shorthandFor = new Map([
    [
        "border-left-width",
        {
            parse: borderTopWidth_export_parse,
            isValid: borderTopWidth_export_isValid,
            definition: borderTopWidth_export_definition
        }
    ],
    [
        "border-left-style",
        {
            parse: borderTopStyle_export_parse,
            isValid: borderTopStyle_export_isValid,
            definition: borderTopStyle_export_definition
        }
    ],
    [
        "border-left-color",
        {
            parse: borderTopColor_export_parse,
            isValid: borderTopColor_export_isValid,
            definition: borderTopColor_export_definition
        }
    ]
]);
borderLeft_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of borderLeft_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("border", "");
            this._setProperty("border-left", v);
        } else {
            this._shorthandSetter("border-left", v, borderLeft_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("border-left");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("border-left", borderLeft_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var borderLeftColor_export_parse, borderLeftColor_export_isValid, borderLeftColor_export_definition;
borderLeftColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
borderLeftColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
borderLeftColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-left", "");
            this._setProperty("border-color", "");
        }
        this._setProperty("border-left-color", borderLeftColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-left-color");
    },
    enumerable: true,
    configurable: true
};
var borderLeftStyle_export_parse, borderLeftStyle_export_isValid, borderLeftStyle_export_definition;
borderLeftStyle_export_parse = function parse(v) {
    const keywords = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderLeftStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderLeftStyle_export_parse(v) === "string";
};
borderLeftStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        const val = borderLeftStyle_export_parse(v);
        if (val === "none" || val === "hidden") {
            this._setProperty("border-left-style", "");
            this._setProperty("border-left-color", "");
            this._setProperty("border-left-width", "");
            return;
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-left", "");
            this._setProperty("border-style", "");
        }
        this._setProperty("border-left-style", val);
    },
    get () {
        return this.getPropertyValue("border-left-style");
    },
    enumerable: true,
    configurable: true
};
var borderLeftWidth_export_parse, borderLeftWidth_export_isValid, borderLeftWidth_export_definition;
borderLeftWidth_export_parse = function parse(v) {
    const keywords = [
        "thin",
        "medium",
        "thick"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    return external_dependency_parsers_0.parseLength(v, true);
};
borderLeftWidth_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderLeftWidth_export_parse(v) === "string";
};
borderLeftWidth_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-left", "");
            this._setProperty("border-width", "");
        }
        this._setProperty("border-left-width", borderLeftWidth_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-left-width");
    },
    enumerable: true,
    configurable: true
};
var borderRight_export_definition;
const borderRight_local_var_shorthandFor = new Map([
    [
        "border-right-width",
        {
            parse: borderTopWidth_export_parse,
            isValid: borderTopWidth_export_isValid,
            definition: borderTopWidth_export_definition
        }
    ],
    [
        "border-right-style",
        {
            parse: borderTopStyle_export_parse,
            isValid: borderTopStyle_export_isValid,
            definition: borderTopStyle_export_definition
        }
    ],
    [
        "border-right-color",
        {
            parse: borderTopColor_export_parse,
            isValid: borderTopColor_export_isValid,
            definition: borderTopColor_export_definition
        }
    ]
]);
borderRight_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of borderRight_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("border", "");
            this._setProperty("border-right", v);
        } else {
            this._shorthandSetter("border-right", v, borderRight_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("border-right");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("border-right", borderRight_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var borderRightColor_export_parse, borderRightColor_export_isValid, borderRightColor_export_definition;
borderRightColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
borderRightColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
borderRightColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-right", "");
            this._setProperty("border-color", "");
        }
        this._setProperty("border-right-color", borderRightColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-right-color");
    },
    enumerable: true,
    configurable: true
};
var borderRightStyle_export_parse, borderRightStyle_export_isValid, borderRightStyle_export_definition;
borderRightStyle_export_parse = function parse(v) {
    const keywords = [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderRightStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderRightStyle_export_parse(v) === "string";
};
borderRightStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        const val = borderRightStyle_export_parse(v);
        if (val === "none" || val === "hidden") {
            this._setProperty("border-right-style", "");
            this._setProperty("border-right-color", "");
            this._setProperty("border-right-width", "");
            return;
        }
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-right", "");
            this._setProperty("border-style", "");
        }
        this._setProperty("border-right-style", val);
    },
    get () {
        return this.getPropertyValue("border-right-style");
    },
    enumerable: true,
    configurable: true
};
var borderRightWidth_export_parse, borderRightWidth_export_isValid, borderRightWidth_export_definition;
borderRightWidth_export_parse = function parse(v) {
    const keywords = [
        "thin",
        "medium",
        "thick"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    return external_dependency_parsers_0.parseLength(v, true);
};
borderRightWidth_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderRightWidth_export_parse(v) === "string";
};
borderRightWidth_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("border", "");
            this._setProperty("border-right", "");
            this._setProperty("border-width", "");
        }
        this._setProperty("border-right-width", borderRightWidth_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-right-width");
    },
    enumerable: true,
    configurable: true
};
var borderSpacing_export_parse, borderSpacing_export_isValid, borderSpacing_export_definition;
borderSpacing_export_parse = function parse(v) {
    if (v === "") {
        return v;
    }
    const key = external_dependency_parsers_0.parseKeyword(v);
    if (key) {
        return key;
    }
    const parts = external_dependency_parsers_0.splitValue(v);
    if (!parts.length || parts.length > 2) {
        return;
    }
    const val = [];
    for (const part of parts){
        const dim = external_dependency_parsers_0.parseLength(part);
        if (!dim) {
            return;
        }
        val.push(dim);
    }
    return val.join(" ");
};
borderSpacing_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof borderSpacing_export_parse(v) === "string";
};
borderSpacing_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("border-spacing", borderSpacing_export_parse(v));
    },
    get () {
        return this.getPropertyValue("border-spacing");
    },
    enumerable: true,
    configurable: true
};
var borderTop_export_definition;
const borderTop_local_var_shorthandFor = new Map([
    [
        "border-top-width",
        {
            parse: borderTopWidth_export_parse,
            isValid: borderTopWidth_export_isValid,
            definition: borderTopWidth_export_definition
        }
    ],
    [
        "border-top-style",
        {
            parse: borderTopStyle_export_parse,
            isValid: borderTopStyle_export_isValid,
            definition: borderTopStyle_export_definition
        }
    ],
    [
        "border-top-color",
        {
            parse: borderTopColor_export_parse,
            isValid: borderTopColor_export_isValid,
            definition: borderTopColor_export_definition
        }
    ]
]);
borderTop_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of borderTop_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("border", "");
            this._setProperty("border-top", v);
        } else {
            this._shorthandSetter("border-top", v, borderTop_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("border-top");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("border-top", borderTop_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var bottom_export_parse, bottom_export_isValid, bottom_export_definition;
bottom_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v);
    if (dim) {
        return dim;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
bottom_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof bottom_export_parse(v) === "string";
};
bottom_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("bottom", bottom_export_parse(v));
    },
    get () {
        return this.getPropertyValue("bottom");
    },
    enumerable: true,
    configurable: true
};
var clear_export_parse, clear_export_isValid, clear_export_definition;
clear_export_parse = function parse(v) {
    const keywords = [
        "inline-start",
        "inline-end",
        "block-start",
        "block-end",
        "left",
        "right",
        "top",
        "bottom",
        "both-inline",
        "both-block",
        "both",
        "none"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
clear_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof clear_export_parse(v) === "string";
};
clear_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("clear", clear_export_parse(v));
    },
    get () {
        return this.getPropertyValue("clear");
    },
    enumerable: true,
    configurable: true
};
var clip_export_parse, clip_export_isValid, clip_export_definition;
// deprecated
// @see https://drafts.fxtf.org/css-masking/#clip-property
clip_export_parse = function parse(v) {
    if (v === "") {
        return v;
    }
    const val = external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
    if (val) {
        return val;
    }
    // parse legacy <shape>
    v = v.toLowerCase();
    const matches = v.match(/^rect\(\s*(.*)\s*\)$/);
    if (!matches) {
        return;
    }
    const parts = matches[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
        return;
    }
    const valid = parts.every(function(part, index) {
        const measurement = external_dependency_parsers_0.parseMeasurement(part.trim());
        parts[index] = measurement;
        return typeof measurement === "string";
    });
    if (!valid) {
        return;
    }
    return `rect(${parts.join(", ")})`;
};
clip_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof clip_export_parse(v) === "string";
};
clip_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("clip", clip_export_parse(v));
    },
    get () {
        return this.getPropertyValue("clip");
    },
    enumerable: true,
    configurable: true
};
var color_export_parse, color_export_isValid, color_export_definition;
color_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
color_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
color_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("color", color_export_parse(v));
    },
    get () {
        return this.getPropertyValue("color");
    },
    enumerable: true,
    configurable: true
};
var flexGrow_export_parse, flexGrow_export_isValid, flexGrow_export_definition;
flexGrow_export_parse = function parse(v) {
    return external_dependency_parsers_0.parseNumber(v, true);
};
flexGrow_export_isValid = function isValid(v) {
    return typeof flexGrow_export_parse(v) === "string";
};
flexGrow_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("flex", "");
            this._setProperty("flex-grow", v);
        } else {
            this._setProperty("flex-grow", flexGrow_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("flex-grow");
    },
    enumerable: true,
    configurable: true
};
var flexShrink_export_parse, flexShrink_export_isValid, flexShrink_export_definition;
flexShrink_export_parse = function parse(v) {
    return external_dependency_parsers_0.parseNumber(v, true);
};
flexShrink_export_isValid = function isValid(v) {
    return typeof flexShrink_export_parse(v) === "string";
};
flexShrink_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("flex", "");
            this._setProperty("flex-shrink", v);
        } else {
            this._setProperty("flex-shrink", flexShrink_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("flex-shrink");
    },
    enumerable: true,
    configurable: true
};
var flexBasis_export_parse, flexBasis_export_isValid, flexBasis_export_definition;
flexBasis_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v);
    if (val) {
        return val;
    }
    const keywords = [
        "content",
        "auto",
        "min-content",
        "max-content"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
flexBasis_export_isValid = function isValid(v) {
    return typeof flexBasis_export_parse(v) === "string";
};
flexBasis_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("flex", "");
            this._setProperty("flex-basis", v);
        } else {
            this._setProperty("flex-basis", flexBasis_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("flex-basis");
    },
    enumerable: true,
    configurable: true
};
var flex_export_parse, flex_export_isValid, flex_export_definition;
const flex_local_var_shorthandFor = new Map([
    [
        "flex-grow",
        {
            parse: flexGrow_export_parse,
            isValid: flexGrow_export_isValid,
            definition: flexGrow_export_definition
        }
    ],
    [
        "flex-shrink",
        {
            parse: flexShrink_export_parse,
            isValid: flexShrink_export_isValid,
            definition: flexShrink_export_definition
        }
    ],
    [
        "flex-basis",
        {
            parse: flexBasis_export_parse,
            isValid: flexBasis_export_isValid,
            definition: flexBasis_export_definition
        }
    ]
]);
flex_export_parse = function parse(v) {
    const key = external_dependency_parsers_0.parseKeyword(v, [
        "auto",
        "none"
    ]);
    if (key) {
        if (key === "auto") {
            return "1 1 auto";
        }
        if (key === "none") {
            return "0 0 auto";
        }
        if (key === "initial") {
            return "0 1 auto";
        }
        return;
    }
    const obj = external_dependency_parsers_0.parseShorthand(v, flex_local_var_shorthandFor);
    if (obj) {
        const flex = {
            "flex-grow": "1",
            "flex-shrink": "1",
            "flex-basis": "0%"
        };
        const items = Object.entries(obj);
        for (const [property, value] of items){
            flex[property] = value;
        }
        return [
            ...Object.values(flex)
        ].join(" ");
    }
};
flex_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof flex_export_parse(v) === "string";
};
flex_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._shorthandSetter("flex", "", flex_local_var_shorthandFor);
            this._setProperty("flex", v);
        } else {
            this._shorthandSetter("flex", flex_export_parse(v), flex_local_var_shorthandFor);
        }
    },
    get () {
        let val = this.getPropertyValue("flex");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        val = this._shorthandGetter("flex", flex_local_var_shorthandFor);
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var float_export_parse, float_export_isValid, float_export_definition;
float_export_parse = function parse(v) {
    const keywords = [
        "left",
        "right",
        "none",
        "inline-start",
        "inline-end"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
float_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof float_export_parse(v) === "string";
};
float_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("float", float_export_parse(v));
    },
    get () {
        return this.getPropertyValue("float");
    },
    enumerable: true,
    configurable: true
};
var floodColor_export_parse, floodColor_export_isValid, floodColor_export_definition;
floodColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
floodColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
floodColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("flood-color", floodColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("flood-color");
    },
    enumerable: true,
    configurable: true
};
var fontStyle_export_parse, fontStyle_export_isValid, fontStyle_export_definition;
fontStyle_export_parse = function parse(v) {
    const keywords = [
        "normal",
        "italic",
        "oblique"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontStyle_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof fontStyle_export_parse(v) === "string";
};
fontStyle_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("font-style", v);
        } else {
            this._setProperty("font-style", fontStyle_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("font-style");
    },
    enumerable: true,
    configurable: true
};
var fontVariant_export_parse, fontVariant_export_isValid, fontVariant_export_definition;
fontVariant_export_parse = function parse(v) {
    const num = external_dependency_parsers_0.parseNumber(v, true);
    if (num && parseFloat(num) <= 1000) {
        return num;
    }
    const keywords = [
        "normal",
        "none",
        "small-caps"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontVariant_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof fontVariant_export_parse(v) === "string";
};
fontVariant_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("font-valiant", v);
        } else {
            this._setProperty("font-variant", fontVariant_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("font-variant");
    },
    enumerable: true,
    configurable: true
};
var fontWeight_export_parse, fontWeight_export_isValid, fontWeight_export_definition;
fontWeight_export_parse = function parse(v) {
    const num = external_dependency_parsers_0.parseNumber(v, true);
    if (num && parseFloat(num) <= 1000) {
        return num;
    }
    const keywords = [
        "normal",
        "bold",
        "lighter",
        "bolder"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontWeight_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof fontWeight_export_parse(v) === "string";
};
fontWeight_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("font-weight", v);
        } else {
            this._setProperty("font-weight", fontWeight_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("font-weight");
    },
    enumerable: true,
    configurable: true
};
var fontSize_export_parse, fontSize_export_isValid, fontSize_export_definition;
fontSize_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    const keywords = [
        "xx-small",
        "x-small",
        "small",
        "medium",
        "large",
        "x-large",
        "xx-large",
        "xxx-large",
        "smaller",
        "larger"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontSize_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof fontSize_export_parse(v) === "string";
};
fontSize_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("font-size", v);
        } else {
            this._setProperty("font-size", fontSize_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("font-size");
    },
    enumerable: true,
    configurable: true
};
var lineHeight_export_parse, lineHeight_export_isValid, lineHeight_export_definition;
lineHeight_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseKeyword(v, [
        "normal"
    ]);
    if (val) {
        return val;
    }
    const num = external_dependency_parsers_0.parseNumber(v, true);
    if (num) {
        return num;
    }
    return external_dependency_parsers_0.parseMeasurement(v, true);
};
lineHeight_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof lineHeight_export_parse(v) === "string";
};
lineHeight_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("line-height", v);
        } else {
            this._setProperty("line-height", lineHeight_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("line-height");
    },
    enumerable: true,
    configurable: true
};
var fontFamily_export_parse, fontFamily_export_isValid, fontFamily_export_definition;
fontFamily_export_parse = function parse(v) {
    if (v === "") {
        return v;
    }
    const keywords = [
        "serif",
        "sans-serif",
        "system-ui",
        "cursive",
        "fantasy",
        "monospace"
    ];
    const val = external_dependency_parsers_0.splitValue(v, {
        delimiter: ","
    });
    const font = [];
    let valid = false;
    for (const i of val){
        const str = external_dependency_parsers_0.parseString(i);
        if (str) {
            font.push(str);
            valid = true;
            continue;
        }
        const key = external_dependency_parsers_0.parseKeyword(i, keywords);
        if (key) {
            font.push(key);
            valid = true;
            continue;
        }
        // This implementation does not strictly follow the specification. The spec
        // does not require the first letter of the font-family to be capitalized.
        // Also, unquoted font-family names are not restricted to ASCII only.
        // However, in the real world, the first letter of the ASCII font-family
        // names are always capitalized, and unquoted font-family names do not
        // contain spaces, e.g. `Times`, and AFAIK, non-ASCII font-family names are
        // always quoted even without spaces, e.g. `""`.
        // Therefore, it is unlikely that this implementation will cause problems.
        // @see https://drafts.csswg.org/css-fonts/#font-family-prop
        if (/^\s*(?:[A-Z][A-Za-z\d\s-]+)\s*$/.test(i)) {
            font.push(i.trim());
            valid = true;
            continue;
        }
        if (!valid) {
            return;
        }
    }
    return font.join(", ");
};
fontFamily_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof fontFamily_export_parse(v) === "string";
};
fontFamily_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("font", "");
            this._setProperty("font-family", v);
        } else {
            this._setProperty("font-family", fontFamily_export_parse(v));
        }
    },
    get () {
        return this.getPropertyValue("font-family");
    },
    enumerable: true,
    configurable: true
};
var font_export_parse, font_export_definition;
const font_local_var_shorthandFor = new Map([
    [
        "font-style",
        {
            parse: fontStyle_export_parse,
            isValid: fontStyle_export_isValid,
            definition: fontStyle_export_definition
        }
    ],
    [
        "font-variant",
        {
            parse: fontVariant_export_parse,
            isValid: fontVariant_export_isValid,
            definition: fontVariant_export_definition
        }
    ],
    [
        "font-weight",
        {
            parse: fontWeight_export_parse,
            isValid: fontWeight_export_isValid,
            definition: fontWeight_export_definition
        }
    ],
    [
        "font-size",
        {
            parse: fontSize_export_parse,
            isValid: fontSize_export_isValid,
            definition: fontSize_export_definition
        }
    ],
    [
        "line-height",
        {
            parse: lineHeight_export_parse,
            isValid: lineHeight_export_isValid,
            definition: lineHeight_export_definition
        }
    ],
    [
        "font-family",
        {
            parse: fontFamily_export_parse,
            isValid: fontFamily_export_isValid,
            definition: fontFamily_export_definition
        }
    ]
]);
font_export_parse = function parse(v) {
    const keywords = [
        "caption",
        "icon",
        "menu",
        "message-box",
        "small-caption",
        "status-bar"
    ];
    const key = external_dependency_parsers_0.parseKeyword(v, keywords);
    if (key) {
        return key;
    }
    const [fontBlock, ...families] = external_dependency_parsers_0.splitValue(v, {
        delimiter: ","
    });
    let blockA, blockB;
    if (fontBlock.includes("/")) {
        [blockA, blockB] = external_dependency_parsers_0.splitValue(fontBlock, {
            delimiter: "/"
        });
    } else {
        blockA = fontBlock.trim();
    }
    const obj = external_dependency_parsers_0.parseShorthand(blockA, font_local_var_shorthandFor, true);
    if (!obj) {
        return;
    }
    const font = {};
    const fontFamilies = new Set();
    for (const [property, value] of Object.entries(obj)){
        if (property === "font-family") {
            if (!blockB) {
                fontFamilies.add(value);
            }
        } else {
            font[property] = value;
        }
    }
    // blockB, if matched, includes line-height and first font-family
    if (blockB) {
        const [lineheight, family] = external_dependency_parsers_0.splitValue(blockB);
        if (({
            parse: lineHeight_export_parse,
            isValid: lineHeight_export_isValid,
            definition: lineHeight_export_definition
        }).isValid(lineheight)) {
            font["line-height"] = ({
                parse: lineHeight_export_parse,
                isValid: lineHeight_export_isValid,
                definition: lineHeight_export_definition
            }).parse(lineheight);
        } else {
            return;
        }
        if (({
            parse: fontFamily_export_parse,
            isValid: fontFamily_export_isValid,
            definition: fontFamily_export_definition
        }).isValid(family)) {
            fontFamilies.add(({
                parse: fontFamily_export_parse,
                isValid: fontFamily_export_isValid,
                definition: fontFamily_export_definition
            }).parse(family));
        } else {
            return;
        }
    }
    for (const family of families){
        if (({
            parse: fontFamily_export_parse,
            isValid: fontFamily_export_isValid,
            definition: fontFamily_export_definition
        }).isValid(family)) {
            fontFamilies.add(({
                parse: fontFamily_export_parse,
                isValid: fontFamily_export_isValid,
                definition: fontFamily_export_definition
            }).parse(family));
        } else {
            return;
        }
    }
    font["font-family"] = [
        ...fontFamilies
    ].join(", ");
    return font;
};
font_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            for (const [key] of font_local_var_shorthandFor){
                this._setProperty(key, "");
            }
            this._setProperty("font", v);
        } else {
            const obj = font_export_parse(v);
            if (!obj) {
                return;
            }
            const str = new Set();
            for (const [key] of font_local_var_shorthandFor){
                const val = obj[key];
                if (typeof val === "string") {
                    this._setProperty(key, val);
                    if (val && !str.has(val)) {
                        if (key === "line-height") {
                            str.add(`/ ${val}`);
                        } else {
                            str.add(val);
                        }
                    }
                }
            }
            this._setProperty("font", [
                ...str
            ].join(" "));
        }
    },
    get () {
        const val = this.getPropertyValue("font");
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return val;
        }
        const str = new Set();
        for (const [key] of font_local_var_shorthandFor){
            const v = this.getPropertyValue(key);
            if (external_dependency_parsers_0.hasVarFunc(v)) {
                return "";
            }
            if (v && !str.has(v)) {
                if (key === "line-height") {
                    str.add(`/ ${v}`);
                } else {
                    str.add(`${v}`);
                }
            }
        }
        return [
            ...str
        ].join(" ");
    },
    enumerable: true,
    configurable: true
};
var height_export_parse, height_export_isValid, height_export_definition;
height_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v, true);
    if (dim) {
        return dim;
    }
    const keywords = [
        "auto",
        "min-content",
        "max-content",
        "fit-content"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
height_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof height_export_parse(v) === "string";
};
height_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("height", height_export_parse(v));
    },
    get () {
        return this.getPropertyValue("height");
    },
    enumerable: true,
    configurable: true
};
var left_export_parse, left_export_isValid, left_export_definition;
left_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v);
    if (dim) {
        return dim;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
left_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof left_export_parse(v) === "string";
};
left_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("left", left_export_parse(v));
    },
    get () {
        return this.getPropertyValue("left");
    },
    enumerable: true,
    configurable: true
};
var lightingColor_export_parse, lightingColor_export_isValid, lightingColor_export_definition;
lightingColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
lightingColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
lightingColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("lighting-color", lightingColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("lighting-color");
    },
    enumerable: true,
    configurable: true
};
var margin_export_parse, margin_export_isValid, margin_export_definition;
const margin_local_var_positions = [
    "top",
    "right",
    "bottom",
    "left"
];
margin_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
margin_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof margin_export_parse(v) === "string";
};
margin_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._implicitSetter("margin", "", "", margin_export_isValid, margin_export_parse, margin_local_var_positions);
            this._setProperty("margin", v);
        } else {
            this._implicitSetter("margin", "", v, margin_export_isValid, margin_export_parse, margin_local_var_positions);
        }
    },
    get () {
        const val = this._implicitGetter("margin", margin_local_var_positions);
        if (val === "") {
            return this.getPropertyValue("margin");
        }
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var marginBottom_export_parse, marginBottom_export_isValid, marginBottom_export_definition;
marginBottom_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
marginBottom_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof marginBottom_export_parse(v) === "string";
};
marginBottom_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("margin", "");
            this._setProperty("margin-bottom", v);
        } else {
            this._subImplicitSetter("margin", "bottom", v, marginBottom_export_isValid, marginBottom_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("margin-bottom");
    },
    enumerable: true,
    configurable: true
};
var marginLeft_export_parse, marginLeft_export_isValid, marginLeft_export_definition;
marginLeft_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
marginLeft_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof marginLeft_export_parse(v) === "string";
};
marginLeft_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("margin", "");
            this._setProperty("margin-left", v);
        } else {
            this._subImplicitSetter("margin", "left", v, marginLeft_export_isValid, marginLeft_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("margin-left");
    },
    enumerable: true,
    configurable: true
};
var marginRight_export_parse, marginRight_export_isValid, marginRight_export_definition;
marginRight_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
marginRight_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof marginRight_export_parse(v) === "string";
};
marginRight_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("margin", "");
            this._setProperty("margin-right", v);
        } else {
            this._subImplicitSetter("margin", "right", v, marginRight_export_isValid, marginRight_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("margin-right");
    },
    enumerable: true,
    configurable: true
};
var marginTop_export_parse, marginTop_export_isValid, marginTop_export_definition;
marginTop_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
marginTop_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof marginTop_export_parse(v) === "string";
};
marginTop_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("margin", "");
            this._setProperty("margin-top", v);
        } else {
            this._subImplicitSetter("margin", "top", v, marginTop_export_isValid, marginTop_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("margin-top");
    },
    enumerable: true,
    configurable: true
};
var opacity_export_parse, opacity_export_isValid, opacity_export_definition;
opacity_export_parse = function parse(v) {
    let num = external_dependency_parsers_0.parseNumber(v);
    if (num) {
        num = parseFloat(num);
        if (num < 0) {
            return "0";
        } else if (num > 1) {
            return "1";
        }
        return `${num}`;
    }
    let pct = external_dependency_parsers_0.parsePercent(v);
    if (pct) {
        pct = parseFloat(pct);
        if (pct < 0) {
            return "0%";
        } else if (pct > 100) {
            return "100%";
        }
        return `${pct}%`;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
opacity_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof opacity_export_parse(v) === "string";
};
opacity_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("opacity", opacity_export_parse(v));
    },
    get () {
        return this.getPropertyValue("opacity");
    },
    enumerable: true,
    configurable: true
};
var outlineColor_export_parse, outlineColor_export_isValid, outlineColor_export_definition;
outlineColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
outlineColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
outlineColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("outline-color", outlineColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("outline-color");
    },
    enumerable: true,
    configurable: true
};
var padding_export_parse, padding_export_isValid, padding_export_definition;
const padding_local_var_positions = [
    "top",
    "right",
    "bottom",
    "left"
];
padding_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
padding_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof padding_export_parse(v) === "string";
};
padding_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._implicitSetter("padding", "", "", padding_export_isValid, padding_export_parse, padding_local_var_positions);
            this._setProperty("padding", v);
        } else {
            this._implicitSetter("padding", "", v, padding_export_isValid, padding_export_parse, padding_local_var_positions);
        }
    },
    get () {
        const val = this._implicitGetter("padding", padding_local_var_positions);
        if (val === "") {
            return this.getPropertyValue("padding");
        }
        if (external_dependency_parsers_0.hasVarFunc(val)) {
            return "";
        }
        return val;
    },
    enumerable: true,
    configurable: true
};
var paddingBottom_export_parse, paddingBottom_export_isValid, paddingBottom_export_definition;
paddingBottom_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
paddingBottom_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof paddingBottom_export_parse(v) === "string";
};
paddingBottom_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("padding", "");
            this._setProperty("padding-bottom", v);
        } else {
            this._subImplicitSetter("padding", "bottom", v, paddingBottom_export_isValid, paddingBottom_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("padding-bottom");
    },
    enumerable: true,
    configurable: true
};
var paddingLeft_export_parse, paddingLeft_export_isValid, paddingLeft_export_definition;
paddingLeft_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
paddingLeft_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof paddingLeft_export_parse(v) === "string";
};
paddingLeft_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("padding", "");
            this._setProperty("padding-left", v);
        } else {
            this._subImplicitSetter("padding", "left", v, paddingLeft_export_isValid, paddingLeft_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("padding-left");
    },
    enumerable: true,
    configurable: true
};
var paddingRight_export_parse, paddingRight_export_isValid, paddingRight_export_definition;
paddingRight_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
paddingRight_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof paddingRight_export_parse(v) === "string";
};
paddingRight_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("padding", "");
            this._setProperty("padding-right", v);
        } else {
            this._subImplicitSetter("padding", "right", v, paddingRight_export_isValid, paddingRight_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("padding-right");
    },
    enumerable: true,
    configurable: true
};
var paddingTop_export_parse, paddingTop_export_isValid, paddingTop_export_definition;
paddingTop_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseMeasurement(v, true);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
paddingTop_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof paddingTop_export_parse(v) === "string";
};
paddingTop_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        if (external_dependency_parsers_0.hasVarFunc(v)) {
            this._setProperty("padding", "");
            this._setProperty("padding-top", v);
        } else {
            this._subImplicitSetter("padding", "top", v, paddingTop_export_isValid, paddingTop_export_parse, [
                "top",
                "right",
                "bottom",
                "left"
            ]);
        }
    },
    get () {
        return this.getPropertyValue("padding-top");
    },
    enumerable: true,
    configurable: true
};
var right_export_parse, right_export_isValid, right_export_definition;
right_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v);
    if (dim) {
        return dim;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
right_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof right_export_parse(v) === "string";
};
right_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("right", right_export_parse(v));
    },
    get () {
        return this.getPropertyValue("right");
    },
    enumerable: true,
    configurable: true
};
var stopColor_export_parse, stopColor_export_isValid, stopColor_export_definition;
stopColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
stopColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
stopColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("stop-color", stopColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("stop-color");
    },
    enumerable: true,
    configurable: true
};
var top_export_parse, top_export_isValid, top_export_definition;
top_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v);
    if (dim) {
        return dim;
    }
    return external_dependency_parsers_0.parseKeyword(v, [
        "auto"
    ]);
};
top_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof top_export_parse(v) === "string";
};
top_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("top", top_export_parse(v));
    },
    get () {
        return this.getPropertyValue("top");
    },
    enumerable: true,
    configurable: true
};
var webkitBorderAfterColor_export_parse, webkitBorderAfterColor_export_isValid, webkitBorderAfterColor_export_definition;
webkitBorderAfterColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderAfterColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderAfterColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-border-after-color", webkitBorderAfterColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-border-after-color");
    },
    enumerable: true,
    configurable: true
};
var webkitBorderBeforeColor_export_parse, webkitBorderBeforeColor_export_isValid, webkitBorderBeforeColor_export_definition;
webkitBorderBeforeColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderBeforeColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderBeforeColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-border-before-color", webkitBorderBeforeColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-border-before-color");
    },
    enumerable: true,
    configurable: true
};
var webkitBorderEndColor_export_parse, webkitBorderEndColor_export_isValid, webkitBorderEndColor_export_definition;
webkitBorderEndColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderEndColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderEndColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-border-end-color", webkitBorderEndColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-border-end-color");
    },
    enumerable: true,
    configurable: true
};
var webkitBorderStartColor_export_parse, webkitBorderStartColor_export_isValid, webkitBorderStartColor_export_definition;
webkitBorderStartColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderStartColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderStartColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-border-start-color", webkitBorderStartColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-border-start-color");
    },
    enumerable: true,
    configurable: true
};
var webkitColumnRuleColor_export_parse, webkitColumnRuleColor_export_isValid, webkitColumnRuleColor_export_definition;
webkitColumnRuleColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitColumnRuleColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitColumnRuleColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-column-rule-color", webkitColumnRuleColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-column-rule-color");
    },
    enumerable: true,
    configurable: true
};
var webkitTapHighlightColor_export_parse, webkitTapHighlightColor_export_isValid, webkitTapHighlightColor_export_definition;
webkitTapHighlightColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitTapHighlightColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitTapHighlightColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-tap-highlight-color", webkitTapHighlightColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-tap-highlight-color");
    },
    enumerable: true,
    configurable: true
};
var webkitTextEmphasisColor_export_parse, webkitTextEmphasisColor_export_isValid, webkitTextEmphasisColor_export_definition;
webkitTextEmphasisColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextEmphasisColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitTextEmphasisColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-text-emphasis-color", webkitTextEmphasisColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-text-emphasis-color");
    },
    enumerable: true,
    configurable: true
};
var webkitTextFillColor_export_parse, webkitTextFillColor_export_isValid, webkitTextFillColor_export_definition;
webkitTextFillColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextFillColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitTextFillColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-text-fill-color", webkitTextFillColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-text-fill-color");
    },
    enumerable: true,
    configurable: true
};
var webkitTextStrokeColor_export_parse, webkitTextStrokeColor_export_isValid, webkitTextStrokeColor_export_definition;
webkitTextStrokeColor_export_parse = function parse(v) {
    const val = external_dependency_parsers_0.parseColor(v);
    if (val) {
        return val;
    }
    return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextStrokeColor_export_isValid = function isValid(v) {
    if (v === "" || typeof external_dependency_parsers_0.parseKeyword(v) === "string") {
        return true;
    }
    return external_dependency_parsers_0.isValidColor(v);
};
webkitTextStrokeColor_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("-webkit-text-stroke-color", webkitTextStrokeColor_export_parse(v));
    },
    get () {
        return this.getPropertyValue("-webkit-text-stroke-color");
    },
    enumerable: true,
    configurable: true
};
var width_export_parse, width_export_isValid, width_export_definition;
width_export_parse = function parse(v) {
    const dim = external_dependency_parsers_0.parseMeasurement(v, true);
    if (dim) {
        return dim;
    }
    const keywords = [
        "auto",
        "min-content",
        "max-content",
        "fit-content"
    ];
    return external_dependency_parsers_0.parseKeyword(v, keywords);
};
width_export_isValid = function isValid(v) {
    if (v === "") {
        return true;
    }
    return typeof width_export_parse(v) === "string";
};
width_export_definition = {
    set (v) {
        v = external_dependency_parsers_0.prepareValue(v, this._global);
        this._setProperty("width", width_export_parse(v));
    },
    get () {
        return this.getPropertyValue("width");
    },
    enumerable: true,
    configurable: true
};
module.exports = {
    backgroundImage: backgroundImage_export_definition,
    "background-image": backgroundImage_export_definition,
    backgroundPosition: backgroundPosition_export_definition,
    "background-position": backgroundPosition_export_definition,
    backgroundRepeat: backgroundRepeat_export_definition,
    "background-repeat": backgroundRepeat_export_definition,
    backgroundAttachment: backgroundAttachment_export_definition,
    "background-attachment": backgroundAttachment_export_definition,
    backgroundColor: backgroundColor_export_definition,
    "background-color": backgroundColor_export_definition,
    background: background_export_definition,
    borderWidth: borderWidth_export_definition,
    "border-width": borderWidth_export_definition,
    borderStyle: borderStyle_export_definition,
    "border-style": borderStyle_export_definition,
    borderColor: borderColor_export_definition,
    "border-color": borderColor_export_definition,
    border: border_export_definition,
    borderTopWidth: borderTopWidth_export_definition,
    "border-top-width": borderTopWidth_export_definition,
    borderTopStyle: borderTopStyle_export_definition,
    "border-top-style": borderTopStyle_export_definition,
    borderTopColor: borderTopColor_export_definition,
    "border-top-color": borderTopColor_export_definition,
    borderBottom: borderBottom_export_definition,
    "border-bottom": borderBottom_export_definition,
    borderBottomColor: borderBottomColor_export_definition,
    "border-bottom-color": borderBottomColor_export_definition,
    borderBottomStyle: borderBottomStyle_export_definition,
    "border-bottom-style": borderBottomStyle_export_definition,
    borderBottomWidth: borderBottomWidth_export_definition,
    "border-bottom-width": borderBottomWidth_export_definition,
    borderCollapse: borderCollapse_export_definition,
    "border-collapse": borderCollapse_export_definition,
    borderLeft: borderLeft_export_definition,
    "border-left": borderLeft_export_definition,
    borderLeftColor: borderLeftColor_export_definition,
    "border-left-color": borderLeftColor_export_definition,
    borderLeftStyle: borderLeftStyle_export_definition,
    "border-left-style": borderLeftStyle_export_definition,
    borderLeftWidth: borderLeftWidth_export_definition,
    "border-left-width": borderLeftWidth_export_definition,
    borderRight: borderRight_export_definition,
    "border-right": borderRight_export_definition,
    borderRightColor: borderRightColor_export_definition,
    "border-right-color": borderRightColor_export_definition,
    borderRightStyle: borderRightStyle_export_definition,
    "border-right-style": borderRightStyle_export_definition,
    borderRightWidth: borderRightWidth_export_definition,
    "border-right-width": borderRightWidth_export_definition,
    borderSpacing: borderSpacing_export_definition,
    "border-spacing": borderSpacing_export_definition,
    borderTop: borderTop_export_definition,
    "border-top": borderTop_export_definition,
    bottom: bottom_export_definition,
    clear: clear_export_definition,
    clip: clip_export_definition,
    color: color_export_definition,
    flexGrow: flexGrow_export_definition,
    "flex-grow": flexGrow_export_definition,
    flexShrink: flexShrink_export_definition,
    "flex-shrink": flexShrink_export_definition,
    flexBasis: flexBasis_export_definition,
    "flex-basis": flexBasis_export_definition,
    flex: flex_export_definition,
    float: float_export_definition,
    floodColor: floodColor_export_definition,
    "flood-color": floodColor_export_definition,
    fontStyle: fontStyle_export_definition,
    "font-style": fontStyle_export_definition,
    fontVariant: fontVariant_export_definition,
    "font-variant": fontVariant_export_definition,
    fontWeight: fontWeight_export_definition,
    "font-weight": fontWeight_export_definition,
    fontSize: fontSize_export_definition,
    "font-size": fontSize_export_definition,
    lineHeight: lineHeight_export_definition,
    "line-height": lineHeight_export_definition,
    fontFamily: fontFamily_export_definition,
    "font-family": fontFamily_export_definition,
    font: font_export_definition,
    height: height_export_definition,
    left: left_export_definition,
    lightingColor: lightingColor_export_definition,
    "lighting-color": lightingColor_export_definition,
    margin: margin_export_definition,
    marginBottom: marginBottom_export_definition,
    "margin-bottom": marginBottom_export_definition,
    marginLeft: marginLeft_export_definition,
    "margin-left": marginLeft_export_definition,
    marginRight: marginRight_export_definition,
    "margin-right": marginRight_export_definition,
    marginTop: marginTop_export_definition,
    "margin-top": marginTop_export_definition,
    opacity: opacity_export_definition,
    outlineColor: outlineColor_export_definition,
    "outline-color": outlineColor_export_definition,
    padding: padding_export_definition,
    paddingBottom: paddingBottom_export_definition,
    "padding-bottom": paddingBottom_export_definition,
    paddingLeft: paddingLeft_export_definition,
    "padding-left": paddingLeft_export_definition,
    paddingRight: paddingRight_export_definition,
    "padding-right": paddingRight_export_definition,
    paddingTop: paddingTop_export_definition,
    "padding-top": paddingTop_export_definition,
    right: right_export_definition,
    stopColor: stopColor_export_definition,
    "stop-color": stopColor_export_definition,
    top: top_export_definition,
    webkitBorderAfterColor: webkitBorderAfterColor_export_definition,
    "-webkit-border-after-color": webkitBorderAfterColor_export_definition,
    "WebkitBorderAfterColor": webkitBorderAfterColor_export_definition,
    webkitBorderBeforeColor: webkitBorderBeforeColor_export_definition,
    "-webkit-border-before-color": webkitBorderBeforeColor_export_definition,
    "WebkitBorderBeforeColor": webkitBorderBeforeColor_export_definition,
    webkitBorderEndColor: webkitBorderEndColor_export_definition,
    "-webkit-border-end-color": webkitBorderEndColor_export_definition,
    "WebkitBorderEndColor": webkitBorderEndColor_export_definition,
    webkitBorderStartColor: webkitBorderStartColor_export_definition,
    "-webkit-border-start-color": webkitBorderStartColor_export_definition,
    "WebkitBorderStartColor": webkitBorderStartColor_export_definition,
    webkitColumnRuleColor: webkitColumnRuleColor_export_definition,
    "-webkit-column-rule-color": webkitColumnRuleColor_export_definition,
    "WebkitColumnRuleColor": webkitColumnRuleColor_export_definition,
    webkitTapHighlightColor: webkitTapHighlightColor_export_definition,
    "-webkit-tap-highlight-color": webkitTapHighlightColor_export_definition,
    "WebkitTapHighlightColor": webkitTapHighlightColor_export_definition,
    webkitTextEmphasisColor: webkitTextEmphasisColor_export_definition,
    "-webkit-text-emphasis-color": webkitTextEmphasisColor_export_definition,
    "WebkitTextEmphasisColor": webkitTextEmphasisColor_export_definition,
    webkitTextFillColor: webkitTextFillColor_export_definition,
    "-webkit-text-fill-color": webkitTextFillColor_export_definition,
    "WebkitTextFillColor": webkitTextFillColor_export_definition,
    webkitTextStrokeColor: webkitTextStrokeColor_export_definition,
    "-webkit-text-stroke-color": webkitTextStrokeColor_export_definition,
    "WebkitTextStrokeColor": webkitTextStrokeColor_export_definition,
    width: width_export_definition
};
}}),
"[project]/node_modules/cssstyle/lib/utils/camelize.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Utility to translate from `border-width` to `borderWidth`.
// NOTE: For values prefixed with webkit, e.g. `-webkit-foo`, we need to provide
// both `webkitFoo` and `WebkitFoo`. Here we only return `webkitFoo`.
exports.dashedToCamelCase = function(dashed) {
    if (dashed.startsWith("--")) {
        return dashed;
    }
    let camel = "";
    let nextCap = false;
    // skip leading hyphen in vendor prefixed value, e.g. -webkit-foo
    let i = /^-webkit-/.test(dashed) ? 1 : 0;
    for(; i < dashed.length; i++){
        if (dashed[i] !== "-") {
            camel += nextCap ? dashed[i].toUpperCase() : dashed[i];
            nextCap = false;
        } else {
            nextCap = true;
        }
    }
    return camel;
};
// Utility to translate from `borderWidth` to `border-width`.
exports.camelCaseToDashed = function(camelCase) {
    if (camelCase.startsWith("--")) {
        return camelCase;
    }
    const dashed = camelCase.replace(/(?<=[a-z])[A-Z]/g, "-$&").toLowerCase();
    if (/^webkit-/.test(dashed)) {
        return `-${dashed}`;
    }
    return dashed;
};
}}),
"[project]/node_modules/cssstyle/lib/utils/propertyDescriptors.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const prepareValue = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/parsers.js [middleware-edge] (ecmascript)").prepareValue;
module.exports.getPropertyDescriptor = function getPropertyDescriptor(property) {
    return {
        set (v) {
            this._setProperty(property, prepareValue(v));
        },
        get () {
            return this.getPropertyValue(property);
        },
        enumerable: true,
        configurable: true
    };
};
}}),
"[project]/node_modules/cssstyle/lib/CSSStyleDeclaration.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is a fork from the CSS Style Declaration part of
 * https://github.com/NV/CSSOM
 */ "use strict";
const CSSOM = __turbopack_context__.r("[project]/node_modules/rrweb-cssom/lib/index.js [middleware-edge] (ecmascript)");
const allExtraProperties = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/allExtraProperties.js [middleware-edge] (ecmascript)");
const allProperties = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/generated/allProperties.js [middleware-edge] (ecmascript)");
const implementedProperties = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/generated/implementedProperties.js [middleware-edge] (ecmascript)");
const generatedProperties = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/generated/properties.js [middleware-edge] (ecmascript)");
const { hasVarFunc, parseKeyword, parseShorthand, prepareValue, splitValue } = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/parsers.js [middleware-edge] (ecmascript)");
const { dashedToCamelCase } = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/utils/camelize.js [middleware-edge] (ecmascript)");
const { getPropertyDescriptor } = __turbopack_context__.r("[project]/node_modules/cssstyle/lib/utils/propertyDescriptors.js [middleware-edge] (ecmascript)");
/**
 * @see https://drafts.csswg.org/cssom/#the-cssstyledeclaration-interface
 */ class CSSStyleDeclaration {
    /**
   * @param {Function} onChangeCallback
   * @param {object} [opt]
   * @param {object} [opt.context] - Window, Element or CSSRule.
   */ constructor(onChangeCallback, opt = {}){
        // Make constructor and internals non-enumerable.
        Object.defineProperties(this, {
            constructor: {
                enumerable: false,
                writable: true
            },
            // Window
            _global: {
                value: globalThis,
                enumerable: false,
                writable: true
            },
            // Element
            _ownerNode: {
                value: null,
                enumerable: false,
                writable: true
            },
            // CSSRule
            _parentNode: {
                value: null,
                enumerable: false,
                writable: true
            },
            _onChange: {
                value: null,
                enumerable: false,
                writable: true
            },
            _values: {
                value: new Map(),
                enumerable: false,
                writable: true
            },
            _priorities: {
                value: new Map(),
                enumerable: false,
                writable: true
            },
            _length: {
                value: 0,
                enumerable: false,
                writable: true
            },
            _computed: {
                value: false,
                enumerable: false,
                writable: true
            },
            _readonly: {
                value: false,
                enumerable: false,
                writable: true
            },
            _setInProgress: {
                value: false,
                enumerable: false,
                writable: true
            }
        });
        const { context } = opt;
        if (context) {
            if (typeof context.getComputedStyle === "function") {
                this._global = context;
                this._computed = true;
                this._readonly = true;
            } else if (context.nodeType === 1 && Object.hasOwn(context, "style")) {
                this._global = context.ownerDocument.defaultView;
                this._ownerNode = context;
            } else if (Object.hasOwn(context, "parentRule")) {
                this._parentRule = context;
                // Find Window from the owner node of the StyleSheet.
                const window = context?.parentStyleSheet?.ownerNode?.ownerDocument?.defaultView;
                if (window) {
                    this._global = window;
                }
            }
        }
        if (typeof onChangeCallback === "function") {
            this._onChange = onChangeCallback;
        }
    }
    get cssText() {
        if (this._computed) {
            return "";
        }
        const properties = [];
        for(let i = 0; i < this._length; i++){
            const property = this[i];
            const value = this.getPropertyValue(property);
            const priority = this.getPropertyPriority(property);
            if (priority === "important") {
                properties.push(`${property}: ${value} !${priority};`);
            } else {
                properties.push(`${property}: ${value};`);
            }
        }
        return properties.join(" ");
    }
    set cssText(value) {
        if (this._readonly) {
            const msg = "cssText can not be modified.";
            const name = "NoModificationAllowedError";
            throw new this._global.DOMException(msg, name);
        }
        Array.prototype.splice.call(this, 0, this._length);
        this._values.clear();
        this._priorities.clear();
        if (this._parentRule || this._ownerNode && this._setInProgress) {
            return;
        }
        this._setInProgress = true;
        let dummyRule;
        try {
            dummyRule = CSSOM.parse(`#bogus{${value}}`).cssRules[0].style;
        } catch  {
            // Malformed css, just return.
            return;
        }
        for(let i = 0; i < dummyRule.length; i++){
            const property = dummyRule[i];
            this.setProperty(property, dummyRule.getPropertyValue(property), dummyRule.getPropertyPriority(property));
        }
        this._setInProgress = false;
        if (typeof this._onChange === "function") {
            this._onChange(this.cssText);
        }
    }
    get length() {
        return this._length;
    }
    // This deletes indices if the new length is less then the current length.
    // If the new length is more, it does nothing, the new indices will be
    // undefined until set.
    set length(len) {
        for(let i = len; i < this._length; i++){
            delete this[i];
        }
        this._length = len;
    }
    // Readonly
    get parentRule() {
        return this._parentRule;
    }
    get cssFloat() {
        return this.getPropertyValue("float");
    }
    set cssFloat(value) {
        this._setProperty("float", value);
    }
    /**
   * @param {string} property
   */ getPropertyPriority(property) {
        return this._priorities.get(property) || "";
    }
    /**
   * @param {string} property
   */ getPropertyValue(property) {
        if (this._values.has(property)) {
            return this._values.get(property).toString();
        }
        return "";
    }
    /**
   * @param {...number} args
   */ item(...args) {
        if (!args.length) {
            const msg = "1 argument required, but only 0 present.";
            throw new this._global.TypeError(msg);
        }
        let [index] = args;
        index = parseInt(index);
        if (Number.isNaN(index) || index < 0 || index >= this._length) {
            return "";
        }
        return this[index];
    }
    /**
   * @param {string} property
   */ removeProperty(property) {
        if (this._readonly) {
            const msg = `Property ${property} can not be modified.`;
            const name = "NoModificationAllowedError";
            throw new this._global.DOMException(msg, name);
        }
        if (!this._values.has(property)) {
            return "";
        }
        const prevValue = this._values.get(property);
        this._values.delete(property);
        this._priorities.delete(property);
        const index = Array.prototype.indexOf.call(this, property);
        if (index >= 0) {
            Array.prototype.splice.call(this, index, 1);
            if (typeof this._onChange === "function") {
                this._onChange(this.cssText);
            }
        }
        return prevValue;
    }
    /**
   * @param {string} property
   * @param {string} value
   * @param {string?} [priority] - "important" or null
   */ setProperty(property, value, priority = null) {
        if (this._readonly) {
            const msg = `Property ${property} can not be modified.`;
            const name = "NoModificationAllowedError";
            throw new this._global.DOMException(msg, name);
        }
        value = prepareValue(value, this._global);
        if (value === "") {
            this[property] = "";
            this.removeProperty(property);
            return;
        }
        const isCustomProperty = property.startsWith("--");
        if (isCustomProperty) {
            this._setProperty(property, value);
            return;
        }
        property = property.toLowerCase();
        if (!allProperties.has(property) && !allExtraProperties.has(property)) {
            return;
        }
        this[property] = value;
        if (priority) {
            this._priorities.set(property, priority);
        } else {
            this._priorities.delete(property);
        }
    }
}
// Internal methods
Object.defineProperties(CSSStyleDeclaration.prototype, {
    _shorthandGetter: {
        /**
     * @param {string} property
     * @param {object} shorthandFor
     */ value (property, shorthandFor) {
            const parts = [];
            for (const key of shorthandFor.keys()){
                const val = this.getPropertyValue(key);
                if (hasVarFunc(val)) {
                    return "";
                }
                if (val !== "") {
                    parts.push(val);
                }
            }
            if (parts.length) {
                return parts.join(" ");
            }
            if (this._values.has(property)) {
                return this.getPropertyValue(property);
            }
            return "";
        },
        enumerable: false
    },
    _implicitGetter: {
        /**
     * @param {string} property
     * @param {Array.<string>} positions
     */ value (property, positions = []) {
            const parts = [];
            for (const position of positions){
                const val = this.getPropertyValue(`${property}-${position}`);
                if (val === "" || hasVarFunc(val)) {
                    return "";
                }
                parts.push(val);
            }
            if (!parts.length) {
                return "";
            }
            switch(positions.length){
                case 4:
                    {
                        const [top, right, bottom, left] = parts;
                        if (top === right && top === bottom && right === left) {
                            return top;
                        }
                        if (top !== right && top === bottom && right === left) {
                            return `${top} ${right}`;
                        }
                        if (top !== right && top !== bottom && right === left) {
                            return `${top} ${right} ${bottom}`;
                        }
                        return `${top} ${right} ${bottom} ${left}`;
                    }
                case 2:
                    {
                        const [x, y] = parts;
                        if (x === y) {
                            return x;
                        }
                        return `${x} ${y}`;
                    }
                default:
                    return "";
            }
        },
        enumerable: false
    },
    _setProperty: {
        /**
     * @param {string} property
     * @param {string} val
     * @param {string?} [priority]
     */ value (property, val, priority = null) {
            if (typeof val !== "string") {
                return;
            }
            if (val === "") {
                this.removeProperty(property);
                return;
            }
            let originalText = "";
            if (typeof this._onChange === "function") {
                originalText = this.cssText;
            }
            if (this._values.has(property)) {
                const index = Array.prototype.indexOf.call(this, property);
                // The property already exists but is not indexed into `this` so add it.
                if (index < 0) {
                    this[this._length] = property;
                    this._length++;
                }
            } else {
                // New property.
                this[this._length] = property;
                this._length++;
            }
            this._values.set(property, val);
            if (priority) {
                this._priorities.set(property, priority);
            } else {
                this._priorities.delete(property);
            }
            if (typeof this._onChange === "function" && this.cssText !== originalText && !this._setInProgress) {
                this._onChange(this.cssText);
            }
        },
        enumerable: false
    },
    _shorthandSetter: {
        /**
     * @param {string} property
     * @param {string} val
     * @param {object} shorthandFor
     */ value (property, val, shorthandFor) {
            val = prepareValue(val, this._global);
            const obj = parseShorthand(val, shorthandFor);
            if (!obj) {
                return;
            }
            for (const subprop of Object.keys(obj)){
                // In case subprop is an implicit property, this will clear *its*
                // subpropertiesX.
                const camel = dashedToCamelCase(subprop);
                this[camel] = obj[subprop];
                // In case it gets translated into something else (0 -> 0px).
                obj[subprop] = this[camel];
                this.removeProperty(subprop);
                // Don't add in empty properties.
                if (obj[subprop] !== "") {
                    this._values.set(subprop, obj[subprop]);
                }
            }
            for (const [subprop] of shorthandFor){
                if (!Object.hasOwn(obj, subprop)) {
                    this.removeProperty(subprop);
                    this._values.delete(subprop);
                }
            }
            // In case the value is something like 'none' that removes all values,
            // check that the generated one is not empty, first remove the property,
            // if it already exists, then call the shorthandGetter, if it's an empty
            // string, don't set the property.
            this.removeProperty(property);
            const calculated = this._shorthandGetter(property, shorthandFor);
            if (calculated !== "") {
                this._setProperty(property, calculated);
            }
            return obj;
        },
        enumerable: false
    },
    // Companion to shorthandSetter, but for the individual parts which takes
    // position value in the middle.
    _midShorthandSetter: {
        /**
     * @param {string} property
     * @param {string} val
     * @param {object} shorthandFor
     * @param {Array.<string>} positions
     */ value (property, val, shorthandFor, positions = []) {
            val = prepareValue(val, this._global);
            const obj = this._shorthandSetter(property, val, shorthandFor);
            if (!obj) {
                return;
            }
            for (const position of positions){
                this.removeProperty(`${property}-${position}`);
                this._values.set(`${property}-${position}`, val);
            }
        },
        enumerable: false
    },
    _implicitSetter: {
        /**
     * @param {string} prefix
     * @param {string} part
     * @param {string} val
     * @param {Function} isValid
     * @param {Function} parser
     * @param {Array.<string>} positions
     */ value (prefix, part, val, isValid, parser, positions = []) {
            val = prepareValue(val, this._global);
            if (typeof val !== "string") {
                return;
            }
            part ||= "";
            if (part) {
                part = `-${part}`;
            }
            let parts = [];
            if (val === "") {
                parts.push(val);
            } else {
                const key = parseKeyword(val);
                if (key) {
                    parts.push(key);
                } else {
                    parts.push(...splitValue(val));
                }
            }
            if (!parts.length || parts.length > positions.length || !parts.every(isValid)) {
                return;
            }
            parts = parts.map((p)=>parser(p));
            this._setProperty(`${prefix}${part}`, parts.join(" "));
            switch(positions.length){
                case 4:
                    if (parts.length === 1) {
                        parts.push(parts[0], parts[0], parts[0]);
                    } else if (parts.length === 2) {
                        parts.push(parts[0], parts[1]);
                    } else if (parts.length === 3) {
                        parts.push(parts[1]);
                    }
                    break;
                case 2:
                    if (parts.length === 1) {
                        parts.push(parts[0]);
                    }
                    break;
                default:
            }
            for(let i = 0; i < positions.length; i++){
                const property = `${prefix}-${positions[i]}${part}`;
                this.removeProperty(property);
                this._values.set(property, parts[i]);
            }
        },
        enumerable: false
    },
    // Companion to implicitSetter, but for the individual parts.
    // This sets the individual value, and checks to see if all sub-parts are
    // set. If so, it sets the shorthand version and removes the individual parts
    // from the cssText.
    _subImplicitSetter: {
        /**
     * @param {string} prefix
     * @param {string} part
     * @param {string} val
     * @param {Function} isValid
     * @param {Function} parser
     * @param {Array.<string>} positions
     */ value (prefix, part, val, isValid, parser, positions = []) {
            val = prepareValue(val, this._global);
            if (typeof val !== "string" || !isValid(val)) {
                return;
            }
            val = parser(val);
            const property = `${prefix}-${part}`;
            this._setProperty(property, val);
            const combinedPriority = this.getPropertyPriority(prefix);
            const subparts = [];
            for (const position of positions){
                subparts.push(`${prefix}-${position}`);
            }
            const parts = subparts.map((subpart)=>this._values.get(subpart));
            const priorities = subparts.map((subpart)=>this.getPropertyPriority(subpart));
            const [priority] = priorities;
            // Combine into a single property if all values are set and have the same
            // priority.
            if (priority === combinedPriority && parts.every((p)=>p) && priorities.every((p)=>p === priority)) {
                for(let i = 0; i < subparts.length; i++){
                    this.removeProperty(subparts[i]);
                    this._values.set(subparts[i], parts[i]);
                }
                this._setProperty(prefix, parts.join(" "), priority);
            } else {
                this.removeProperty(prefix);
                for(let i = 0; i < subparts.length; i++){
                    // The property we're setting won't be important, the rest will either
                    // keep their priority or inherit it from the combined property
                    const subPriority = subparts[i] === property ? "" : priorities[i] || combinedPriority;
                    this._setProperty(subparts[i], parts[i], subPriority);
                }
            }
        },
        enumerable: false
    }
});
// Properties
Object.defineProperties(CSSStyleDeclaration.prototype, generatedProperties);
// Additional properties
[
    ...allProperties,
    ...allExtraProperties
].forEach(function(property) {
    if (!implementedProperties.has(property)) {
        const declaration = getPropertyDescriptor(property);
        Object.defineProperty(CSSStyleDeclaration.prototype, property, declaration);
        const camel = dashedToCamelCase(property);
        Object.defineProperty(CSSStyleDeclaration.prototype, camel, declaration);
        if (/^webkit[A-Z]/.test(camel)) {
            const pascal = camel.replace(/^webkit/, "Webkit");
            Object.defineProperty(CSSStyleDeclaration.prototype, pascal, declaration);
        }
    }
});
exports.CSSStyleDeclaration = CSSStyleDeclaration;
}}),
}]);

//# sourceMappingURL=node_modules_cssstyle_lib_37332f39._.js.map