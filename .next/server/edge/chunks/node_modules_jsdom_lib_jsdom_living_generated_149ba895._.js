(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/node_modules_jsdom_lib_jsdom_living_generated_149ba895._.js", {

"[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Returns "Type(value) is Object" in ES terminology.
function isObject(value) {
    return typeof value === "object" && value !== null || typeof value === "function";
}
const hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
// Like `Object.assign`, but using `[[GetOwnProperty]]` and `[[DefineOwnProperty]]`
// instead of `[[Get]]` and `[[Set]]` and only allowing objects
function define(target, source) {
    for (const key of Reflect.ownKeys(source)){
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
            throw new TypeError(`Cannot redefine property: ${String(key)}`);
        }
    }
}
function newObjectInRealm(globalObject, object) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object));
}
const wrapperSymbol = Symbol("wrapper");
const implSymbol = Symbol("impl");
const sameObjectCaches = Symbol("SameObject caches");
const ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function initCtorRegistry(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
        return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = Object.create(null);
    // In addition to registering all the WebIDL2JS-generated types in the constructor registry,
    // we also register a few intrinsics that we make use of in generated code, since they are not
    // easy to grab from the globalObject variable.
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));
    try {
        ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
    } catch  {
        ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
}
function getSameObject(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
}
function wrapperForImpl(impl) {
    return impl ? impl[wrapperSymbol] : null;
}
function implForWrapper(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
}
function tryWrapperForImpl(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
}
function tryImplForWrapper(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
}
const iterInternalSymbol = Symbol("internal");
function isArrayIndexPropName(P) {
    if (typeof P !== "string") {
        return false;
    }
    const i = P >>> 0;
    if (i === 2 ** 32 - 1) {
        return false;
    }
    const s = `${i}`;
    if (P !== s) {
        return false;
    }
    return true;
}
const byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
function isArrayBuffer(value) {
    try {
        byteLengthGetter.call(value);
        return true;
    } catch (e) {
        return false;
    }
}
function iteratorResult([key, value], kind) {
    let result;
    switch(kind){
        case "key":
            result = key;
            break;
        case "value":
            result = value;
            break;
        case "key+value":
            result = [
                key,
                value
            ];
            break;
    }
    return {
        value: result,
        done: false
    };
}
const supportsPropertyIndex = Symbol("supports property index");
const supportedPropertyIndices = Symbol("supported property indices");
const supportsPropertyName = Symbol("supports property name");
const supportedPropertyNames = Symbol("supported property names");
const indexedGet = Symbol("indexed property get");
const indexedSetNew = Symbol("indexed property set new");
const indexedSetExisting = Symbol("indexed property set existing");
const namedGet = Symbol("named property get");
const namedSetNew = Symbol("named property set new");
const namedSetExisting = Symbol("named property set existing");
const namedDelete = Symbol("named property delete");
const asyncIteratorNext = Symbol("async iterator get the next iteration result");
const asyncIteratorReturn = Symbol("async iterator return steps");
const asyncIteratorInit = Symbol("async iterator initialization steps");
const asyncIteratorEOI = Symbol("async iterator end of iteration");
module.exports = exports = {
    isObject,
    hasOwn,
    define,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMException.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMException";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMException'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMException"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMException {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to construct 'DOMException': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to construct 'DOMException': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = "Error";
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of DOMException.");
            }
            return esValue[implSymbol]["name"];
        }
        get message() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get message' called on an object that is not a valid instance of DOMException.");
            }
            return esValue[implSymbol]["message"];
        }
        get code() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get code' called on an object that is not a valid instance of DOMException.");
            }
            return esValue[implSymbol]["code"];
        }
    }
    Object.defineProperties(DOMException.prototype, {
        name: {
            enumerable: true
        },
        message: {
            enumerable: true
        },
        code: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMException",
            configurable: true
        },
        INDEX_SIZE_ERR: {
            value: 1,
            enumerable: true
        },
        DOMSTRING_SIZE_ERR: {
            value: 2,
            enumerable: true
        },
        HIERARCHY_REQUEST_ERR: {
            value: 3,
            enumerable: true
        },
        WRONG_DOCUMENT_ERR: {
            value: 4,
            enumerable: true
        },
        INVALID_CHARACTER_ERR: {
            value: 5,
            enumerable: true
        },
        NO_DATA_ALLOWED_ERR: {
            value: 6,
            enumerable: true
        },
        NO_MODIFICATION_ALLOWED_ERR: {
            value: 7,
            enumerable: true
        },
        NOT_FOUND_ERR: {
            value: 8,
            enumerable: true
        },
        NOT_SUPPORTED_ERR: {
            value: 9,
            enumerable: true
        },
        INUSE_ATTRIBUTE_ERR: {
            value: 10,
            enumerable: true
        },
        INVALID_STATE_ERR: {
            value: 11,
            enumerable: true
        },
        SYNTAX_ERR: {
            value: 12,
            enumerable: true
        },
        INVALID_MODIFICATION_ERR: {
            value: 13,
            enumerable: true
        },
        NAMESPACE_ERR: {
            value: 14,
            enumerable: true
        },
        INVALID_ACCESS_ERR: {
            value: 15,
            enumerable: true
        },
        VALIDATION_ERR: {
            value: 16,
            enumerable: true
        },
        TYPE_MISMATCH_ERR: {
            value: 17,
            enumerable: true
        },
        SECURITY_ERR: {
            value: 18,
            enumerable: true
        },
        NETWORK_ERR: {
            value: 19,
            enumerable: true
        },
        ABORT_ERR: {
            value: 20,
            enumerable: true
        },
        URL_MISMATCH_ERR: {
            value: 21,
            enumerable: true
        },
        QUOTA_EXCEEDED_ERR: {
            value: 22,
            enumerable: true
        },
        TIMEOUT_ERR: {
            value: 23,
            enumerable: true
        },
        INVALID_NODE_TYPE_ERR: {
            value: 24,
            enumerable: true
        },
        DATA_CLONE_ERR: {
            value: 25,
            enumerable: true
        }
    });
    Object.defineProperties(DOMException, {
        INDEX_SIZE_ERR: {
            value: 1,
            enumerable: true
        },
        DOMSTRING_SIZE_ERR: {
            value: 2,
            enumerable: true
        },
        HIERARCHY_REQUEST_ERR: {
            value: 3,
            enumerable: true
        },
        WRONG_DOCUMENT_ERR: {
            value: 4,
            enumerable: true
        },
        INVALID_CHARACTER_ERR: {
            value: 5,
            enumerable: true
        },
        NO_DATA_ALLOWED_ERR: {
            value: 6,
            enumerable: true
        },
        NO_MODIFICATION_ALLOWED_ERR: {
            value: 7,
            enumerable: true
        },
        NOT_FOUND_ERR: {
            value: 8,
            enumerable: true
        },
        NOT_SUPPORTED_ERR: {
            value: 9,
            enumerable: true
        },
        INUSE_ATTRIBUTE_ERR: {
            value: 10,
            enumerable: true
        },
        INVALID_STATE_ERR: {
            value: 11,
            enumerable: true
        },
        SYNTAX_ERR: {
            value: 12,
            enumerable: true
        },
        INVALID_MODIFICATION_ERR: {
            value: 13,
            enumerable: true
        },
        NAMESPACE_ERR: {
            value: 14,
            enumerable: true
        },
        INVALID_ACCESS_ERR: {
            value: 15,
            enumerable: true
        },
        VALIDATION_ERR: {
            value: 16,
            enumerable: true
        },
        TYPE_MISMATCH_ERR: {
            value: 17,
            enumerable: true
        },
        SECURITY_ERR: {
            value: 18,
            enumerable: true
        },
        NETWORK_ERR: {
            value: 19,
            enumerable: true
        },
        ABORT_ERR: {
            value: 20,
            enumerable: true
        },
        URL_MISMATCH_ERR: {
            value: 21,
            enumerable: true
        },
        QUOTA_EXCEEDED_ERR: {
            value: 22,
            enumerable: true
        },
        TIMEOUT_ERR: {
            value: 23,
            enumerable: true
        },
        INVALID_NODE_TYPE_ERR: {
            value: 24,
            enumerable: true
        },
        DATA_CLONE_ERR: {
            value: 25,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = DOMException;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMException
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/webidl/DOMException-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "bubbles";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'bubbles' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "cancelable";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'cancelable' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "composed";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'composed' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ErrorEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "colno";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'colno' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "error";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["any"](value, {
                context: context + " has member 'error' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "filename";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'filename' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "lineno";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'lineno' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "message";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'message' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Event";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Event'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Event"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
function getUnforgeables(globalObject) {
    let unforgeables = unforgeablesMap.get(globalObject);
    if (unforgeables === undefined) {
        unforgeables = Object.create(null);
        utils.define(unforgeables, {
            get isTrusted () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get isTrusted' called on an object that is not a valid instance of Event.");
                }
                return esValue[implSymbol]["isTrusted"];
            }
        });
        Object.defineProperties(unforgeables, {
            isTrusted: {
                configurable: false
            }
        });
        unforgeablesMap.set(globalObject, unforgeables);
    }
    return unforgeables;
}
exports._internalSetup = (wrapper, globalObject)=>{
    utils.define(wrapper, getUnforgeables(globalObject));
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const unforgeablesMap = new WeakMap();
const exposed = new Set([
    "Window",
    "Worker",
    "AudioWorklet"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'Event': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'Event': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = EventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'Event': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        composedPath() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'composedPath' called on an object that is not a valid instance of Event.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].composedPath());
        }
        stopPropagation() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'stopPropagation' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol].stopPropagation();
        }
        stopImmediatePropagation() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'stopImmediatePropagation' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol].stopImmediatePropagation();
        }
        preventDefault() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'preventDefault' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol].preventDefault();
        }
        initEvent(type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initEvent' called on an object that is not a valid instance of Event.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initEvent' on 'Event': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initEvent' on 'Event': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initEvent' on 'Event': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initEvent' on 'Event': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initEvent(...args);
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["type"];
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of Event.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["target"]);
        }
        get srcElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get srcElement' called on an object that is not a valid instance of Event.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["srcElement"]);
        }
        get currentTarget() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get currentTarget' called on an object that is not a valid instance of Event.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["currentTarget"]);
        }
        get eventPhase() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get eventPhase' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["eventPhase"];
        }
        get cancelBubble() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cancelBubble' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["cancelBubble"];
        }
        set cancelBubble(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cancelBubble' called on an object that is not a valid instance of Event.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'cancelBubble' property on 'Event': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["cancelBubble"] = V;
        }
        get bubbles() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bubbles' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["bubbles"];
        }
        get cancelable() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cancelable' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["cancelable"];
        }
        get returnValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get returnValue' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["returnValue"];
        }
        set returnValue(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set returnValue' called on an object that is not a valid instance of Event.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'returnValue' property on 'Event': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["returnValue"] = V;
        }
        get defaultPrevented() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultPrevented' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["defaultPrevented"];
        }
        get composed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get composed' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["composed"];
        }
        get timeStamp() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get timeStamp' called on an object that is not a valid instance of Event.");
            }
            return esValue[implSymbol]["timeStamp"];
        }
    }
    Object.defineProperties(Event.prototype, {
        composedPath: {
            enumerable: true
        },
        stopPropagation: {
            enumerable: true
        },
        stopImmediatePropagation: {
            enumerable: true
        },
        preventDefault: {
            enumerable: true
        },
        initEvent: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        srcElement: {
            enumerable: true
        },
        currentTarget: {
            enumerable: true
        },
        eventPhase: {
            enumerable: true
        },
        cancelBubble: {
            enumerable: true
        },
        bubbles: {
            enumerable: true
        },
        cancelable: {
            enumerable: true
        },
        returnValue: {
            enumerable: true
        },
        defaultPrevented: {
            enumerable: true
        },
        composed: {
            enumerable: true
        },
        timeStamp: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Event",
            configurable: true
        },
        NONE: {
            value: 0,
            enumerable: true
        },
        CAPTURING_PHASE: {
            value: 1,
            enumerable: true
        },
        AT_TARGET: {
            value: 2,
            enumerable: true
        },
        BUBBLING_PHASE: {
            value: 3,
            enumerable: true
        }
    });
    Object.defineProperties(Event, {
        NONE: {
            value: 0,
            enumerable: true
        },
        CAPTURING_PHASE: {
            value: 1,
            enumerable: true
        },
        AT_TARGET: {
            value: 2,
            enumerable: true
        },
        BUBBLING_PHASE: {
            value: 3,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = Event;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Event
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/Event-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ErrorEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ErrorEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/ErrorEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "ErrorEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ErrorEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ErrorEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ErrorEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'ErrorEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'ErrorEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = ErrorEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'ErrorEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get message() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get message' called on an object that is not a valid instance of ErrorEvent.");
            }
            return esValue[implSymbol]["message"];
        }
        get filename() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get filename' called on an object that is not a valid instance of ErrorEvent.");
            }
            return esValue[implSymbol]["filename"];
        }
        get lineno() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lineno' called on an object that is not a valid instance of ErrorEvent.");
            }
            return esValue[implSymbol]["lineno"];
        }
        get colno() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get colno' called on an object that is not a valid instance of ErrorEvent.");
            }
            return esValue[implSymbol]["colno"];
        }
        get error() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get error' called on an object that is not a valid instance of ErrorEvent.");
            }
            return esValue[implSymbol]["error"];
        }
    }
    Object.defineProperties(ErrorEvent.prototype, {
        message: {
            enumerable: true
        },
        filename: {
            enumerable: true
        },
        lineno: {
            enumerable: true
        },
        colno: {
            enumerable: true
        },
        error: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ErrorEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ErrorEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ErrorEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/ErrorEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/NodeList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "NodeList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'NodeList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["NodeList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class NodeList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of NodeList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'NodeList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'NodeList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of NodeList.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(NodeList.prototype, {
        item: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "NodeList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        },
        keys: {
            value: globalObject.Array.prototype.keys,
            configurable: true,
            enumerable: true,
            writable: true
        },
        values: {
            value: globalObject.Array.prototype.values,
            configurable: true,
            enumerable: true,
            writable: true
        },
        entries: {
            value: globalObject.Array.prototype.entries,
            configurable: true,
            enumerable: true,
            writable: true
        },
        forEach: {
            value: globalObject.Array.prototype.forEach,
            configurable: true,
            enumerable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = NodeList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: NodeList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/NodeList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationRecord.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "MutationRecord";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MutationRecord'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MutationRecord"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MutationRecord {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of MutationRecord.");
            }
            return esValue[implSymbol]["type"];
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of MutationRecord.");
            }
            return utils.getSameObject(this, "target", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["target"]);
            });
        }
        get addedNodes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get addedNodes' called on an object that is not a valid instance of MutationRecord.");
            }
            return utils.getSameObject(this, "addedNodes", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["addedNodes"]);
            });
        }
        get removedNodes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get removedNodes' called on an object that is not a valid instance of MutationRecord.");
            }
            return utils.getSameObject(this, "removedNodes", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["removedNodes"]);
            });
        }
        get previousSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get previousSibling' called on an object that is not a valid instance of MutationRecord.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["previousSibling"]);
        }
        get nextSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nextSibling' called on an object that is not a valid instance of MutationRecord.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["nextSibling"]);
        }
        get attributeName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get attributeName' called on an object that is not a valid instance of MutationRecord.");
            }
            return esValue[implSymbol]["attributeName"];
        }
        get attributeNamespace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get attributeNamespace' called on an object that is not a valid instance of MutationRecord.");
            }
            return esValue[implSymbol]["attributeNamespace"];
        }
        get oldValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oldValue' called on an object that is not a valid instance of MutationRecord.");
            }
            return esValue[implSymbol]["oldValue"];
        }
    }
    Object.defineProperties(MutationRecord.prototype, {
        type: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        addedNodes: {
            enumerable: true
        },
        removedNodes: {
            enumerable: true
        },
        previousSibling: {
            enumerable: true
        },
        nextSibling: {
            enumerable: true
        },
        attributeName: {
            enumerable: true
        },
        attributeNamespace: {
            enumerable: true
        },
        oldValue: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MutationRecord",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = MutationRecord;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MutationRecord
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/mutation-observer/MutationRecord-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "detail";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long"](value, {
                context: context + " has member 'detail' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "view";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = utils.tryImplForWrapper(value);
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "which";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'which' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventModifierInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const UIEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    UIEventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "altKey";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'altKey' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "ctrlKey";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'ctrlKey' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "metaKey";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'metaKey' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierAltGraph";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierAltGraph' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierCapsLock";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierCapsLock' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierFn";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierFn' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierFnLock";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierFnLock' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierHyper";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierHyper' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierNumLock";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierNumLock' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierScrollLock";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierScrollLock' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierSuper";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierSuper' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierSymbol";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierSymbol' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "modifierSymbolLock";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'modifierSymbolLock' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "shiftKey";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'shiftKey' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MouseEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const EventModifierInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventModifierInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventModifierInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "button";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["short"](value, {
                context: context + " has member 'button' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "buttons";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned short"](value, {
                context: context + " has member 'buttons' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "clientX";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long"](value, {
                context: context + " has member 'clientX' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "clientX";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'clientX' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
    {
        const key = "clientY";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long"](value, {
                context: context + " has member 'clientY' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "clientY";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'clientY' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
    {
        const key = "relatedTarget";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = EventTarget.convert(globalObject, value, {
                    context: context + " has member 'relatedTarget' that"
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "screenX";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long"](value, {
                context: context + " has member 'screenX' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "screenX";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'screenX' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
    {
        const key = "screenY";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long"](value, {
                context: context + " has member 'screenY' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "screenY";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'screenY' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const UIEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "UIEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'UIEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["UIEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class UIEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'UIEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'UIEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = UIEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'UIEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        initUIEvent(typeArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initUIEvent' called on an object that is not a valid instance of UIEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initUIEvent' on 'UIEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initUIEvent' on 'UIEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initUIEvent' on 'UIEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initUIEvent' on 'UIEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = utils.tryImplForWrapper(curArg);
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initUIEvent' on 'UIEvent': parameter 5",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initUIEvent(...args);
        }
        get view() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get view' called on an object that is not a valid instance of UIEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["view"]);
        }
        get detail() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get detail' called on an object that is not a valid instance of UIEvent.");
            }
            return esValue[implSymbol]["detail"];
        }
        get which() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get which' called on an object that is not a valid instance of UIEvent.");
            }
            return esValue[implSymbol]["which"];
        }
    }
    Object.defineProperties(UIEvent.prototype, {
        initUIEvent: {
            enumerable: true
        },
        view: {
            enumerable: true
        },
        detail: {
            enumerable: true
        },
        which: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "UIEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = UIEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: UIEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/UIEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MouseEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const MouseEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MouseEventInit.js [middleware-edge] (ecmascript)");
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "MouseEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MouseEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MouseEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MouseEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'MouseEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'MouseEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = MouseEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'MouseEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        getModifierState(keyArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getModifierState' called on an object that is not a valid instance of MouseEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getModifierState' on 'MouseEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getModifierState' on 'MouseEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].getModifierState(...args);
        }
        initMouseEvent(typeArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initMouseEvent' called on an object that is not a valid instance of MouseEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initMouseEvent' on 'MouseEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = utils.tryImplForWrapper(curArg);
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 5",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[5];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 6",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[6];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 7",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[7];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 8",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[8];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 9",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[9];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 10",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[10];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 11",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[11];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 12",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[12];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 13",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[13];
                if (curArg !== undefined) {
                    curArg = conversions["short"](curArg, {
                        context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 14",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[14];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = EventTarget.convert(globalObject, curArg, {
                            context: "Failed to execute 'initMouseEvent' on 'MouseEvent': parameter 15"
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initMouseEvent(...args);
        }
        get screenX() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get screenX' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["screenX"];
        }
        get screenY() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get screenY' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["screenY"];
        }
        get clientX() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get clientX' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["clientX"];
        }
        get clientY() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get clientY' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["clientY"];
        }
        get ctrlKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ctrlKey' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["ctrlKey"];
        }
        get shiftKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shiftKey' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["shiftKey"];
        }
        get altKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get altKey' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["altKey"];
        }
        get metaKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get metaKey' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["metaKey"];
        }
        get button() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get button' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["button"];
        }
        get buttons() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get buttons' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["buttons"];
        }
        get relatedTarget() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get relatedTarget' called on an object that is not a valid instance of MouseEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["relatedTarget"]);
        }
        get pageX() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pageX' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["pageX"];
        }
        get pageY() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pageY' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["pageY"];
        }
        get x() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get x' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["x"];
        }
        get y() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get y' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["y"];
        }
        get offsetX() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetX' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["offsetX"];
        }
        get offsetY() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetY' called on an object that is not a valid instance of MouseEvent.");
            }
            return esValue[implSymbol]["offsetY"];
        }
    }
    Object.defineProperties(MouseEvent.prototype, {
        getModifierState: {
            enumerable: true
        },
        initMouseEvent: {
            enumerable: true
        },
        screenX: {
            enumerable: true
        },
        screenY: {
            enumerable: true
        },
        clientX: {
            enumerable: true
        },
        clientY: {
            enumerable: true
        },
        ctrlKey: {
            enumerable: true
        },
        shiftKey: {
            enumerable: true
        },
        altKey: {
            enumerable: true
        },
        metaKey: {
            enumerable: true
        },
        button: {
            enumerable: true
        },
        buttons: {
            enumerable: true
        },
        relatedTarget: {
            enumerable: true
        },
        pageX: {
            enumerable: true
        },
        pageY: {
            enumerable: true
        },
        x: {
            enumerable: true
        },
        y: {
            enumerable: true
        },
        offsetX: {
            enumerable: true
        },
        offsetY: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MouseEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = MouseEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MouseEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/MouseEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventListener.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (!utils.isObject(value)) {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    function callTheUserObjectsOperation(event) {
        let thisArg = utils.tryWrapperForImpl(this);
        let O = value;
        let X = O;
        if (typeof O !== "function") {
            X = O["handleEvent"];
            if (typeof X !== "function") {
                throw new globalObject.TypeError(`${context} does not correctly implement EventListener.`);
            }
            thisArg = O;
        }
        event = utils.tryWrapperForImpl(event);
        let callResult = Reflect.apply(X, thisArg, [
            event
        ]);
    }
    callTheUserObjectsOperation[utils.wrapperSymbol] = value;
    callTheUserObjectsOperation.objectReference = value;
    return callTheUserObjectsOperation;
};
exports.install = (globalObject, globalNames)=>{};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    function invokeTheCallbackFunction(event) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        if (typeof value === "function") {
            event = utils.tryWrapperForImpl(event);
            callResult = Reflect.apply(value, thisArg, [
                event
            ]);
        }
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    }
    invokeTheCallbackFunction.construct = (event)=>{
        event = utils.tryWrapperForImpl(event);
        let callResult = Reflect.construct(value, [
            event
        ]);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/OnBeforeUnloadEventHandlerNonNull.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    function invokeTheCallbackFunction(event) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        if (typeof value === "function") {
            event = utils.tryWrapperForImpl(event);
            callResult = Reflect.apply(value, thisArg, [
                event
            ]);
        }
        if (callResult === null || callResult === undefined) {
            callResult = null;
        } else {
            callResult = conversions["DOMString"](callResult, {
                context: context,
                globals: globalObject
            });
        }
        return callResult;
    }
    invokeTheCallbackFunction.construct = (event)=>{
        event = utils.tryWrapperForImpl(event);
        let callResult = Reflect.construct(value, [
            event
        ]);
        if (callResult === null || callResult === undefined) {
            callResult = null;
        } else {
            callResult = conversions["DOMString"](callResult, {
                context: context,
                globals: globalObject
            });
        }
        return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/OnErrorEventHandlerNonNull.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    function invokeTheCallbackFunction(...args) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        if (typeof value === "function") {
            for(let i = 0; i < Math.min(args.length, 5); i++){
                args[i] = utils.tryWrapperForImpl(args[i]);
            }
            if (args.length < 1) {
                for(let i = args.length; i < 1; i++){
                    args[i] = undefined;
                }
            } else if (args.length > 5) {
                args.length = 5;
            }
            callResult = Reflect.apply(value, thisArg, args);
        }
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    }
    invokeTheCallbackFunction.construct = (...args)=>{
        for(let i = 0; i < Math.min(args.length, 5); i++){
            args[i] = utils.tryWrapperForImpl(args[i]);
        }
        if (args.length < 1) {
            for(let i = args.length; i < 1; i++){
                args[i] = undefined;
            }
        } else if (args.length > 5) {
            args.length = 5;
        }
        let callResult = Reflect.construct(value, args);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/AbortSignal.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "AbortSignal";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'AbortSignal'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["AbortSignal"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class AbortSignal extends globalObject.EventTarget {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        throwIfAborted() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'throwIfAborted' called on an object that is not a valid instance of AbortSignal.");
            }
            return esValue[implSymbol].throwIfAborted();
        }
        get aborted() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get aborted' called on an object that is not a valid instance of AbortSignal.");
            }
            return esValue[implSymbol]["aborted"];
        }
        get reason() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get reason' called on an object that is not a valid instance of AbortSignal.");
            }
            return esValue[implSymbol]["reason"];
        }
        get onabort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onabort' called on an object that is not a valid instance of AbortSignal.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onabort"]);
        }
        set onabort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onabort' called on an object that is not a valid instance of AbortSignal.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onabort' property on 'AbortSignal': The provided value"
                });
            }
            esValue[implSymbol]["onabort"] = V;
        }
        static abort() {
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'abort' on 'AbortSignal': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.abort(globalObject, ...args));
        }
        static timeout(milliseconds) {
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'timeout' on 'AbortSignal': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long long"](curArg, {
                    context: "Failed to execute 'timeout' on 'AbortSignal': parameter 1",
                    globals: globalObject,
                    enforceRange: true
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.timeout(globalObject, ...args));
        }
        static any(signals) {
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'any' on 'AbortSignal': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError("Failed to execute 'any' on 'AbortSignal': parameter 1" + " is not an iterable object.");
                } else {
                    const V = [];
                    const tmp = curArg;
                    for (let nextItem of tmp){
                        nextItem = exports.convert(globalObject, nextItem, {
                            context: "Failed to execute 'any' on 'AbortSignal': parameter 1" + "'s element"
                        });
                        V.push(nextItem);
                    }
                    curArg = V;
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.any(globalObject, ...args));
        }
    }
    Object.defineProperties(AbortSignal.prototype, {
        throwIfAborted: {
            enumerable: true
        },
        aborted: {
            enumerable: true
        },
        reason: {
            enumerable: true
        },
        onabort: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "AbortSignal",
            configurable: true
        }
    });
    Object.defineProperties(AbortSignal, {
        abort: {
            enumerable: true
        },
        timeout: {
            enumerable: true
        },
        any: {
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = AbortSignal;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: AbortSignal
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/aborting/AbortSignal-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventListenerOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "capture";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'capture' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/AddEventListenerOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const AbortSignal = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/AbortSignal.js [middleware-edge] (ecmascript)");
const EventListenerOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventListenerOptions.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventListenerOptions._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "once";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'once' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "passive";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'passive' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "signal";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = AbortSignal.convert(globalObject, value, {
                context: context + " has member 'signal' that"
            });
            ret[key] = value;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventListener = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventListener.js [middleware-edge] (ecmascript)");
const AddEventListenerOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/AddEventListenerOptions.js [middleware-edge] (ecmascript)");
const EventListenerOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventListenerOptions.js [middleware-edge] (ecmascript)");
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "EventTarget";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'EventTarget'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["EventTarget"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker",
    "AudioWorklet"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class EventTarget {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        addEventListener(type, callback) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'addEventListener' called on an object that is not a valid instance of EventTarget.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = EventListener.convert(globalObject, curArg, {
                        context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 2"
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = AddEventListenerOptions.convert(globalObject, curArg, {
                            context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 3"
                        });
                    } else if (utils.isObject(curArg)) {
                        curArg = AddEventListenerOptions.convert(globalObject, curArg, {
                            context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 3" + " dictionary"
                        });
                    } else if (typeof curArg === "boolean") {
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 3",
                            globals: globalObject
                        });
                    } else {
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'addEventListener' on 'EventTarget': parameter 3",
                            globals: globalObject
                        });
                    }
                }
                args.push(curArg);
            }
            return esValue[implSymbol].addEventListener(...args);
        }
        removeEventListener(type, callback) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeEventListener' called on an object that is not a valid instance of EventTarget.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'removeEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = EventListener.convert(globalObject, curArg, {
                        context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 2"
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = EventListenerOptions.convert(globalObject, curArg, {
                            context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 3"
                        });
                    } else if (utils.isObject(curArg)) {
                        curArg = EventListenerOptions.convert(globalObject, curArg, {
                            context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 3" + " dictionary"
                        });
                    } else if (typeof curArg === "boolean") {
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 3",
                            globals: globalObject
                        });
                    } else {
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'removeEventListener' on 'EventTarget': parameter 3",
                            globals: globalObject
                        });
                    }
                }
                args.push(curArg);
            }
            return esValue[implSymbol].removeEventListener(...args);
        }
        dispatchEvent(event) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'dispatchEvent' called on an object that is not a valid instance of EventTarget.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'dispatchEvent' on 'EventTarget': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Event.convert(globalObject, curArg, {
                    context: "Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].dispatchEvent(...args);
        }
    }
    Object.defineProperties(EventTarget.prototype, {
        addEventListener: {
            enumerable: true
        },
        removeEventListener: {
            enumerable: true
        },
        dispatchEvent: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "EventTarget",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = EventTarget;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: EventTarget
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLCollection.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "HTMLCollection";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLCollection'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLCollection"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLCollection {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of HTMLCollection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'HTMLCollection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'HTMLCollection': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of HTMLCollection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'HTMLCollection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'HTMLCollection': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].namedItem(...args));
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of HTMLCollection.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(HTMLCollection.prototype, {
        item: {
            enumerable: true
        },
        namedItem: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLCollection",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLCollection;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLCollection
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!(key in target)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        const namedValue = target[implSymbol].namedItem(P);
        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
            return {
                writable: false,
                enumerable: false,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        if (!utils.hasOwn(target, P)) {
            const creating = !(target[implSymbol].namedItem(P) !== null);
            if (!creating) {
                return false;
            }
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
            return false;
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCollection-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/GetRootNodeOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "composed";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'composed' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const GetRootNodeOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/GetRootNodeOptions.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "Node";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Node'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Node"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Node extends globalObject.EventTarget {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        getRootNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getRootNode' called on an object that is not a valid instance of Node.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = GetRootNodeOptions.convert(globalObject, curArg, {
                    context: "Failed to execute 'getRootNode' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getRootNode(...args));
        }
        hasChildNodes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'hasChildNodes' called on an object that is not a valid instance of Node.");
            }
            return esValue[implSymbol].hasChildNodes();
        }
        normalize() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'normalize' called on an object that is not a valid instance of Node.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].normalize();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        cloneNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'cloneNode' called on an object that is not a valid instance of Node.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'cloneNode' on 'Node': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].cloneNode(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        isEqualNode(otherNode) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'isEqualNode' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'isEqualNode' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = exports.convert(globalObject, curArg, {
                        context: "Failed to execute 'isEqualNode' on 'Node': parameter 1"
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].isEqualNode(...args);
        }
        isSameNode(otherNode) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'isSameNode' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'isSameNode' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = exports.convert(globalObject, curArg, {
                        context: "Failed to execute 'isSameNode' on 'Node': parameter 1"
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].isSameNode(...args);
        }
        compareDocumentPosition(other) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'compareDocumentPosition' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'compareDocumentPosition' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'compareDocumentPosition' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].compareDocumentPosition(...args);
        }
        contains(other) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'contains' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'contains' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = exports.convert(globalObject, curArg, {
                        context: "Failed to execute 'contains' on 'Node': parameter 1"
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].contains(...args);
        }
        lookupPrefix(namespace) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'lookupPrefix' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'lookupPrefix' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'lookupPrefix' on 'Node': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].lookupPrefix(...args);
        }
        lookupNamespaceURI(prefix) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'lookupNamespaceURI' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'lookupNamespaceURI' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'lookupNamespaceURI' on 'Node': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].lookupNamespaceURI(...args);
        }
        isDefaultNamespace(namespace) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'isDefaultNamespace' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'isDefaultNamespace' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'isDefaultNamespace' on 'Node': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].isDefaultNamespace(...args);
        }
        insertBefore(node, child) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertBefore' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'insertBefore' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = exports.convert(globalObject, curArg, {
                        context: "Failed to execute 'insertBefore' on 'Node': parameter 2"
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].insertBefore(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        appendChild(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'appendChild' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'appendChild' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'appendChild' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].appendChild(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        replaceChild(node, child) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceChild' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'replaceChild' on 'Node': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'replaceChild' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'replaceChild' on 'Node': parameter 2"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].replaceChild(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        removeChild(child) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeChild' called on an object that is not a valid instance of Node.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'removeChild' on 'Node': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'removeChild' on 'Node': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].removeChild(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get nodeType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nodeType' called on an object that is not a valid instance of Node.");
            }
            return esValue[implSymbol]["nodeType"];
        }
        get nodeName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nodeName' called on an object that is not a valid instance of Node.");
            }
            return esValue[implSymbol]["nodeName"];
        }
        get baseURI() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get baseURI' called on an object that is not a valid instance of Node.");
            }
            return esValue[implSymbol]["baseURI"];
        }
        get isConnected() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get isConnected' called on an object that is not a valid instance of Node.");
            }
            return esValue[implSymbol]["isConnected"];
        }
        get ownerDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ownerDocument' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ownerDocument"]);
        }
        get parentNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get parentNode' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["parentNode"]);
        }
        get parentElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get parentElement' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["parentElement"]);
        }
        get childNodes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get childNodes' called on an object that is not a valid instance of Node.");
            }
            return utils.getSameObject(this, "childNodes", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["childNodes"]);
            });
        }
        get firstChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get firstChild' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["firstChild"]);
        }
        get lastChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lastChild' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["lastChild"]);
        }
        get previousSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get previousSibling' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["previousSibling"]);
        }
        get nextSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nextSibling' called on an object that is not a valid instance of Node.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["nextSibling"]);
        }
        get nodeValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nodeValue' called on an object that is not a valid instance of Node.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["nodeValue"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set nodeValue(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set nodeValue' called on an object that is not a valid instance of Node.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'nodeValue' property on 'Node': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["nodeValue"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get textContent() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get textContent' called on an object that is not a valid instance of Node.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["textContent"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set textContent(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set textContent' called on an object that is not a valid instance of Node.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'textContent' property on 'Node': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["textContent"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(Node.prototype, {
        getRootNode: {
            enumerable: true
        },
        hasChildNodes: {
            enumerable: true
        },
        normalize: {
            enumerable: true
        },
        cloneNode: {
            enumerable: true
        },
        isEqualNode: {
            enumerable: true
        },
        isSameNode: {
            enumerable: true
        },
        compareDocumentPosition: {
            enumerable: true
        },
        contains: {
            enumerable: true
        },
        lookupPrefix: {
            enumerable: true
        },
        lookupNamespaceURI: {
            enumerable: true
        },
        isDefaultNamespace: {
            enumerable: true
        },
        insertBefore: {
            enumerable: true
        },
        appendChild: {
            enumerable: true
        },
        replaceChild: {
            enumerable: true
        },
        removeChild: {
            enumerable: true
        },
        nodeType: {
            enumerable: true
        },
        nodeName: {
            enumerable: true
        },
        baseURI: {
            enumerable: true
        },
        isConnected: {
            enumerable: true
        },
        ownerDocument: {
            enumerable: true
        },
        parentNode: {
            enumerable: true
        },
        parentElement: {
            enumerable: true
        },
        childNodes: {
            enumerable: true
        },
        firstChild: {
            enumerable: true
        },
        lastChild: {
            enumerable: true
        },
        previousSibling: {
            enumerable: true
        },
        nextSibling: {
            enumerable: true
        },
        nodeValue: {
            enumerable: true
        },
        textContent: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Node",
            configurable: true
        },
        ELEMENT_NODE: {
            value: 1,
            enumerable: true
        },
        ATTRIBUTE_NODE: {
            value: 2,
            enumerable: true
        },
        TEXT_NODE: {
            value: 3,
            enumerable: true
        },
        CDATA_SECTION_NODE: {
            value: 4,
            enumerable: true
        },
        ENTITY_REFERENCE_NODE: {
            value: 5,
            enumerable: true
        },
        ENTITY_NODE: {
            value: 6,
            enumerable: true
        },
        PROCESSING_INSTRUCTION_NODE: {
            value: 7,
            enumerable: true
        },
        COMMENT_NODE: {
            value: 8,
            enumerable: true
        },
        DOCUMENT_NODE: {
            value: 9,
            enumerable: true
        },
        DOCUMENT_TYPE_NODE: {
            value: 10,
            enumerable: true
        },
        DOCUMENT_FRAGMENT_NODE: {
            value: 11,
            enumerable: true
        },
        NOTATION_NODE: {
            value: 12,
            enumerable: true
        },
        DOCUMENT_POSITION_DISCONNECTED: {
            value: 0x01,
            enumerable: true
        },
        DOCUMENT_POSITION_PRECEDING: {
            value: 0x02,
            enumerable: true
        },
        DOCUMENT_POSITION_FOLLOWING: {
            value: 0x04,
            enumerable: true
        },
        DOCUMENT_POSITION_CONTAINS: {
            value: 0x08,
            enumerable: true
        },
        DOCUMENT_POSITION_CONTAINED_BY: {
            value: 0x10,
            enumerable: true
        },
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: {
            value: 0x20,
            enumerable: true
        }
    });
    Object.defineProperties(Node, {
        ELEMENT_NODE: {
            value: 1,
            enumerable: true
        },
        ATTRIBUTE_NODE: {
            value: 2,
            enumerable: true
        },
        TEXT_NODE: {
            value: 3,
            enumerable: true
        },
        CDATA_SECTION_NODE: {
            value: 4,
            enumerable: true
        },
        ENTITY_REFERENCE_NODE: {
            value: 5,
            enumerable: true
        },
        ENTITY_NODE: {
            value: 6,
            enumerable: true
        },
        PROCESSING_INSTRUCTION_NODE: {
            value: 7,
            enumerable: true
        },
        COMMENT_NODE: {
            value: 8,
            enumerable: true
        },
        DOCUMENT_NODE: {
            value: 9,
            enumerable: true
        },
        DOCUMENT_TYPE_NODE: {
            value: 10,
            enumerable: true
        },
        DOCUMENT_FRAGMENT_NODE: {
            value: 11,
            enumerable: true
        },
        NOTATION_NODE: {
            value: 12,
            enumerable: true
        },
        DOCUMENT_POSITION_DISCONNECTED: {
            value: 0x01,
            enumerable: true
        },
        DOCUMENT_POSITION_PRECEDING: {
            value: 0x02,
            enumerable: true
        },
        DOCUMENT_POSITION_FOLLOWING: {
            value: 0x04,
            enumerable: true
        },
        DOCUMENT_POSITION_CONTAINS: {
            value: 0x08,
            enumerable: true
        },
        DOCUMENT_POSITION_CONTAINED_BY: {
            value: 0x10,
            enumerable: true
        },
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: {
            value: 0x20,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = Node;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Node
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Attr.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const interfaceName = "Attr";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Attr'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Attr"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Node._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Attr extends globalObject.Node {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get namespaceURI() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get namespaceURI' called on an object that is not a valid instance of Attr.");
            }
            return esValue[implSymbol]["namespaceURI"];
        }
        get prefix() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get prefix' called on an object that is not a valid instance of Attr.");
            }
            return esValue[implSymbol]["prefix"];
        }
        get localName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get localName' called on an object that is not a valid instance of Attr.");
            }
            return esValue[implSymbol]["localName"];
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of Attr.");
            }
            return esValue[implSymbol]["name"];
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of Attr.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of Attr.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'Attr': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ownerElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ownerElement' called on an object that is not a valid instance of Attr.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ownerElement"]);
        }
        get specified() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get specified' called on an object that is not a valid instance of Attr.");
            }
            return esValue[implSymbol]["specified"];
        }
    }
    Object.defineProperties(Attr.prototype, {
        namespaceURI: {
            enumerable: true
        },
        prefix: {
            enumerable: true
        },
        localName: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        ownerElement: {
            enumerable: true
        },
        specified: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Attr",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Attr;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Attr
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/attributes/Attr-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/NamedNodeMap.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Attr = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Attr.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "NamedNodeMap";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'NamedNodeMap'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["NamedNodeMap"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class NamedNodeMap {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'NamedNodeMap': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'NamedNodeMap': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        getNamedItem(qualifiedName) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getNamedItem' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getNamedItem' on 'NamedNodeMap': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getNamedItem' on 'NamedNodeMap': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getNamedItem(...args));
        }
        getNamedItemNS(namespace, localName) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getNamedItemNS' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'getNamedItemNS' on 'NamedNodeMap': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'getNamedItemNS' on 'NamedNodeMap': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getNamedItemNS' on 'NamedNodeMap': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getNamedItemNS(...args));
        }
        setNamedItem(attr) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setNamedItem' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setNamedItem' on 'NamedNodeMap': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Attr.convert(globalObject, curArg, {
                    context: "Failed to execute 'setNamedItem' on 'NamedNodeMap': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].setNamedItem(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        setNamedItemNS(attr) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setNamedItemNS' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setNamedItemNS' on 'NamedNodeMap': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Attr.convert(globalObject, curArg, {
                    context: "Failed to execute 'setNamedItemNS' on 'NamedNodeMap': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].setNamedItemNS(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        removeNamedItem(qualifiedName) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeNamedItem' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'removeNamedItem' on 'NamedNodeMap': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'removeNamedItem' on 'NamedNodeMap': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].removeNamedItem(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        removeNamedItemNS(namespace, localName) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeNamedItemNS' called on an object that is not a valid instance of NamedNodeMap.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'removeNamedItemNS' on 'NamedNodeMap': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'removeNamedItemNS' on 'NamedNodeMap': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'removeNamedItemNS' on 'NamedNodeMap': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].removeNamedItemNS(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of NamedNodeMap.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(NamedNodeMap.prototype, {
        item: {
            enumerable: true
        },
        getNamedItem: {
            enumerable: true
        },
        getNamedItemNS: {
            enumerable: true
        },
        setNamedItem: {
            enumerable: true
        },
        setNamedItemNS: {
            enumerable: true
        },
        removeNamedItem: {
            enumerable: true
        },
        removeNamedItemNS: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "NamedNodeMap",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = NamedNodeMap;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: NamedNodeMap
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!(key in target)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        const namedValue = target[implSymbol].getNamedItem(P);
        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
            return {
                writable: false,
                enumerable: false,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        if (!utils.hasOwn(target, P)) {
            const creating = !(target[implSymbol].getNamedItem(P) !== null);
            if (!creating) {
                return false;
            }
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        if (target[implSymbol].getNamedItem(P) !== null && !(P in target)) {
            return false;
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/attributes/NamedNodeMap-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DocumentFragment.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DocumentFragment";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DocumentFragment'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DocumentFragment"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Node._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DocumentFragment extends globalObject.Node {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        getElementById(elementId) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getElementById' called on an object that is not a valid instance of DocumentFragment.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getElementById' on 'DocumentFragment': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getElementById' on 'DocumentFragment': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getElementById(...args));
        }
        prepend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'prepend' called on an object that is not a valid instance of DocumentFragment.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'prepend' on 'DocumentFragment': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].prepend(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        append() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'append' called on an object that is not a valid instance of DocumentFragment.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'append' on 'DocumentFragment': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].append(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        replaceChildren() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceChildren' called on an object that is not a valid instance of DocumentFragment.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'replaceChildren' on 'DocumentFragment': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].replaceChildren(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        querySelector(selectors) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'querySelector' called on an object that is not a valid instance of DocumentFragment.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'querySelector' on 'DocumentFragment': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'querySelector' on 'DocumentFragment': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].querySelector(...args));
        }
        querySelectorAll(selectors) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'querySelectorAll' called on an object that is not a valid instance of DocumentFragment.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'querySelectorAll' on 'DocumentFragment': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'querySelectorAll' on 'DocumentFragment': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].querySelectorAll(...args));
        }
        get children() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get children' called on an object that is not a valid instance of DocumentFragment.");
            }
            return utils.getSameObject(this, "children", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["children"]);
            });
        }
        get firstElementChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get firstElementChild' called on an object that is not a valid instance of DocumentFragment.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["firstElementChild"]);
        }
        get lastElementChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lastElementChild' called on an object that is not a valid instance of DocumentFragment.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["lastElementChild"]);
        }
        get childElementCount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get childElementCount' called on an object that is not a valid instance of DocumentFragment.");
            }
            return esValue[implSymbol]["childElementCount"];
        }
    }
    Object.defineProperties(DocumentFragment.prototype, {
        getElementById: {
            enumerable: true
        },
        prepend: {
            enumerable: true
        },
        append: {
            enumerable: true
        },
        replaceChildren: {
            enumerable: true
        },
        querySelector: {
            enumerable: true
        },
        querySelectorAll: {
            enumerable: true
        },
        children: {
            enumerable: true
        },
        firstElementChild: {
            enumerable: true
        },
        lastElementChild: {
            enumerable: true
        },
        childElementCount: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DocumentFragment",
            configurable: true
        },
        [Symbol.unscopables]: {
            value: {
                prepend: true,
                append: true,
                replaceChildren: true,
                __proto__: null
            },
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = DocumentFragment;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DocumentFragment
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/DocumentFragment-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DocumentType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DocumentType";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DocumentType'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DocumentType"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Node._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DocumentType extends globalObject.Node {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        before() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'before' called on an object that is not a valid instance of DocumentType.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'before' on 'DocumentType': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].before(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        after() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'after' called on an object that is not a valid instance of DocumentType.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'after' on 'DocumentType': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].after(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        replaceWith() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceWith' called on an object that is not a valid instance of DocumentType.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'replaceWith' on 'DocumentType': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].replaceWith(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        remove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'remove' called on an object that is not a valid instance of DocumentType.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].remove();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of DocumentType.");
            }
            return esValue[implSymbol]["name"];
        }
        get publicId() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get publicId' called on an object that is not a valid instance of DocumentType.");
            }
            return esValue[implSymbol]["publicId"];
        }
        get systemId() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get systemId' called on an object that is not a valid instance of DocumentType.");
            }
            return esValue[implSymbol]["systemId"];
        }
    }
    Object.defineProperties(DocumentType.prototype, {
        before: {
            enumerable: true
        },
        after: {
            enumerable: true
        },
        replaceWith: {
            enumerable: true
        },
        remove: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        publicId: {
            enumerable: true
        },
        systemId: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DocumentType",
            configurable: true
        },
        [Symbol.unscopables]: {
            value: {
                before: true,
                after: true,
                replaceWith: true,
                remove: true,
                __proto__: null
            },
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = DocumentType;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DocumentType
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/DocumentType-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CharacterData.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "CharacterData";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CharacterData'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CharacterData"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Node._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CharacterData extends globalObject.Node {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        substringData(offset, count) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'substringData' called on an object that is not a valid instance of CharacterData.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'substringData' on 'CharacterData': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'substringData' on 'CharacterData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'substringData' on 'CharacterData': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].substringData(...args);
        }
        appendData(data) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'appendData' called on an object that is not a valid instance of CharacterData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'appendData' on 'CharacterData': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'appendData' on 'CharacterData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].appendData(...args);
        }
        insertData(offset, data) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertData' called on an object that is not a valid instance of CharacterData.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'insertData' on 'CharacterData': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'insertData' on 'CharacterData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'insertData' on 'CharacterData': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].insertData(...args);
        }
        deleteData(offset, count) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteData' called on an object that is not a valid instance of CharacterData.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'deleteData' on 'CharacterData': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'deleteData' on 'CharacterData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'deleteData' on 'CharacterData': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].deleteData(...args);
        }
        replaceData(offset, count, data) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceData' called on an object that is not a valid instance of CharacterData.");
            }
            if (arguments.length < 3) {
                throw new globalObject.TypeError(`Failed to execute 'replaceData' on 'CharacterData': 3 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'replaceData' on 'CharacterData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'replaceData' on 'CharacterData': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'replaceData' on 'CharacterData': parameter 3",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].replaceData(...args);
        }
        before() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'before' called on an object that is not a valid instance of CharacterData.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'before' on 'CharacterData': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].before(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        after() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'after' called on an object that is not a valid instance of CharacterData.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'after' on 'CharacterData': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].after(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        replaceWith() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceWith' called on an object that is not a valid instance of CharacterData.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                if (Node.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'replaceWith' on 'CharacterData': parameter " + (i + 1),
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].replaceWith(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        remove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'remove' called on an object that is not a valid instance of CharacterData.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].remove();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get data() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get data' called on an object that is not a valid instance of CharacterData.");
            }
            return esValue[implSymbol]["data"];
        }
        set data(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set data' called on an object that is not a valid instance of CharacterData.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'data' property on 'CharacterData': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            esValue[implSymbol]["data"] = V;
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of CharacterData.");
            }
            return esValue[implSymbol]["length"];
        }
        get previousElementSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get previousElementSibling' called on an object that is not a valid instance of CharacterData.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["previousElementSibling"]);
        }
        get nextElementSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nextElementSibling' called on an object that is not a valid instance of CharacterData.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["nextElementSibling"]);
        }
    }
    Object.defineProperties(CharacterData.prototype, {
        substringData: {
            enumerable: true
        },
        appendData: {
            enumerable: true
        },
        insertData: {
            enumerable: true
        },
        deleteData: {
            enumerable: true
        },
        replaceData: {
            enumerable: true
        },
        before: {
            enumerable: true
        },
        after: {
            enumerable: true
        },
        replaceWith: {
            enumerable: true
        },
        remove: {
            enumerable: true
        },
        data: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        previousElementSibling: {
            enumerable: true
        },
        nextElementSibling: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "CharacterData",
            configurable: true
        },
        [Symbol.unscopables]: {
            value: {
                before: true,
                after: true,
                replaceWith: true,
                remove: true,
                __proto__: null
            },
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CharacterData;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CharacterData
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/CharacterData-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Text.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const CharacterData = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CharacterData.js [middleware-edge] (ecmascript)");
const interfaceName = "Text";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Text'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Text"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    CharacterData._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Text extends globalObject.CharacterData {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to construct 'Text': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        splitText(offset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'splitText' called on an object that is not a valid instance of Text.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'splitText' on 'Text': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'splitText' on 'Text': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].splitText(...args));
        }
        get wholeText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get wholeText' called on an object that is not a valid instance of Text.");
            }
            return esValue[implSymbol]["wholeText"];
        }
        get assignedSlot() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get assignedSlot' called on an object that is not a valid instance of Text.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["assignedSlot"]);
        }
    }
    Object.defineProperties(Text.prototype, {
        splitText: {
            enumerable: true
        },
        wholeText: {
            enumerable: true
        },
        assignedSlot: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Text",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Text;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Text
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/Text-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CDATASection.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Text = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Text.js [middleware-edge] (ecmascript)");
const interfaceName = "CDATASection";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CDATASection'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CDATASection"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Text._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CDATASection extends globalObject.Text {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(CDATASection.prototype, {
        [Symbol.toStringTag]: {
            value: "CDATASection",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CDATASection;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CDATASection
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/CDATASection-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Comment.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const CharacterData = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CharacterData.js [middleware-edge] (ecmascript)");
const interfaceName = "Comment";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Comment'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Comment"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    CharacterData._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Comment extends globalObject.CharacterData {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to construct 'Comment': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
    }
    Object.defineProperties(Comment.prototype, {
        [Symbol.toStringTag]: {
            value: "Comment",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Comment;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Comment
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/Comment-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ProcessingInstruction.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const CharacterData = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CharacterData.js [middleware-edge] (ecmascript)");
const interfaceName = "ProcessingInstruction";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ProcessingInstruction'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ProcessingInstruction"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    CharacterData._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ProcessingInstruction extends globalObject.CharacterData {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of ProcessingInstruction.");
            }
            return esValue[implSymbol]["target"];
        }
    }
    Object.defineProperties(ProcessingInstruction.prototype, {
        target: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ProcessingInstruction",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ProcessingInstruction;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ProcessingInstruction
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/ProcessingInstruction-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMTokenList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMTokenList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMTokenList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMTokenList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMTokenList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of DOMTokenList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'DOMTokenList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'DOMTokenList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].item(...args);
        }
        contains(token) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'contains' called on an object that is not a valid instance of DOMTokenList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'contains' on 'DOMTokenList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'contains' on 'DOMTokenList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].contains(...args);
        }
        add() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'add' called on an object that is not a valid instance of DOMTokenList.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'add' on 'DOMTokenList': parameter " + (i + 1),
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].add(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        remove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'remove' called on an object that is not a valid instance of DOMTokenList.");
            }
            const args = [];
            for(let i = 0; i < arguments.length; i++){
                let curArg = arguments[i];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'remove' on 'DOMTokenList': parameter " + (i + 1),
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].remove(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        toggle(token) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toggle' called on an object that is not a valid instance of DOMTokenList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'toggle' on 'DOMTokenList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'toggle' on 'DOMTokenList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'toggle' on 'DOMTokenList': parameter 2",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].toggle(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        replace(token, newToken) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replace' called on an object that is not a valid instance of DOMTokenList.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'replace' on 'DOMTokenList': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'replace' on 'DOMTokenList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'replace' on 'DOMTokenList': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].replace(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        supports(token) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'supports' called on an object that is not a valid instance of DOMTokenList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'supports' on 'DOMTokenList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'supports' on 'DOMTokenList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].supports(...args);
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of DOMTokenList.");
            }
            return esValue[implSymbol]["length"];
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of DOMTokenList.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of DOMTokenList.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'DOMTokenList': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        toString() {
            const esValue = this;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of DOMTokenList.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(DOMTokenList.prototype, {
        item: {
            enumerable: true
        },
        contains: {
            enumerable: true
        },
        add: {
            enumerable: true
        },
        remove: {
            enumerable: true
        },
        toggle: {
            enumerable: true
        },
        replace: {
            enumerable: true
        },
        supports: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        toString: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMTokenList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        },
        keys: {
            value: globalObject.Array.prototype.keys,
            configurable: true,
            enumerable: true,
            writable: true
        },
        values: {
            value: globalObject.Array.prototype.values,
            configurable: true,
            enumerable: true,
            writable: true
        },
        entries: {
            value: globalObject.Array.prototype.entries,
            configurable: true,
            enumerable: true,
            writable: true
        },
        forEach: {
            value: globalObject.Array.prototype.forEach,
            configurable: true,
            enumerable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = DOMTokenList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMTokenList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/DOMTokenList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ShadowRoot.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const DocumentFragment = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DocumentFragment.js [middleware-edge] (ecmascript)");
const interfaceName = "ShadowRoot";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ShadowRoot'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ShadowRoot"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    DocumentFragment._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ShadowRoot extends globalObject.DocumentFragment {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get mode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get mode' called on an object that is not a valid instance of ShadowRoot.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["mode"]);
        }
        get host() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of ShadowRoot.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["host"]);
        }
        get innerHTML() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get innerHTML' called on an object that is not a valid instance of ShadowRoot.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["innerHTML"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set innerHTML(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set innerHTML' called on an object that is not a valid instance of ShadowRoot.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'innerHTML' property on 'ShadowRoot': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["innerHTML"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get activeElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get activeElement' called on an object that is not a valid instance of ShadowRoot.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["activeElement"]);
        }
    }
    Object.defineProperties(ShadowRoot.prototype, {
        mode: {
            enumerable: true
        },
        host: {
            enumerable: true
        },
        innerHTML: {
            enumerable: true
        },
        activeElement: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ShadowRoot",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ShadowRoot;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ShadowRoot
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/ShadowRoot-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ShadowRootMode.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "open",
    "closed"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for ShadowRootMode`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ShadowRootInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ShadowRootMode = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/ShadowRootMode.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "mode";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = ShadowRootMode.convert(globalObject, value, {
                context: context + " has member 'mode' that"
            });
            ret[key] = value;
        } else {
            throw new globalObject.TypeError("mode is required in 'ShadowRootInit'");
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/StyleSheetList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "StyleSheetList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'StyleSheetList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["StyleSheetList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class StyleSheetList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of StyleSheetList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'StyleSheetList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'StyleSheetList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of StyleSheetList.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(StyleSheetList.prototype, {
        item: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "StyleSheetList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = StyleSheetList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: StyleSheetList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/cssom/StyleSheetList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/History.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "History";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'History'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["History"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class History {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        go() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'go' called on an object that is not a valid instance of History.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'go' on 'History': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].go(...args);
        }
        back() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'back' called on an object that is not a valid instance of History.");
            }
            return esValue[implSymbol].back();
        }
        forward() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'forward' called on an object that is not a valid instance of History.");
            }
            return esValue[implSymbol].forward();
        }
        pushState(data, title) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'pushState' called on an object that is not a valid instance of History.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'pushState' on 'History': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["any"](curArg, {
                    context: "Failed to execute 'pushState' on 'History': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'pushState' on 'History': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'pushState' on 'History': parameter 3",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].pushState(...args);
        }
        replaceState(data, title) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceState' called on an object that is not a valid instance of History.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'replaceState' on 'History': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["any"](curArg, {
                    context: "Failed to execute 'replaceState' on 'History': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'replaceState' on 'History': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'replaceState' on 'History': parameter 3",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].replaceState(...args);
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of History.");
            }
            return esValue[implSymbol]["length"];
        }
        get state() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get state' called on an object that is not a valid instance of History.");
            }
            return esValue[implSymbol]["state"];
        }
    }
    Object.defineProperties(History.prototype, {
        go: {
            enumerable: true
        },
        back: {
            enumerable: true
        },
        forward: {
            enumerable: true
        },
        pushState: {
            enumerable: true
        },
        replaceState: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        state: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "History",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = History;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: History
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/window/History-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Location.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Location";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Location'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Location"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
function getUnforgeables(globalObject) {
    let unforgeables = unforgeablesMap.get(globalObject);
    if (unforgeables === undefined) {
        unforgeables = Object.create(null);
        utils.define(unforgeables, {
            assign (url) {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'assign' called on an object that is not a valid instance of Location.");
                }
                if (arguments.length < 1) {
                    throw new globalObject.TypeError(`Failed to execute 'assign' on 'Location': 1 argument required, but only ${arguments.length} present.`);
                }
                const args = [];
                {
                    let curArg = arguments[0];
                    curArg = conversions["USVString"](curArg, {
                        context: "Failed to execute 'assign' on 'Location': parameter 1",
                        globals: globalObject
                    });
                    args.push(curArg);
                }
                return esValue[implSymbol].assign(...args);
            },
            replace (url) {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'replace' called on an object that is not a valid instance of Location.");
                }
                if (arguments.length < 1) {
                    throw new globalObject.TypeError(`Failed to execute 'replace' on 'Location': 1 argument required, but only ${arguments.length} present.`);
                }
                const args = [];
                {
                    let curArg = arguments[0];
                    curArg = conversions["USVString"](curArg, {
                        context: "Failed to execute 'replace' on 'Location': parameter 1",
                        globals: globalObject
                    });
                    args.push(curArg);
                }
                return esValue[implSymbol].replace(...args);
            },
            reload () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'reload' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol].reload();
            },
            get href () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["href"];
            },
            set href (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'href' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["href"] = V;
            },
            toString () {
                const esValue = this;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["href"];
            },
            get origin () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["origin"];
            },
            get protocol () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["protocol"];
            },
            set protocol (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'protocol' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["protocol"] = V;
            },
            get host () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["host"];
            },
            set host (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'host' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["host"] = V;
            },
            get hostname () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["hostname"];
            },
            set hostname (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'hostname' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["hostname"] = V;
            },
            get port () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["port"];
            },
            set port (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'port' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["port"] = V;
            },
            get pathname () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["pathname"];
            },
            set pathname (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'pathname' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["pathname"] = V;
            },
            get search () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["search"];
            },
            set search (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'search' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["search"] = V;
            },
            get hash () {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of Location.");
                }
                return esValue[implSymbol]["hash"];
            },
            set hash (V){
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of Location.");
                }
                V = conversions["USVString"](V, {
                    context: "Failed to set the 'hash' property on 'Location': The provided value",
                    globals: globalObject
                });
                esValue[implSymbol]["hash"] = V;
            }
        });
        Object.defineProperties(unforgeables, {
            assign: {
                configurable: false,
                writable: false
            },
            replace: {
                configurable: false,
                writable: false
            },
            reload: {
                configurable: false,
                writable: false
            },
            href: {
                configurable: false
            },
            toString: {
                configurable: false,
                writable: false
            },
            origin: {
                configurable: false
            },
            protocol: {
                configurable: false
            },
            host: {
                configurable: false
            },
            hostname: {
                configurable: false
            },
            port: {
                configurable: false
            },
            pathname: {
                configurable: false
            },
            search: {
                configurable: false
            },
            hash: {
                configurable: false
            }
        });
        unforgeablesMap.set(globalObject, unforgeables);
    }
    return unforgeables;
}
exports._internalSetup = (wrapper, globalObject)=>{
    utils.define(wrapper, getUnforgeables(globalObject));
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const unforgeablesMap = new WeakMap();
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Location {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(Location.prototype, {
        [Symbol.toStringTag]: {
            value: "Location",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Location;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Location
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/window/Location-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/TreeWalker.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "TreeWalker";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'TreeWalker'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["TreeWalker"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class TreeWalker {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        parentNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'parentNode' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].parentNode());
        }
        firstChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'firstChild' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].firstChild());
        }
        lastChild() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'lastChild' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].lastChild());
        }
        previousSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'previousSibling' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].previousSibling());
        }
        nextSibling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'nextSibling' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].nextSibling());
        }
        previousNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'previousNode' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].previousNode());
        }
        nextNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'nextNode' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].nextNode());
        }
        get root() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get root' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.getSameObject(this, "root", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["root"]);
            });
        }
        get whatToShow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get whatToShow' called on an object that is not a valid instance of TreeWalker.");
            }
            return esValue[implSymbol]["whatToShow"];
        }
        get filter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get filter' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["filter"]);
        }
        get currentNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get currentNode' called on an object that is not a valid instance of TreeWalker.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["currentNode"]);
        }
        set currentNode(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set currentNode' called on an object that is not a valid instance of TreeWalker.");
            }
            V = Node.convert(globalObject, V, {
                context: "Failed to set the 'currentNode' property on 'TreeWalker': The provided value"
            });
            esValue[implSymbol]["currentNode"] = V;
        }
    }
    Object.defineProperties(TreeWalker.prototype, {
        parentNode: {
            enumerable: true
        },
        firstChild: {
            enumerable: true
        },
        lastChild: {
            enumerable: true
        },
        previousSibling: {
            enumerable: true
        },
        nextSibling: {
            enumerable: true
        },
        previousNode: {
            enumerable: true
        },
        nextNode: {
            enumerable: true
        },
        root: {
            enumerable: true
        },
        whatToShow: {
            enumerable: true
        },
        filter: {
            enumerable: true
        },
        currentNode: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "TreeWalker",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = TreeWalker;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: TreeWalker
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/traversal/TreeWalker-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/NodeIterator.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "NodeIterator";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'NodeIterator'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["NodeIterator"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class NodeIterator {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        nextNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'nextNode' called on an object that is not a valid instance of NodeIterator.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].nextNode());
        }
        previousNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'previousNode' called on an object that is not a valid instance of NodeIterator.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].previousNode());
        }
        detach() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'detach' called on an object that is not a valid instance of NodeIterator.");
            }
            return esValue[implSymbol].detach();
        }
        get root() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get root' called on an object that is not a valid instance of NodeIterator.");
            }
            return utils.getSameObject(this, "root", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["root"]);
            });
        }
        get referenceNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get referenceNode' called on an object that is not a valid instance of NodeIterator.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["referenceNode"]);
        }
        get pointerBeforeReferenceNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pointerBeforeReferenceNode' called on an object that is not a valid instance of NodeIterator.");
            }
            return esValue[implSymbol]["pointerBeforeReferenceNode"];
        }
        get whatToShow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get whatToShow' called on an object that is not a valid instance of NodeIterator.");
            }
            return esValue[implSymbol]["whatToShow"];
        }
        get filter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get filter' called on an object that is not a valid instance of NodeIterator.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["filter"]);
        }
    }
    Object.defineProperties(NodeIterator.prototype, {
        nextNode: {
            enumerable: true
        },
        previousNode: {
            enumerable: true
        },
        detach: {
            enumerable: true
        },
        root: {
            enumerable: true
        },
        referenceNode: {
            enumerable: true
        },
        pointerBeforeReferenceNode: {
            enumerable: true
        },
        whatToShow: {
            enumerable: true
        },
        filter: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "NodeIterator",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = NodeIterator;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: NodeIterator
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/traversal/NodeIterator-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/AbstractRange.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "AbstractRange";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'AbstractRange'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["AbstractRange"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class AbstractRange {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get startContainer() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get startContainer' called on an object that is not a valid instance of AbstractRange.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["startContainer"]);
        }
        get startOffset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get startOffset' called on an object that is not a valid instance of AbstractRange.");
            }
            return esValue[implSymbol]["startOffset"];
        }
        get endContainer() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get endContainer' called on an object that is not a valid instance of AbstractRange.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["endContainer"]);
        }
        get endOffset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get endOffset' called on an object that is not a valid instance of AbstractRange.");
            }
            return esValue[implSymbol]["endOffset"];
        }
        get collapsed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get collapsed' called on an object that is not a valid instance of AbstractRange.");
            }
            return esValue[implSymbol]["collapsed"];
        }
    }
    Object.defineProperties(AbstractRange.prototype, {
        startContainer: {
            enumerable: true
        },
        startOffset: {
            enumerable: true
        },
        endContainer: {
            enumerable: true
        },
        endOffset: {
            enumerable: true
        },
        collapsed: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "AbstractRange",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = AbstractRange;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: AbstractRange
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/range/AbstractRange-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Range.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const AbstractRange = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/AbstractRange.js [middleware-edge] (ecmascript)");
const interfaceName = "Range";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Range'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Range"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    AbstractRange._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Range extends globalObject.AbstractRange {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        setStart(node, offset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setStart' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setStart' on 'Range': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setStart' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setStart' on 'Range': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setStart(...args);
        }
        setEnd(node, offset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setEnd' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setEnd' on 'Range': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setEnd' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setEnd' on 'Range': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setEnd(...args);
        }
        setStartBefore(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setStartBefore' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setStartBefore' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setStartBefore' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setStartBefore(...args);
        }
        setStartAfter(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setStartAfter' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setStartAfter' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setStartAfter' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setStartAfter(...args);
        }
        setEndBefore(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setEndBefore' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setEndBefore' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setEndBefore' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setEndBefore(...args);
        }
        setEndAfter(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setEndAfter' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setEndAfter' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setEndAfter' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setEndAfter(...args);
        }
        collapse() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'collapse' called on an object that is not a valid instance of Range.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'collapse' on 'Range': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].collapse(...args);
        }
        selectNode(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'selectNode' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'selectNode' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'selectNode' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].selectNode(...args);
        }
        selectNodeContents(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'selectNodeContents' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'selectNodeContents' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'selectNodeContents' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].selectNodeContents(...args);
        }
        compareBoundaryPoints(how, sourceRange) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'compareBoundaryPoints' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'compareBoundaryPoints' on 'Range': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned short"](curArg, {
                    context: "Failed to execute 'compareBoundaryPoints' on 'Range': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = exports.convert(globalObject, curArg, {
                    context: "Failed to execute 'compareBoundaryPoints' on 'Range': parameter 2"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].compareBoundaryPoints(...args);
        }
        deleteContents() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteContents' called on an object that is not a valid instance of Range.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteContents();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        extractContents() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'extractContents' called on an object that is not a valid instance of Range.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].extractContents());
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        cloneContents() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'cloneContents' called on an object that is not a valid instance of Range.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].cloneContents());
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        insertNode(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertNode' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'insertNode' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'insertNode' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].insertNode(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        surroundContents(newParent) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'surroundContents' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'surroundContents' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'surroundContents' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].surroundContents(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        cloneRange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'cloneRange' called on an object that is not a valid instance of Range.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].cloneRange());
        }
        detach() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'detach' called on an object that is not a valid instance of Range.");
            }
            return esValue[implSymbol].detach();
        }
        isPointInRange(node, offset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'isPointInRange' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'isPointInRange' on 'Range': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'isPointInRange' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'isPointInRange' on 'Range': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].isPointInRange(...args);
        }
        comparePoint(node, offset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'comparePoint' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'comparePoint' on 'Range': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'comparePoint' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'comparePoint' on 'Range': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].comparePoint(...args);
        }
        intersectsNode(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'intersectsNode' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'intersectsNode' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'intersectsNode' on 'Range': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].intersectsNode(...args);
        }
        toString() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of Range.");
            }
            return esValue[implSymbol].toString();
        }
        createContextualFragment(fragment) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createContextualFragment' called on an object that is not a valid instance of Range.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'createContextualFragment' on 'Range': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'createContextualFragment' on 'Range': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol].createContextualFragment(...args));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get commonAncestorContainer() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get commonAncestorContainer' called on an object that is not a valid instance of Range.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["commonAncestorContainer"]);
        }
    }
    Object.defineProperties(Range.prototype, {
        setStart: {
            enumerable: true
        },
        setEnd: {
            enumerable: true
        },
        setStartBefore: {
            enumerable: true
        },
        setStartAfter: {
            enumerable: true
        },
        setEndBefore: {
            enumerable: true
        },
        setEndAfter: {
            enumerable: true
        },
        collapse: {
            enumerable: true
        },
        selectNode: {
            enumerable: true
        },
        selectNodeContents: {
            enumerable: true
        },
        compareBoundaryPoints: {
            enumerable: true
        },
        deleteContents: {
            enumerable: true
        },
        extractContents: {
            enumerable: true
        },
        cloneContents: {
            enumerable: true
        },
        insertNode: {
            enumerable: true
        },
        surroundContents: {
            enumerable: true
        },
        cloneRange: {
            enumerable: true
        },
        detach: {
            enumerable: true
        },
        isPointInRange: {
            enumerable: true
        },
        comparePoint: {
            enumerable: true
        },
        intersectsNode: {
            enumerable: true
        },
        toString: {
            enumerable: true
        },
        createContextualFragment: {
            enumerable: true
        },
        commonAncestorContainer: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Range",
            configurable: true
        },
        START_TO_START: {
            value: 0,
            enumerable: true
        },
        START_TO_END: {
            value: 1,
            enumerable: true
        },
        END_TO_END: {
            value: 2,
            enumerable: true
        },
        END_TO_START: {
            value: 3,
            enumerable: true
        }
    });
    Object.defineProperties(Range, {
        START_TO_START: {
            value: 0,
            enumerable: true
        },
        START_TO_END: {
            value: 1,
            enumerable: true
        },
        END_TO_END: {
            value: 2,
            enumerable: true
        },
        END_TO_START: {
            value: 3,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = Range;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Range
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "detail";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["any"](value, {
                context: context + " has member 'detail' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const CustomEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "CustomEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CustomEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CustomEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CustomEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'CustomEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'CustomEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = CustomEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'CustomEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        initCustomEvent(type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initCustomEvent' called on an object that is not a valid instance of CustomEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initCustomEvent' on 'CustomEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initCustomEvent' on 'CustomEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initCustomEvent' on 'CustomEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initCustomEvent' on 'CustomEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'initCustomEvent' on 'CustomEvent': parameter 4",
                        globals: globalObject
                    });
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initCustomEvent(...args);
        }
        get detail() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get detail' called on an object that is not a valid instance of CustomEvent.");
            }
            return esValue[implSymbol]["detail"];
        }
    }
    Object.defineProperties(CustomEvent.prototype, {
        initCustomEvent: {
            enumerable: true
        },
        detail: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "CustomEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CustomEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CustomEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/CustomEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FocusEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const UIEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    UIEventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "relatedTarget";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = EventTarget.convert(globalObject, value, {
                    context: context + " has member 'relatedTarget' that"
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FocusEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const FocusEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/FocusEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "FocusEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'FocusEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["FocusEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class FocusEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'FocusEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'FocusEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = FocusEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'FocusEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get relatedTarget() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get relatedTarget' called on an object that is not a valid instance of FocusEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["relatedTarget"]);
        }
    }
    Object.defineProperties(FocusEvent.prototype, {
        relatedTarget: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "FocusEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = FocusEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: FocusEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/FocusEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HashChangeEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "newURL";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'newURL' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "oldURL";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'oldURL' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HashChangeEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HashChangeEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HashChangeEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "HashChangeEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HashChangeEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HashChangeEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HashChangeEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'HashChangeEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'HashChangeEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = HashChangeEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'HashChangeEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get oldURL() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oldURL' called on an object that is not a valid instance of HashChangeEvent.");
            }
            return esValue[implSymbol]["oldURL"];
        }
        get newURL() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get newURL' called on an object that is not a valid instance of HashChangeEvent.");
            }
            return esValue[implSymbol]["newURL"];
        }
    }
    Object.defineProperties(HashChangeEvent.prototype, {
        oldURL: {
            enumerable: true
        },
        newURL: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HashChangeEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HashChangeEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HashChangeEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/HashChangeEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/KeyboardEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventModifierInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventModifierInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventModifierInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "charCode";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'charCode' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "code";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'code' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "isComposing";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'isComposing' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "key";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'key' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "keyCode";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'keyCode' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "location";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'location' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "repeat";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'repeat' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/KeyboardEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const KeyboardEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/KeyboardEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "KeyboardEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'KeyboardEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["KeyboardEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class KeyboardEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'KeyboardEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'KeyboardEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = KeyboardEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'KeyboardEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        getModifierState(keyArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getModifierState' called on an object that is not a valid instance of KeyboardEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getModifierState' on 'KeyboardEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getModifierState' on 'KeyboardEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].getModifierState(...args);
        }
        initKeyboardEvent(typeArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initKeyboardEvent' called on an object that is not a valid instance of KeyboardEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = utils.tryImplForWrapper(curArg);
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 5",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[5];
                if (curArg !== undefined) {
                    curArg = conversions["unsigned long"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 6",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[6];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 7",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[7];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 8",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[8];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 9",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[9];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': parameter 10",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initKeyboardEvent(...args);
        }
        get key() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get key' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["key"];
        }
        get code() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get code' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["code"];
        }
        get location() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get location' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["location"];
        }
        get ctrlKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ctrlKey' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["ctrlKey"];
        }
        get shiftKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shiftKey' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["shiftKey"];
        }
        get altKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get altKey' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["altKey"];
        }
        get metaKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get metaKey' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["metaKey"];
        }
        get repeat() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get repeat' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["repeat"];
        }
        get isComposing() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get isComposing' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["isComposing"];
        }
        get charCode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get charCode' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["charCode"];
        }
        get keyCode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get keyCode' called on an object that is not a valid instance of KeyboardEvent.");
            }
            return esValue[implSymbol]["keyCode"];
        }
    }
    Object.defineProperties(KeyboardEvent.prototype, {
        getModifierState: {
            enumerable: true
        },
        initKeyboardEvent: {
            enumerable: true
        },
        key: {
            enumerable: true
        },
        code: {
            enumerable: true
        },
        location: {
            enumerable: true
        },
        ctrlKey: {
            enumerable: true
        },
        shiftKey: {
            enumerable: true
        },
        altKey: {
            enumerable: true
        },
        metaKey: {
            enumerable: true
        },
        repeat: {
            enumerable: true
        },
        isComposing: {
            enumerable: true
        },
        charCode: {
            enumerable: true
        },
        keyCode: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "KeyboardEvent",
            configurable: true
        },
        DOM_KEY_LOCATION_STANDARD: {
            value: 0x00,
            enumerable: true
        },
        DOM_KEY_LOCATION_LEFT: {
            value: 0x01,
            enumerable: true
        },
        DOM_KEY_LOCATION_RIGHT: {
            value: 0x02,
            enumerable: true
        },
        DOM_KEY_LOCATION_NUMPAD: {
            value: 0x03,
            enumerable: true
        }
    });
    Object.defineProperties(KeyboardEvent, {
        DOM_KEY_LOCATION_STANDARD: {
            value: 0x00,
            enumerable: true
        },
        DOM_KEY_LOCATION_LEFT: {
            value: 0x01,
            enumerable: true
        },
        DOM_KEY_LOCATION_RIGHT: {
            value: 0x02,
            enumerable: true
        },
        DOM_KEY_LOCATION_NUMPAD: {
            value: 0x03,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = KeyboardEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: KeyboardEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/KeyboardEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MessageEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "data";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["any"](value, {
                context: context + " has member 'data' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "lastEventId";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'lastEventId' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "origin";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'origin' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "ports";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (!utils.isObject(value)) {
                throw new globalObject.TypeError(context + " has member 'ports' that" + " is not an iterable object.");
            } else {
                const V = [];
                const tmp = value;
                for (let nextItem of tmp){
                    nextItem = utils.tryImplForWrapper(nextItem);
                    V.push(nextItem);
                }
                value = V;
            }
            ret[key] = value;
        } else {
            ret[key] = [];
        }
    }
    {
        const key = "source";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = utils.tryImplForWrapper(value);
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MessageEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const MessageEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MessageEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "MessageEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MessageEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MessageEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker",
    "AudioWorklet"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MessageEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'MessageEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'MessageEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = MessageEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'MessageEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        initMessageEvent(type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initMessageEvent' called on an object that is not a valid instance of MessageEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initMessageEvent' on 'MessageEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 4",
                        globals: globalObject
                    });
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    curArg = conversions["USVString"](curArg, {
                        context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 5",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[5];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 6",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[6];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = utils.tryImplForWrapper(curArg);
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[7];
                if (curArg !== undefined) {
                    if (!utils.isObject(curArg)) {
                        throw new globalObject.TypeError("Failed to execute 'initMessageEvent' on 'MessageEvent': parameter 8" + " is not an iterable object.");
                    } else {
                        const V = [];
                        const tmp = curArg;
                        for (let nextItem of tmp){
                            nextItem = utils.tryImplForWrapper(nextItem);
                            V.push(nextItem);
                        }
                        curArg = V;
                    }
                } else {
                    curArg = [];
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initMessageEvent(...args);
        }
        get data() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get data' called on an object that is not a valid instance of MessageEvent.");
            }
            return esValue[implSymbol]["data"];
        }
        get origin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of MessageEvent.");
            }
            return esValue[implSymbol]["origin"];
        }
        get lastEventId() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lastEventId' called on an object that is not a valid instance of MessageEvent.");
            }
            return esValue[implSymbol]["lastEventId"];
        }
        get source() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get source' called on an object that is not a valid instance of MessageEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["source"]);
        }
        get ports() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ports' called on an object that is not a valid instance of MessageEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ports"]);
        }
    }
    Object.defineProperties(MessageEvent.prototype, {
        initMessageEvent: {
            enumerable: true
        },
        data: {
            enumerable: true
        },
        origin: {
            enumerable: true
        },
        lastEventId: {
            enumerable: true
        },
        source: {
            enumerable: true
        },
        ports: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MessageEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = MessageEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MessageEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/MessageEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/PopStateEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "state";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["any"](value, {
                context: context + " has member 'state' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/PopStateEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const PopStateEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/PopStateEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "PopStateEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'PopStateEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["PopStateEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class PopStateEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'PopStateEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'PopStateEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = PopStateEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'PopStateEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get state() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get state' called on an object that is not a valid instance of PopStateEvent.");
            }
            return esValue[implSymbol]["state"];
        }
    }
    Object.defineProperties(PopStateEvent.prototype, {
        state: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "PopStateEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = PopStateEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: PopStateEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/PopStateEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ProgressEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "lengthComputable";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'lengthComputable' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "loaded";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long long"](value, {
                context: context + " has member 'loaded' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "total";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long long"](value, {
                context: context + " has member 'total' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ProgressEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ProgressEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/ProgressEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "ProgressEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ProgressEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ProgressEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "DedicatedWorker",
    "SharedWorker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ProgressEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'ProgressEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'ProgressEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = ProgressEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'ProgressEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get lengthComputable() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lengthComputable' called on an object that is not a valid instance of ProgressEvent.");
            }
            return esValue[implSymbol]["lengthComputable"];
        }
        get loaded() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get loaded' called on an object that is not a valid instance of ProgressEvent.");
            }
            return esValue[implSymbol]["loaded"];
        }
        get total() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get total' called on an object that is not a valid instance of ProgressEvent.");
            }
            return esValue[implSymbol]["total"];
        }
    }
    Object.defineProperties(ProgressEvent.prototype, {
        lengthComputable: {
            enumerable: true
        },
        loaded: {
            enumerable: true
        },
        total: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ProgressEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ProgressEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ProgressEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/ProgressEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/TouchEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventModifierInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventModifierInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventModifierInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "changedTouches";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (!utils.isObject(value)) {
                throw new globalObject.TypeError(context + " has member 'changedTouches' that" + " is not an iterable object.");
            } else {
                const V = [];
                const tmp = value;
                for (let nextItem of tmp){
                    nextItem = utils.tryImplForWrapper(nextItem);
                    V.push(nextItem);
                }
                value = V;
            }
            ret[key] = value;
        } else {
            ret[key] = [];
        }
    }
    {
        const key = "targetTouches";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (!utils.isObject(value)) {
                throw new globalObject.TypeError(context + " has member 'targetTouches' that" + " is not an iterable object.");
            } else {
                const V = [];
                const tmp = value;
                for (let nextItem of tmp){
                    nextItem = utils.tryImplForWrapper(nextItem);
                    V.push(nextItem);
                }
                value = V;
            }
            ret[key] = value;
        } else {
            ret[key] = [];
        }
    }
    {
        const key = "touches";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (!utils.isObject(value)) {
                throw new globalObject.TypeError(context + " has member 'touches' that" + " is not an iterable object.");
            } else {
                const V = [];
                const tmp = value;
                for (let nextItem of tmp){
                    nextItem = utils.tryImplForWrapper(nextItem);
                    V.push(nextItem);
                }
                value = V;
            }
            ret[key] = value;
        } else {
            ret[key] = [];
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/TouchEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const TouchEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/TouchEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "TouchEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'TouchEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["TouchEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class TouchEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'TouchEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'TouchEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = TouchEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'TouchEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get touches() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get touches' called on an object that is not a valid instance of TouchEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["touches"]);
        }
        get targetTouches() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get targetTouches' called on an object that is not a valid instance of TouchEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["targetTouches"]);
        }
        get changedTouches() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get changedTouches' called on an object that is not a valid instance of TouchEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["changedTouches"]);
        }
        get altKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get altKey' called on an object that is not a valid instance of TouchEvent.");
            }
            return esValue[implSymbol]["altKey"];
        }
        get metaKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get metaKey' called on an object that is not a valid instance of TouchEvent.");
            }
            return esValue[implSymbol]["metaKey"];
        }
        get ctrlKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ctrlKey' called on an object that is not a valid instance of TouchEvent.");
            }
            return esValue[implSymbol]["ctrlKey"];
        }
        get shiftKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shiftKey' called on an object that is not a valid instance of TouchEvent.");
            }
            return esValue[implSymbol]["shiftKey"];
        }
    }
    Object.defineProperties(TouchEvent.prototype, {
        touches: {
            enumerable: true
        },
        targetTouches: {
            enumerable: true
        },
        changedTouches: {
            enumerable: true
        },
        altKey: {
            enumerable: true
        },
        metaKey: {
            enumerable: true
        },
        ctrlKey: {
            enumerable: true
        },
        shiftKey: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "TouchEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = TouchEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: TouchEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/TouchEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ElementCreationOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "is";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'is' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/NodeFilter.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (!utils.isObject(value)) {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    function callTheUserObjectsOperation(node) {
        let thisArg = utils.tryWrapperForImpl(this);
        let O = value;
        let X = O;
        if (typeof O !== "function") {
            X = O["acceptNode"];
            if (typeof X !== "function") {
                throw new globalObject.TypeError(`${context} does not correctly implement NodeFilter.`);
            }
            thisArg = O;
        }
        node = utils.tryWrapperForImpl(node);
        let callResult = Reflect.apply(X, thisArg, [
            node
        ]);
        callResult = conversions["unsigned short"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    }
    callTheUserObjectsOperation[utils.wrapperSymbol] = value;
    callTheUserObjectsOperation.objectReference = value;
    return callTheUserObjectsOperation;
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    const NodeFilter = ()=>{
        throw new globalObject.TypeError("Illegal invocation");
    };
    Object.defineProperties(NodeFilter, {
        FILTER_ACCEPT: {
            value: 1,
            enumerable: true
        },
        FILTER_REJECT: {
            value: 2,
            enumerable: true
        },
        FILTER_SKIP: {
            value: 3,
            enumerable: true
        },
        SHOW_ALL: {
            value: 0xffffffff,
            enumerable: true
        },
        SHOW_ELEMENT: {
            value: 0x1,
            enumerable: true
        },
        SHOW_ATTRIBUTE: {
            value: 0x2,
            enumerable: true
        },
        SHOW_TEXT: {
            value: 0x4,
            enumerable: true
        },
        SHOW_CDATA_SECTION: {
            value: 0x8,
            enumerable: true
        },
        SHOW_ENTITY_REFERENCE: {
            value: 0x10,
            enumerable: true
        },
        SHOW_ENTITY: {
            value: 0x20,
            enumerable: true
        },
        SHOW_PROCESSING_INSTRUCTION: {
            value: 0x40,
            enumerable: true
        },
        SHOW_COMMENT: {
            value: 0x80,
            enumerable: true
        },
        SHOW_DOCUMENT: {
            value: 0x100,
            enumerable: true
        },
        SHOW_DOCUMENT_TYPE: {
            value: 0x200,
            enumerable: true
        },
        SHOW_DOCUMENT_FRAGMENT: {
            value: 0x400,
            enumerable: true
        },
        SHOW_NOTATION: {
            value: 0x800,
            enumerable: true
        }
    });
    Object.defineProperty(globalObject, "NodeFilter", {
        configurable: true,
        writable: true,
        value: NodeFilter
    });
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ElementInternals.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "ElementInternals";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ElementInternals'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ElementInternals"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ElementInternals {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get shadowRoot() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shadowRoot' called on an object that is not a valid instance of ElementInternals.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["shadowRoot"]);
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of ElementInternals.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
        get role() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get role' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("role");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set role(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set role' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'role' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("role");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("role", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaAtomic() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaAtomic' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-atomic");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaAtomic(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaAtomic' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaAtomic' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-atomic");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-atomic", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaAutoComplete() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaAutoComplete' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-autocomplete");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaAutoComplete(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaAutoComplete' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaAutoComplete' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-autocomplete");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-autocomplete", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaBusy() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaBusy' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-busy");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaBusy(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaBusy' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaBusy' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-busy");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-busy", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaChecked() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaChecked' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-checked");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaChecked(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaChecked' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaChecked' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-checked");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-checked", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaColCount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaColCount' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-colcount");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaColCount(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaColCount' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaColCount' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-colcount");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-colcount", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaColIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaColIndex' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-colindex");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaColIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaColIndex' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaColIndex' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-colindex");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-colindex", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaColIndexText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaColIndexText' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-colindextext");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaColIndexText(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaColIndexText' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaColIndexText' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-colindextext");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-colindextext", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaColSpan() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaColSpan' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-colspan");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaColSpan(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaColSpan' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaColSpan' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-colspan");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-colspan", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaCurrent() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaCurrent' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-current");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaCurrent(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaCurrent' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaCurrent' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-current");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-current", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaDescription() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaDescription' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-description");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaDescription(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaDescription' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaDescription' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-description");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-description", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaDisabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaDisabled' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-disabled");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaDisabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaDisabled' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaDisabled' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-disabled");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-disabled", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaExpanded() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaExpanded' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-expanded");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaExpanded(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaExpanded' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaExpanded' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-expanded");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-expanded", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaHasPopup() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaHasPopup' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-haspopup");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaHasPopup(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaHasPopup' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaHasPopup' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-haspopup");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-haspopup", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaHidden() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaHidden' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-hidden");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaHidden(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaHidden' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaHidden' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-hidden");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-hidden", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaInvalid() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaInvalid' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-invalid");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaInvalid(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaInvalid' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaInvalid' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-invalid");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-invalid", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaKeyShortcuts() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaKeyShortcuts' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-keyshortcuts");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaKeyShortcuts(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaKeyShortcuts' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaKeyShortcuts' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-keyshortcuts");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-keyshortcuts", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaLabel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaLabel' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-label");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaLabel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaLabel' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaLabel' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-label");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-label", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaLevel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaLevel' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-level");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaLevel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaLevel' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaLevel' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-level");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-level", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaLive() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaLive' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-live");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaLive(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaLive' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaLive' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-live");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-live", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaModal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaModal' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-modal");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaModal(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaModal' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaModal' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-modal");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-modal", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaMultiLine() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaMultiLine' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-multiline");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaMultiLine(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaMultiLine' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaMultiLine' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-multiline");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-multiline", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaMultiSelectable() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaMultiSelectable' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-multiselectable");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaMultiSelectable(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaMultiSelectable' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaMultiSelectable' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-multiselectable");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-multiselectable", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaOrientation() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaOrientation' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-orientation");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaOrientation(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaOrientation' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaOrientation' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-orientation");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-orientation", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaPlaceholder() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaPlaceholder' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-placeholder");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaPlaceholder(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaPlaceholder' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaPlaceholder' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-placeholder");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-placeholder", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaPosInSet() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaPosInSet' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-posinset");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaPosInSet(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaPosInSet' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaPosInSet' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-posinset");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-posinset", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaPressed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaPressed' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-pressed");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaPressed(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaPressed' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaPressed' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-pressed");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-pressed", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaReadOnly() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaReadOnly' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-readonly");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaReadOnly(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaReadOnly' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaReadOnly' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-readonly");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-readonly", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRequired() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRequired' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-required");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRequired(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRequired' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRequired' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-required");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-required", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRoleDescription() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRoleDescription' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-roledescription");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRoleDescription(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRoleDescription' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRoleDescription' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-roledescription");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-roledescription", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRowCount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRowCount' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-rowcount");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRowCount(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRowCount' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRowCount' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-rowcount");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-rowcount", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRowIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRowIndex' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-rowindex");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRowIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRowIndex' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRowIndex' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-rowindex");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-rowindex", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRowIndexText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRowIndexText' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-rowindextext");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRowIndexText(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRowIndexText' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRowIndexText' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-rowindextext");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-rowindextext", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRowSpan() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRowSpan' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-rowspan");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRowSpan(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRowSpan' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRowSpan' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-rowspan");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-rowspan", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaSelected() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaSelected' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-selected");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaSelected(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaSelected' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaSelected' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-selected");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-selected", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaSetSize() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaSetSize' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-setsize");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaSetSize(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaSetSize' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaSetSize' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-setsize");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-setsize", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaSort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaSort' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-sort");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaSort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaSort' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaSort' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-sort");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-sort", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaValueMax() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaValueMax' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-valuemax");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaValueMax(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaValueMax' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaValueMax' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-valuemax");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-valuemax", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaValueMin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaValueMin' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-valuemin");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaValueMin(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaValueMin' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaValueMin' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-valuemin");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-valuemin", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaValueNow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaValueNow' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-valuenow");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaValueNow(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaValueNow' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaValueNow' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-valuenow");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-valuenow", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaValueText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaValueText' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-valuetext");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaValueText(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaValueText' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaValueText' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-valuetext");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-valuetext", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ariaRelevant() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ariaRelevant' called on an object that is not a valid instance of ElementInternals.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("aria-relevant");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ariaRelevant(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ariaRelevant' called on an object that is not a valid instance of ElementInternals.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'ariaRelevant' property on 'ElementInternals': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("aria-relevant");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("aria-relevant", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(ElementInternals.prototype, {
        shadowRoot: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        role: {
            enumerable: true
        },
        ariaAtomic: {
            enumerable: true
        },
        ariaAutoComplete: {
            enumerable: true
        },
        ariaBusy: {
            enumerable: true
        },
        ariaChecked: {
            enumerable: true
        },
        ariaColCount: {
            enumerable: true
        },
        ariaColIndex: {
            enumerable: true
        },
        ariaColIndexText: {
            enumerable: true
        },
        ariaColSpan: {
            enumerable: true
        },
        ariaCurrent: {
            enumerable: true
        },
        ariaDescription: {
            enumerable: true
        },
        ariaDisabled: {
            enumerable: true
        },
        ariaExpanded: {
            enumerable: true
        },
        ariaHasPopup: {
            enumerable: true
        },
        ariaHidden: {
            enumerable: true
        },
        ariaInvalid: {
            enumerable: true
        },
        ariaKeyShortcuts: {
            enumerable: true
        },
        ariaLabel: {
            enumerable: true
        },
        ariaLevel: {
            enumerable: true
        },
        ariaLive: {
            enumerable: true
        },
        ariaModal: {
            enumerable: true
        },
        ariaMultiLine: {
            enumerable: true
        },
        ariaMultiSelectable: {
            enumerable: true
        },
        ariaOrientation: {
            enumerable: true
        },
        ariaPlaceholder: {
            enumerable: true
        },
        ariaPosInSet: {
            enumerable: true
        },
        ariaPressed: {
            enumerable: true
        },
        ariaReadOnly: {
            enumerable: true
        },
        ariaRequired: {
            enumerable: true
        },
        ariaRoleDescription: {
            enumerable: true
        },
        ariaRowCount: {
            enumerable: true
        },
        ariaRowIndex: {
            enumerable: true
        },
        ariaRowIndexText: {
            enumerable: true
        },
        ariaRowSpan: {
            enumerable: true
        },
        ariaSelected: {
            enumerable: true
        },
        ariaSetSize: {
            enumerable: true
        },
        ariaSort: {
            enumerable: true
        },
        ariaValueMax: {
            enumerable: true
        },
        ariaValueMin: {
            enumerable: true
        },
        ariaValueNow: {
            enumerable: true
        },
        ariaValueText: {
            enumerable: true
        },
        ariaRelevant: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ElementInternals",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ElementInternals;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ElementInternals
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/custom-elements/ElementInternals-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMStringMap.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMStringMap";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMStringMap'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMStringMap"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMStringMap {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(DOMStringMap.prototype, {
        [Symbol.toStringTag]: {
            value: "DOMStringMap",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = DOMStringMap;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMStringMap
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!utils.hasOwn(target, key)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        const namedValue = target[implSymbol][utils.namedGet](P);
        if (namedValue !== undefined && !utils.hasOwn(target, P) && !ignoreNamedProps) {
            return {
                writable: true,
                enumerable: true,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
            if (typeof P === "string") {
                let namedValue = V;
                namedValue = conversions["DOMString"](namedValue, {
                    context: "Failed to set the '" + P + "' property on 'DOMStringMap': The provided value",
                    globals: globalObject
                });
                ceReactionsPreSteps_helpers_custom_elements(globalObject);
                try {
                    const creating = !(target[implSymbol][utils.namedGet](P) !== undefined);
                    if (creating) {
                        target[implSymbol][utils.namedSetNew](P, namedValue);
                    } else {
                        target[implSymbol][utils.namedSetExisting](P, namedValue);
                    }
                } finally{
                    ceReactionsPostSteps_helpers_custom_elements(globalObject);
                }
                return true;
            }
        }
        let ownDesc;
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (desc.get || desc.set) {
            return false;
        }
        let namedValue = desc.value;
        namedValue = conversions["DOMString"](namedValue, {
            context: "Failed to set the '" + P + "' property on 'DOMStringMap': The provided value",
            globals: globalObject
        });
        ceReactionsPreSteps_helpers_custom_elements(globalObject);
        try {
            const creating = !(target[implSymbol][utils.namedGet](P) !== undefined);
            if (creating) {
                target[implSymbol][utils.namedSetNew](P, namedValue);
            } else {
                target[implSymbol][utils.namedSetExisting](P, namedValue);
            }
        } finally{
            ceReactionsPostSteps_helpers_custom_elements(globalObject);
        }
        return true;
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (target[implSymbol][utils.namedGet](P) !== undefined && !utils.hasOwn(target, P)) {
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                target[implSymbol][utils.namedDelete](P);
                return true;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/DOMStringMap-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const OnErrorEventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/OnErrorEventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Element = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Element.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Element._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLElement extends globalObject.Element {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        click() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'click' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol].click();
        }
        attachInternals() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'attachInternals' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].attachInternals());
        }
        focus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'focus' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol].focus();
        }
        blur() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'blur' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol].blur();
        }
        get title() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get title' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("title");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set title(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set title' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'title' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("title", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get lang() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lang' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("lang");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set lang(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set lang' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'lang' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("lang", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get translate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get translate' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["translate"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set translate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set translate' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'translate' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["translate"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get dir() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dir' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["dir"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set dir(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set dir' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'dir' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["dir"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hidden() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hidden' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("hidden") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hidden(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hidden' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'hidden' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("hidden", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("hidden");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get accessKey() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get accessKey' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("accesskey");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set accessKey(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set accessKey' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'accessKey' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("accesskey", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get draggable() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get draggable' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["draggable"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set draggable(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set draggable' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'draggable' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["draggable"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get offsetParent() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetParent' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["offsetParent"]);
        }
        get offsetTop() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetTop' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol]["offsetTop"];
        }
        get offsetLeft() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetLeft' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol]["offsetLeft"];
        }
        get offsetWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetWidth' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol]["offsetWidth"];
        }
        get offsetHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get offsetHeight' called on an object that is not a valid instance of HTMLElement.");
            }
            return esValue[implSymbol]["offsetHeight"];
        }
        get style() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get style' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.getSameObject(this, "style", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["style"]);
            });
        }
        set style(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set style' called on an object that is not a valid instance of HTMLElement.");
            }
            const Q = esValue["style"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'style' is not an object");
            }
            Reflect.set(Q, "cssText", V);
        }
        get onabort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onabort' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onabort"]);
        }
        set onabort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onabort' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onabort' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onabort"] = V;
        }
        get onauxclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onauxclick' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onauxclick"]);
        }
        set onauxclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onauxclick' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onauxclick' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onauxclick"] = V;
        }
        get onbeforeinput() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeinput' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeinput"]);
        }
        set onbeforeinput(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeinput' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeinput' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeinput"] = V;
        }
        get onbeforematch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforematch' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforematch"]);
        }
        set onbeforematch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforematch' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforematch' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforematch"] = V;
        }
        get onbeforetoggle() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforetoggle' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforetoggle"]);
        }
        set onbeforetoggle(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforetoggle' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforetoggle' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforetoggle"] = V;
        }
        get onblur() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onblur' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onblur"]);
        }
        set onblur(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onblur' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onblur' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onblur"] = V;
        }
        get oncancel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncancel' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncancel"]);
        }
        set oncancel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncancel' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncancel' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncancel"] = V;
        }
        get oncanplay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncanplay' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncanplay"]);
        }
        set oncanplay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncanplay' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncanplay' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncanplay"] = V;
        }
        get oncanplaythrough() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncanplaythrough' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncanplaythrough"]);
        }
        set oncanplaythrough(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncanplaythrough' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncanplaythrough' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncanplaythrough"] = V;
        }
        get onchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onchange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onchange"]);
        }
        set onchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onchange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onchange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onchange"] = V;
        }
        get onclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onclick' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onclick"]);
        }
        set onclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onclick' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onclick' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onclick"] = V;
        }
        get onclose() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onclose' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onclose"]);
        }
        set onclose(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onclose' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onclose' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onclose"] = V;
        }
        get oncontextlost() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextlost' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextlost"]);
        }
        set oncontextlost(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextlost' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextlost' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextlost"] = V;
        }
        get oncontextmenu() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextmenu' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextmenu"]);
        }
        set oncontextmenu(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextmenu' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextmenu' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextmenu"] = V;
        }
        get oncontextrestored() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextrestored' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextrestored"]);
        }
        set oncontextrestored(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextrestored' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextrestored' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextrestored"] = V;
        }
        get oncopy() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncopy' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncopy"]);
        }
        set oncopy(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncopy' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncopy' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncopy"] = V;
        }
        get oncuechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncuechange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncuechange"]);
        }
        set oncuechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncuechange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncuechange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncuechange"] = V;
        }
        get oncut() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncut' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncut"]);
        }
        set oncut(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncut' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncut' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oncut"] = V;
        }
        get ondblclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondblclick' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondblclick"]);
        }
        set ondblclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondblclick' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondblclick' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondblclick"] = V;
        }
        get ondrag() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondrag' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondrag"]);
        }
        set ondrag(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondrag' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondrag' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondrag"] = V;
        }
        get ondragend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragend"]);
        }
        set ondragend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragend"] = V;
        }
        get ondragenter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragenter' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragenter"]);
        }
        set ondragenter(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragenter' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragenter' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragenter"] = V;
        }
        get ondragleave() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragleave' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragleave"]);
        }
        set ondragleave(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragleave' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragleave' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragleave"] = V;
        }
        get ondragover() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragover' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragover"]);
        }
        set ondragover(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragover' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragover' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragover"] = V;
        }
        get ondragstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragstart' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragstart"]);
        }
        set ondragstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragstart' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragstart' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragstart"] = V;
        }
        get ondrop() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondrop' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondrop"]);
        }
        set ondrop(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondrop' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondrop' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondrop"] = V;
        }
        get ondurationchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondurationchange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondurationchange"]);
        }
        set ondurationchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondurationchange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondurationchange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ondurationchange"] = V;
        }
        get onemptied() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onemptied' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onemptied"]);
        }
        set onemptied(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onemptied' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onemptied' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onemptied"] = V;
        }
        get onended() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onended' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onended"]);
        }
        set onended(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onended' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onended' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onended"] = V;
        }
        get onerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onerror' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onerror"]);
        }
        set onerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onerror' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = OnErrorEventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onerror' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onerror"] = V;
        }
        get onfocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onfocus' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onfocus"]);
        }
        set onfocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onfocus' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onfocus' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onfocus"] = V;
        }
        get onformdata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onformdata' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onformdata"]);
        }
        set onformdata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onformdata' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onformdata' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onformdata"] = V;
        }
        get oninput() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oninput' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oninput"]);
        }
        set oninput(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oninput' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oninput' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oninput"] = V;
        }
        get oninvalid() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oninvalid' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oninvalid"]);
        }
        set oninvalid(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oninvalid' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oninvalid' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["oninvalid"] = V;
        }
        get onkeydown() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeydown' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeydown"]);
        }
        set onkeydown(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeydown' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeydown' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeydown"] = V;
        }
        get onkeypress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeypress' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeypress"]);
        }
        set onkeypress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeypress' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeypress' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeypress"] = V;
        }
        get onkeyup() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeyup' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeyup"]);
        }
        set onkeyup(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeyup' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeyup' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeyup"] = V;
        }
        get onload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onload' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onload"]);
        }
        set onload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onload' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onload' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onload"] = V;
        }
        get onloadeddata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadeddata' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadeddata"]);
        }
        set onloadeddata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadeddata' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadeddata' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadeddata"] = V;
        }
        get onloadedmetadata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadedmetadata' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadedmetadata"]);
        }
        set onloadedmetadata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadedmetadata' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadedmetadata' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadedmetadata"] = V;
        }
        get onloadstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadstart' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadstart"]);
        }
        set onloadstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadstart' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadstart' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadstart"] = V;
        }
        get onmousedown() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmousedown' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmousedown"]);
        }
        set onmousedown(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmousedown' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmousedown' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmousedown"] = V;
        }
        get onmouseenter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseenter"]);
        }
        set onmouseenter(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseenter' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseenter"] = V;
        }
        get onmouseleave() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseleave"]);
        }
        set onmouseleave(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseleave' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseleave"] = V;
        }
        get onmousemove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmousemove' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmousemove"]);
        }
        set onmousemove(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmousemove' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmousemove' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmousemove"] = V;
        }
        get onmouseout() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseout' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseout"]);
        }
        set onmouseout(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseout' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseout' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseout"] = V;
        }
        get onmouseover() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseover' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseover"]);
        }
        set onmouseover(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseover' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseover' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseover"] = V;
        }
        get onmouseup() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseup' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseup"]);
        }
        set onmouseup(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseup' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseup' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseup"] = V;
        }
        get onpaste() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpaste' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpaste"]);
        }
        set onpaste(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpaste' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpaste' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onpaste"] = V;
        }
        get onpause() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpause' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpause"]);
        }
        set onpause(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpause' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpause' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onpause"] = V;
        }
        get onplay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onplay' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onplay"]);
        }
        set onplay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onplay' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onplay' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onplay"] = V;
        }
        get onplaying() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onplaying' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onplaying"]);
        }
        set onplaying(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onplaying' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onplaying' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onplaying"] = V;
        }
        get onprogress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onprogress' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onprogress"]);
        }
        set onprogress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onprogress' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onprogress' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onprogress"] = V;
        }
        get onratechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onratechange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onratechange"]);
        }
        set onratechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onratechange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onratechange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onratechange"] = V;
        }
        get onreset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onreset' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onreset"]);
        }
        set onreset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onreset' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onreset' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onreset"] = V;
        }
        get onresize() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onresize' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onresize"]);
        }
        set onresize(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onresize' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onresize' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onresize"] = V;
        }
        get onscroll() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onscroll' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onscroll"]);
        }
        set onscroll(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onscroll' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onscroll' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onscroll"] = V;
        }
        get onscrollend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onscrollend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onscrollend"]);
        }
        set onscrollend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onscrollend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onscrollend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onscrollend"] = V;
        }
        get onsecuritypolicyviolation() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsecuritypolicyviolation' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsecuritypolicyviolation"]);
        }
        set onsecuritypolicyviolation(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsecuritypolicyviolation' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsecuritypolicyviolation' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onsecuritypolicyviolation"] = V;
        }
        get onseeked() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onseeked' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onseeked"]);
        }
        set onseeked(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onseeked' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onseeked' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onseeked"] = V;
        }
        get onseeking() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onseeking' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onseeking"]);
        }
        set onseeking(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onseeking' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onseeking' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onseeking"] = V;
        }
        get onselect() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onselect' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onselect"]);
        }
        set onselect(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onselect' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onselect' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onselect"] = V;
        }
        get onslotchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onslotchange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onslotchange"]);
        }
        set onslotchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onslotchange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onslotchange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onslotchange"] = V;
        }
        get onstalled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onstalled' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onstalled"]);
        }
        set onstalled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onstalled' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onstalled' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onstalled"] = V;
        }
        get onsubmit() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsubmit' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsubmit"]);
        }
        set onsubmit(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsubmit' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsubmit' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onsubmit"] = V;
        }
        get onsuspend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsuspend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsuspend"]);
        }
        set onsuspend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsuspend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsuspend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onsuspend"] = V;
        }
        get ontimeupdate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontimeupdate' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontimeupdate"]);
        }
        set ontimeupdate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontimeupdate' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontimeupdate' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontimeupdate"] = V;
        }
        get ontoggle() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontoggle' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontoggle"]);
        }
        set ontoggle(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontoggle' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontoggle' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontoggle"] = V;
        }
        get onvolumechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onvolumechange' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onvolumechange"]);
        }
        set onvolumechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onvolumechange' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onvolumechange' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onvolumechange"] = V;
        }
        get onwaiting() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwaiting' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwaiting"]);
        }
        set onwaiting(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwaiting' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwaiting' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwaiting"] = V;
        }
        get onwebkitanimationend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationend"]);
        }
        set onwebkitanimationend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationend"] = V;
        }
        get onwebkitanimationiteration() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationiteration' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationiteration"]);
        }
        set onwebkitanimationiteration(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationiteration' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationiteration' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationiteration"] = V;
        }
        get onwebkitanimationstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationstart' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationstart"]);
        }
        set onwebkitanimationstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationstart' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationstart' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationstart"] = V;
        }
        get onwebkittransitionend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkittransitionend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkittransitionend"]);
        }
        set onwebkittransitionend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkittransitionend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkittransitionend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkittransitionend"] = V;
        }
        get onwheel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwheel' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwheel"]);
        }
        set onwheel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwheel' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwheel' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["onwheel"] = V;
        }
        get ontouchstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchstart' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchstart"]);
        }
        set ontouchstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchstart' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchstart' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchstart"] = V;
        }
        get ontouchend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchend' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchend"]);
        }
        set ontouchend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchend' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchend' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchend"] = V;
        }
        get ontouchmove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchmove' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchmove"]);
        }
        set ontouchmove(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchmove' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchmove' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchmove"] = V;
        }
        get ontouchcancel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchcancel' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchcancel"]);
        }
        set ontouchcancel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchcancel' called on an object that is not a valid instance of HTMLElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchcancel' property on 'HTMLElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchcancel"] = V;
        }
        get dataset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dataset' called on an object that is not a valid instance of HTMLElement.");
            }
            return utils.getSameObject(this, "dataset", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["dataset"]);
            });
        }
        get nonce() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nonce' called on an object that is not a valid instance of HTMLElement.");
            }
            const value = esValue[implSymbol]._reflectGetTheContentAttribute("nonce");
            return value === null ? "" : value;
        }
        set nonce(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set nonce' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'nonce' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]._reflectSetTheContentAttribute("nonce", V);
        }
        get tabIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tabIndex' called on an object that is not a valid instance of HTMLElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["tabIndex"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set tabIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set tabIndex' called on an object that is not a valid instance of HTMLElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'tabIndex' property on 'HTMLElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["tabIndex"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLElement.prototype, {
        click: {
            enumerable: true
        },
        attachInternals: {
            enumerable: true
        },
        focus: {
            enumerable: true
        },
        blur: {
            enumerable: true
        },
        title: {
            enumerable: true
        },
        lang: {
            enumerable: true
        },
        translate: {
            enumerable: true
        },
        dir: {
            enumerable: true
        },
        hidden: {
            enumerable: true
        },
        accessKey: {
            enumerable: true
        },
        draggable: {
            enumerable: true
        },
        offsetParent: {
            enumerable: true
        },
        offsetTop: {
            enumerable: true
        },
        offsetLeft: {
            enumerable: true
        },
        offsetWidth: {
            enumerable: true
        },
        offsetHeight: {
            enumerable: true
        },
        style: {
            enumerable: true
        },
        onabort: {
            enumerable: true
        },
        onauxclick: {
            enumerable: true
        },
        onbeforeinput: {
            enumerable: true
        },
        onbeforematch: {
            enumerable: true
        },
        onbeforetoggle: {
            enumerable: true
        },
        onblur: {
            enumerable: true
        },
        oncancel: {
            enumerable: true
        },
        oncanplay: {
            enumerable: true
        },
        oncanplaythrough: {
            enumerable: true
        },
        onchange: {
            enumerable: true
        },
        onclick: {
            enumerable: true
        },
        onclose: {
            enumerable: true
        },
        oncontextlost: {
            enumerable: true
        },
        oncontextmenu: {
            enumerable: true
        },
        oncontextrestored: {
            enumerable: true
        },
        oncopy: {
            enumerable: true
        },
        oncuechange: {
            enumerable: true
        },
        oncut: {
            enumerable: true
        },
        ondblclick: {
            enumerable: true
        },
        ondrag: {
            enumerable: true
        },
        ondragend: {
            enumerable: true
        },
        ondragenter: {
            enumerable: true
        },
        ondragleave: {
            enumerable: true
        },
        ondragover: {
            enumerable: true
        },
        ondragstart: {
            enumerable: true
        },
        ondrop: {
            enumerable: true
        },
        ondurationchange: {
            enumerable: true
        },
        onemptied: {
            enumerable: true
        },
        onended: {
            enumerable: true
        },
        onerror: {
            enumerable: true
        },
        onfocus: {
            enumerable: true
        },
        onformdata: {
            enumerable: true
        },
        oninput: {
            enumerable: true
        },
        oninvalid: {
            enumerable: true
        },
        onkeydown: {
            enumerable: true
        },
        onkeypress: {
            enumerable: true
        },
        onkeyup: {
            enumerable: true
        },
        onload: {
            enumerable: true
        },
        onloadeddata: {
            enumerable: true
        },
        onloadedmetadata: {
            enumerable: true
        },
        onloadstart: {
            enumerable: true
        },
        onmousedown: {
            enumerable: true
        },
        onmouseenter: {
            enumerable: true
        },
        onmouseleave: {
            enumerable: true
        },
        onmousemove: {
            enumerable: true
        },
        onmouseout: {
            enumerable: true
        },
        onmouseover: {
            enumerable: true
        },
        onmouseup: {
            enumerable: true
        },
        onpaste: {
            enumerable: true
        },
        onpause: {
            enumerable: true
        },
        onplay: {
            enumerable: true
        },
        onplaying: {
            enumerable: true
        },
        onprogress: {
            enumerable: true
        },
        onratechange: {
            enumerable: true
        },
        onreset: {
            enumerable: true
        },
        onresize: {
            enumerable: true
        },
        onscroll: {
            enumerable: true
        },
        onscrollend: {
            enumerable: true
        },
        onsecuritypolicyviolation: {
            enumerable: true
        },
        onseeked: {
            enumerable: true
        },
        onseeking: {
            enumerable: true
        },
        onselect: {
            enumerable: true
        },
        onslotchange: {
            enumerable: true
        },
        onstalled: {
            enumerable: true
        },
        onsubmit: {
            enumerable: true
        },
        onsuspend: {
            enumerable: true
        },
        ontimeupdate: {
            enumerable: true
        },
        ontoggle: {
            enumerable: true
        },
        onvolumechange: {
            enumerable: true
        },
        onwaiting: {
            enumerable: true
        },
        onwebkitanimationend: {
            enumerable: true
        },
        onwebkitanimationiteration: {
            enumerable: true
        },
        onwebkitanimationstart: {
            enumerable: true
        },
        onwebkittransitionend: {
            enumerable: true
        },
        onwheel: {
            enumerable: true
        },
        ontouchstart: {
            enumerable: true
        },
        ontouchend: {
            enumerable: true
        },
        ontouchmove: {
            enumerable: true
        },
        ontouchcancel: {
            enumerable: true
        },
        dataset: {
            enumerable: true
        },
        nonce: {
            enumerable: true
        },
        tabIndex: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLDocument.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Document = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Document.js [middleware-edge] (ecmascript)");
const interfaceName = "XMLDocument";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'XMLDocument'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["XMLDocument"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Document._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class XMLDocument extends globalObject.Document {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(XMLDocument.prototype, {
        [Symbol.toStringTag]: {
            value: "XMLDocument",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = XMLDocument;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: XMLDocument
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/XMLDocument-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMImplementation.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const DocumentType = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DocumentType.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMImplementation";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMImplementation'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMImplementation"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMImplementation {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        createDocumentType(qualifiedName, publicId, systemId) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createDocumentType' called on an object that is not a valid instance of DOMImplementation.");
            }
            if (arguments.length < 3) {
                throw new globalObject.TypeError(`Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 3",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createDocumentType(...args));
        }
        createDocument(namespace, qualifiedName) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createDocument' called on an object that is not a valid instance of DOMImplementation.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'createDocument' on 'DOMImplementation': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'createDocument' on 'DOMImplementation': parameter 2",
                    globals: globalObject,
                    treatNullAsEmptyString: true
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = DocumentType.convert(globalObject, curArg, {
                            context: "Failed to execute 'createDocument' on 'DOMImplementation': parameter 3"
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createDocument(...args));
        }
        createHTMLDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createHTMLDocument' called on an object that is not a valid instance of DOMImplementation.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'createHTMLDocument' on 'DOMImplementation': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createHTMLDocument(...args));
        }
        hasFeature() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'hasFeature' called on an object that is not a valid instance of DOMImplementation.");
            }
            return esValue[implSymbol].hasFeature();
        }
    }
    Object.defineProperties(DOMImplementation.prototype, {
        createDocumentType: {
            enumerable: true
        },
        createDocument: {
            enumerable: true
        },
        createHTMLDocument: {
            enumerable: true
        },
        hasFeature: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMImplementation",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = DOMImplementation;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMImplementation
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/DOMImplementation-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/RadioNodeList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const NodeList = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/NodeList.js [middleware-edge] (ecmascript)");
const interfaceName = "RadioNodeList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'RadioNodeList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["RadioNodeList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    NodeList._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class RadioNodeList extends globalObject.NodeList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of RadioNodeList.");
            }
            return esValue[implSymbol]["value"];
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of RadioNodeList.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'RadioNodeList': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["value"] = V;
        }
    }
    Object.defineProperties(RadioNodeList.prototype, {
        value: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "RadioNodeList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = RadioNodeList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: RadioNodeList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/RadioNodeList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptionElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLOptionElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLOptionElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLOptionElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLOptionElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get label() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get label' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["label"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set label(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set label' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'label' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["label"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get defaultSelected() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultSelected' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("selected") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultSelected(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultSelected' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'defaultSelected' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("selected", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("selected");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get selected() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selected' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            return esValue[implSymbol]["selected"];
        }
        set selected(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selected' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'selected' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selected"] = V;
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get text() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get text' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["text"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set text(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set text' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'text' property on 'HTMLOptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["text"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get index() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get index' called on an object that is not a valid instance of HTMLOptionElement.");
            }
            return esValue[implSymbol]["index"];
        }
    }
    Object.defineProperties(HTMLOptionElement.prototype, {
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        label: {
            enumerable: true
        },
        defaultSelected: {
            enumerable: true
        },
        selected: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        text: {
            enumerable: true
        },
        index: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLOptionElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLOptionElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLOptionElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOptionElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptGroupElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLOptGroupElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLOptGroupElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLOptGroupElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLOptGroupElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLOptGroupElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLOptGroupElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLOptGroupElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get label() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get label' called on an object that is not a valid instance of HTMLOptGroupElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("label");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set label(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set label' called on an object that is not a valid instance of HTMLOptGroupElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'label' property on 'HTMLOptGroupElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("label", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLOptGroupElement.prototype, {
        disabled: {
            enumerable: true
        },
        label: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLOptGroupElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLOptGroupElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLOptGroupElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOptGroupElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptionsCollection.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLOptionElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptionElement.js [middleware-edge] (ecmascript)");
const HTMLOptGroupElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptGroupElement.js [middleware-edge] (ecmascript)");
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLCollection = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLCollection.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLOptionsCollection";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLOptionsCollection'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLOptionsCollection"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLCollection._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLOptionsCollection extends globalObject.HTMLCollection {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        add(element) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'add' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'add' on 'HTMLOptionsCollection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (HTMLOptionElement.is(curArg) || HTMLOptGroupElement.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    throw new globalObject.TypeError("Failed to execute 'add' on 'HTMLOptionsCollection': parameter 1" + " is not of any supported type.");
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        if (HTMLElement.is(curArg)) {
                            curArg = utils.implForWrapper(curArg);
                        } else if (typeof curArg === "number") {
                            curArg = conversions["long"](curArg, {
                                context: "Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2",
                                globals: globalObject
                            });
                        } else {
                            curArg = conversions["long"](curArg, {
                                context: "Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2",
                                globals: globalObject
                            });
                        }
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].add(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        remove(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'remove' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'remove' on 'HTMLOptionsCollection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["long"](curArg, {
                    context: "Failed to execute 'remove' on 'HTMLOptionsCollection': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].remove(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["length"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set length(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set length' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'length' property on 'HTMLOptionsCollection': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["length"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get selectedIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectedIndex' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            return esValue[implSymbol]["selectedIndex"];
        }
        set selectedIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectedIndex' called on an object that is not a valid instance of HTMLOptionsCollection.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'selectedIndex' property on 'HTMLOptionsCollection': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selectedIndex"] = V;
        }
    }
    Object.defineProperties(HTMLOptionsCollection.prototype, {
        add: {
            enumerable: true
        },
        remove: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        selectedIndex: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLOptionsCollection",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLOptionsCollection;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLOptionsCollection
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!(key in target)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        const namedValue = target[implSymbol].namedItem(P);
        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
            return {
                writable: false,
                enumerable: true,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
            if (utils.isArrayIndexPropName(P)) {
                const index = P >>> 0;
                let indexedValue = V;
                if (indexedValue === null || indexedValue === undefined) {
                    indexedValue = null;
                } else {
                    indexedValue = HTMLOptionElement.convert(globalObject, indexedValue, {
                        context: "Failed to set the " + index + " property on 'HTMLOptionsCollection': The provided value"
                    });
                }
                ceReactionsPreSteps_helpers_custom_elements(globalObject);
                try {
                    const creating = !(target[implSymbol].item(index) !== null);
                    if (creating) {
                        target[implSymbol][utils.indexedSetNew](index, indexedValue);
                    } else {
                        target[implSymbol][utils.indexedSetExisting](index, indexedValue);
                    }
                } finally{
                    ceReactionsPostSteps_helpers_custom_elements(globalObject);
                }
                return true;
            }
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            if (desc.get || desc.set) {
                return false;
            }
            const index = P >>> 0;
            let indexedValue = desc.value;
            if (indexedValue === null || indexedValue === undefined) {
                indexedValue = null;
            } else {
                indexedValue = HTMLOptionElement.convert(globalObject, indexedValue, {
                    context: "Failed to set the " + index + " property on 'HTMLOptionsCollection': The provided value"
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const creating = !(target[implSymbol].item(index) !== null);
                if (creating) {
                    target[implSymbol][utils.indexedSetNew](index, indexedValue);
                } else {
                    target[implSymbol][utils.indexedSetExisting](index, indexedValue);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
            return true;
        }
        if (!utils.hasOwn(target, P)) {
            const creating = !(target[implSymbol].namedItem(P) !== null);
            if (!creating) {
                return false;
            }
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
            return false;
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOptionsCollection-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLHeadElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLHeadElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLHeadElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLHeadElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLHeadElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
    }
    Object.defineProperties(HTMLHeadElement.prototype, {
        [Symbol.toStringTag]: {
            value: "HTMLHeadElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLHeadElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLHeadElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLHeadElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTitleElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTitleElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTitleElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTitleElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTitleElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get text() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get text' called on an object that is not a valid instance of HTMLTitleElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["text"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set text(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set text' called on an object that is not a valid instance of HTMLTitleElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'text' property on 'HTMLTitleElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["text"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTitleElement.prototype, {
        text: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTitleElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTitleElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTitleElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTitleElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLBaseElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLBaseElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLBaseElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLBaseElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLBaseElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get href() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of HTMLBaseElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["href"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set href(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of HTMLBaseElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'href' property on 'HTMLBaseElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["href"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of HTMLBaseElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("target");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set target(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set target' called on an object that is not a valid instance of HTMLBaseElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'target' property on 'HTMLBaseElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("target", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLBaseElement.prototype, {
        href: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLBaseElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLBaseElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLBaseElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLBaseElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLLinkElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLLinkElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLLinkElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLLinkElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLLinkElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get href() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("href");
                if (value === null) {
                    return "";
                }
                if (this._hrefURLCacheKey === value) {
                    return this._hrefURLCache;
                }
                this._hrefURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._hrefURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._hrefURLCache;
                }
                this._hrefURLCache = conversions.USVString(value);
                return this._hrefURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set href(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'href' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("href", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get crossOrigin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get crossOrigin' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("crossorigin");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set crossOrigin(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set crossOrigin' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'crossOrigin' property on 'HTMLLinkElement': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("crossorigin");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("crossorigin", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rel' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rel");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rel' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rel' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rel", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get relList() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get relList' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            return utils.getSameObject(this, "relList", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["relList"]);
            });
        }
        set relList(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set relList' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            const Q = esValue["relList"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'relList' is not an object");
            }
            Reflect.set(Q, "value", V);
        }
        get media() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get media' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("media");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set media(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set media' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'media' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("media", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hreflang() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hreflang' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("hreflang");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hreflang(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hreflang' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'hreflang' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("hreflang", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get charset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get charset' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charset");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set charset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set charset' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'charset' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rev() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rev' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rev");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rev(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rev' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rev' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rev", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("target");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set target(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set target' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'target' property on 'HTMLLinkElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("target", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get sheet() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get sheet' called on an object that is not a valid instance of HTMLLinkElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["sheet"]);
        }
    }
    Object.defineProperties(HTMLLinkElement.prototype, {
        href: {
            enumerable: true
        },
        crossOrigin: {
            enumerable: true
        },
        rel: {
            enumerable: true
        },
        relList: {
            enumerable: true
        },
        media: {
            enumerable: true
        },
        hreflang: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        charset: {
            enumerable: true
        },
        rev: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        sheet: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLLinkElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLLinkElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLLinkElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLLinkElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMetaElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMetaElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMetaElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMetaElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMetaElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLMetaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get httpEquiv() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get httpEquiv' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("http-equiv");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set httpEquiv(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set httpEquiv' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'httpEquiv' property on 'HTMLMetaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("http-equiv", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get content() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get content' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("content");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set content(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set content' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'content' property on 'HTMLMetaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("content", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get scheme() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scheme' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("scheme");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scheme(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scheme' called on an object that is not a valid instance of HTMLMetaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'scheme' property on 'HTMLMetaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("scheme", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLMetaElement.prototype, {
        name: {
            enumerable: true
        },
        httpEquiv: {
            enumerable: true
        },
        content: {
            enumerable: true
        },
        scheme: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMetaElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMetaElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMetaElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMetaElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLStyleElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLStyleElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLStyleElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLStyleElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLStyleElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get media() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get media' called on an object that is not a valid instance of HTMLStyleElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("media");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set media(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set media' called on an object that is not a valid instance of HTMLStyleElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'media' property on 'HTMLStyleElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("media", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLStyleElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLStyleElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLStyleElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get sheet() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get sheet' called on an object that is not a valid instance of HTMLStyleElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["sheet"]);
        }
    }
    Object.defineProperties(HTMLStyleElement.prototype, {
        media: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        sheet: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLStyleElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLStyleElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLStyleElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLStyleElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLBodyElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const OnBeforeUnloadEventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/OnBeforeUnloadEventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLBodyElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLBodyElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLBodyElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLBodyElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get text() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get text' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("text");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set text(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set text' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'text' property on 'HTMLBodyElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("text", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get link() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get link' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("link");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set link(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set link' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'link' property on 'HTMLBodyElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("link", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vLink() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vLink' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("vlink");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vLink(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vLink' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'vLink' property on 'HTMLBodyElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("vlink", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get aLink() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get aLink' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("alink");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set aLink(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set aLink' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'aLink' property on 'HTMLBodyElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("alink", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get bgColor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bgColor' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("bgcolor");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set bgColor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set bgColor' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'bgColor' property on 'HTMLBodyElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("bgcolor", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get background() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get background' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("background");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set background(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set background' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'background' property on 'HTMLBodyElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("background", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get onafterprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onafterprint' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onafterprint"]);
        }
        set onafterprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onafterprint' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onafterprint' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onafterprint"] = V;
        }
        get onbeforeprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeprint' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeprint"]);
        }
        set onbeforeprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeprint' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeprint' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeprint"] = V;
        }
        get onbeforeunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeunload' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeunload"]);
        }
        set onbeforeunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeunload' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = OnBeforeUnloadEventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeunload' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeunload"] = V;
        }
        get onhashchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onhashchange' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onhashchange"]);
        }
        set onhashchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onhashchange' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onhashchange' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onhashchange"] = V;
        }
        get onlanguagechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onlanguagechange' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onlanguagechange"]);
        }
        set onlanguagechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onlanguagechange' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onlanguagechange' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onlanguagechange"] = V;
        }
        get onmessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessage' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessage"]);
        }
        set onmessage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessage' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessage' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessage"] = V;
        }
        get onmessageerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessageerror' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessageerror"]);
        }
        set onmessageerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessageerror' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessageerror' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessageerror"] = V;
        }
        get onoffline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onoffline' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onoffline"]);
        }
        set onoffline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onoffline' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onoffline' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onoffline"] = V;
        }
        get ononline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ononline' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ononline"]);
        }
        set ononline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ononline' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ononline' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["ononline"] = V;
        }
        get onpagehide() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpagehide' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpagehide"]);
        }
        set onpagehide(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpagehide' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpagehide' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onpagehide"] = V;
        }
        get onpageshow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpageshow' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpageshow"]);
        }
        set onpageshow(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpageshow' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpageshow' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onpageshow"] = V;
        }
        get onpopstate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpopstate' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpopstate"]);
        }
        set onpopstate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpopstate' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpopstate' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onpopstate"] = V;
        }
        get onrejectionhandled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onrejectionhandled' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onrejectionhandled"]);
        }
        set onrejectionhandled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onrejectionhandled' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onrejectionhandled' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onrejectionhandled"] = V;
        }
        get onstorage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onstorage' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onstorage"]);
        }
        set onstorage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onstorage' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onstorage' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onstorage"] = V;
        }
        get onunhandledrejection() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunhandledrejection' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunhandledrejection"]);
        }
        set onunhandledrejection(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunhandledrejection' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunhandledrejection' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onunhandledrejection"] = V;
        }
        get onunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunload' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunload"]);
        }
        set onunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunload' called on an object that is not a valid instance of HTMLBodyElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunload' property on 'HTMLBodyElement': The provided value"
                });
            }
            esValue[implSymbol]["onunload"] = V;
        }
    }
    Object.defineProperties(HTMLBodyElement.prototype, {
        text: {
            enumerable: true
        },
        link: {
            enumerable: true
        },
        vLink: {
            enumerable: true
        },
        aLink: {
            enumerable: true
        },
        bgColor: {
            enumerable: true
        },
        background: {
            enumerable: true
        },
        onafterprint: {
            enumerable: true
        },
        onbeforeprint: {
            enumerable: true
        },
        onbeforeunload: {
            enumerable: true
        },
        onhashchange: {
            enumerable: true
        },
        onlanguagechange: {
            enumerable: true
        },
        onmessage: {
            enumerable: true
        },
        onmessageerror: {
            enumerable: true
        },
        onoffline: {
            enumerable: true
        },
        ononline: {
            enumerable: true
        },
        onpagehide: {
            enumerable: true
        },
        onpageshow: {
            enumerable: true
        },
        onpopstate: {
            enumerable: true
        },
        onrejectionhandled: {
            enumerable: true
        },
        onstorage: {
            enumerable: true
        },
        onunhandledrejection: {
            enumerable: true
        },
        onunload: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLBodyElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLBodyElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLBodyElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLBodyElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLHeadingElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLHeadingElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLHeadingElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLHeadingElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLHeadingElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLHeadingElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLHeadingElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLHeadingElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLHeadingElement.prototype, {
        align: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLHeadingElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLHeadingElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLHeadingElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLHeadingElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLParagraphElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLParagraphElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLParagraphElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLParagraphElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLParagraphElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLParagraphElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLParagraphElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLParagraphElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLParagraphElement.prototype, {
        align: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLParagraphElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLParagraphElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLParagraphElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLParagraphElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLHRElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLHRElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLHRElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLHRElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLHRElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLHRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLHRElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLHRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get color() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get color' called on an object that is not a valid instance of HTMLHRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("color");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set color(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set color' called on an object that is not a valid instance of HTMLHRElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'color' property on 'HTMLHRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("color", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get noShade() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get noShade' called on an object that is not a valid instance of HTMLHRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("noshade") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set noShade(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set noShade' called on an object that is not a valid instance of HTMLHRElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'noShade' property on 'HTMLHRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("noshade", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("noshade");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get size() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of HTMLHRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("size");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set size(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set size' called on an object that is not a valid instance of HTMLHRElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'size' property on 'HTMLHRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("size", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLHRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLHRElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLHRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLHRElement.prototype, {
        align: {
            enumerable: true
        },
        color: {
            enumerable: true
        },
        noShade: {
            enumerable: true
        },
        size: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLHRElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLHRElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLHRElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLHRElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLPreElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const parseInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseInteger;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLPreElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLPreElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLPreElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLPreElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLPreElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                if (value !== null) {
                    value = parseInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLPreElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'width' property on 'HTMLPreElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLPreElement.prototype, {
        width: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLPreElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLPreElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLPreElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLPreElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLUListElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLUListElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLUListElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLUListElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLUListElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get compact() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get compact' called on an object that is not a valid instance of HTMLUListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("compact") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set compact(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set compact' called on an object that is not a valid instance of HTMLUListElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'compact' property on 'HTMLUListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("compact", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("compact");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLUListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLUListElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLUListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLUListElement.prototype, {
        compact: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLUListElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLUListElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLUListElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLUListElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOListElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLOListElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLOListElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLOListElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLOListElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get reversed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get reversed' called on an object that is not a valid instance of HTMLOListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("reversed") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set reversed(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set reversed' called on an object that is not a valid instance of HTMLOListElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'reversed' property on 'HTMLOListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("reversed", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("reversed");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get start() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get start' called on an object that is not a valid instance of HTMLOListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["start"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set start(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set start' called on an object that is not a valid instance of HTMLOListElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'start' property on 'HTMLOListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["start"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLOListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLOListElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLOListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get compact() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get compact' called on an object that is not a valid instance of HTMLOListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("compact") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set compact(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set compact' called on an object that is not a valid instance of HTMLOListElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'compact' property on 'HTMLOListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("compact", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("compact");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLOListElement.prototype, {
        reversed: {
            enumerable: true
        },
        start: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        compact: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLOListElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLOListElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLOListElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOListElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLLIElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const parseInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseInteger;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLLIElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLLIElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLLIElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLLIElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLLIElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("value");
                if (value !== null) {
                    value = parseInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLLIElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'value' property on 'HTMLLIElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("value", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLLIElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLLIElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLLIElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLLIElement.prototype, {
        value: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLLIElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLLIElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLLIElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLLIElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMenuElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMenuElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMenuElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMenuElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMenuElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get compact() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get compact' called on an object that is not a valid instance of HTMLMenuElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("compact") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set compact(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set compact' called on an object that is not a valid instance of HTMLMenuElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'compact' property on 'HTMLMenuElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("compact", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("compact");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLMenuElement.prototype, {
        compact: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMenuElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMenuElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMenuElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMenuElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDListElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDListElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDListElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDListElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDListElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get compact() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get compact' called on an object that is not a valid instance of HTMLDListElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("compact") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set compact(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set compact' called on an object that is not a valid instance of HTMLDListElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'compact' property on 'HTMLDListElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("compact", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("compact");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDListElement.prototype, {
        compact: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDListElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDListElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDListElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDListElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDivElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDivElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDivElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDivElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDivElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLDivElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLDivElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLDivElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDivElement.prototype, {
        align: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDivElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDivElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDivElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDivElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLAnchorElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLAnchorElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLAnchorElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLAnchorElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLAnchorElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("target");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set target(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set target' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'target' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("target", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get download() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get download' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("download");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set download(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set download' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'download' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("download", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rel' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rel");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rel' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rel' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rel", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get relList() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get relList' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            return utils.getSameObject(this, "relList", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["relList"]);
            });
        }
        set relList(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set relList' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            const Q = esValue["relList"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'relList' is not an object");
            }
            Reflect.set(Q, "value", V);
        }
        get hreflang() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hreflang' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("hreflang");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hreflang(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hreflang' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'hreflang' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("hreflang", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get text() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get text' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["text"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set text(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set text' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'text' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["text"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get coords() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get coords' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("coords");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set coords(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set coords' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'coords' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("coords", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get charset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get charset' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charset");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set charset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set charset' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'charset' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rev() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rev' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rev");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rev(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rev' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rev' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rev", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get shape() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shape' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("shape");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set shape(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set shape' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'shape' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("shape", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get href() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["href"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set href(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'href' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["href"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        toString() {
            const esValue = this;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["href"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get origin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            return esValue[implSymbol]["origin"];
        }
        get protocol() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["protocol"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set protocol(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'protocol' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["protocol"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get username() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["username"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set username(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'username' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["username"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get password() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["password"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set password(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'password' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["password"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get host() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["host"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set host(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'host' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["host"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hostname() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["hostname"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hostname(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'hostname' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["hostname"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get port() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["port"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set port(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'port' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["port"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get pathname() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["pathname"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set pathname(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'pathname' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["pathname"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get search() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["search"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set search(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'search' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["search"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hash() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["hash"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hash(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of HTMLAnchorElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'hash' property on 'HTMLAnchorElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["hash"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLAnchorElement.prototype, {
        target: {
            enumerable: true
        },
        download: {
            enumerable: true
        },
        rel: {
            enumerable: true
        },
        relList: {
            enumerable: true
        },
        hreflang: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        text: {
            enumerable: true
        },
        coords: {
            enumerable: true
        },
        charset: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        rev: {
            enumerable: true
        },
        shape: {
            enumerable: true
        },
        href: {
            enumerable: true
        },
        toString: {
            enumerable: true
        },
        origin: {
            enumerable: true
        },
        protocol: {
            enumerable: true
        },
        username: {
            enumerable: true
        },
        password: {
            enumerable: true
        },
        host: {
            enumerable: true
        },
        hostname: {
            enumerable: true
        },
        port: {
            enumerable: true
        },
        pathname: {
            enumerable: true
        },
        search: {
            enumerable: true
        },
        hash: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLAnchorElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLAnchorElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLAnchorElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLAnchorElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLAreaElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLAreaElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLAreaElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLAreaElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLAreaElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get alt() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get alt' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("alt");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set alt(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set alt' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'alt' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("alt", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get coords() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get coords' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("coords");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set coords(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set coords' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'coords' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("coords", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get shape() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get shape' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("shape");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set shape(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set shape' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'shape' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("shape", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("target");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set target(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set target' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'target' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("target", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rel' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rel");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rel' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rel' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rel", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get relList() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get relList' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            return utils.getSameObject(this, "relList", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["relList"]);
            });
        }
        set relList(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set relList' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            const Q = esValue["relList"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'relList' is not an object");
            }
            Reflect.set(Q, "value", V);
        }
        get noHref() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get noHref' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("nohref") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set noHref(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set noHref' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'noHref' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("nohref", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("nohref");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get href() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["href"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set href(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'href' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["href"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        toString() {
            const esValue = this;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["href"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get origin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            return esValue[implSymbol]["origin"];
        }
        get protocol() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["protocol"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set protocol(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'protocol' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["protocol"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get username() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["username"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set username(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'username' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["username"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get password() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["password"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set password(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'password' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["password"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get host() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["host"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set host(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'host' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["host"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hostname() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["hostname"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hostname(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'hostname' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["hostname"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get port() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["port"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set port(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'port' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["port"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get pathname() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["pathname"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set pathname(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'pathname' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["pathname"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get search() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["search"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set search(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'search' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["search"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hash() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["hash"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hash(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of HTMLAreaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'hash' property on 'HTMLAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["hash"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLAreaElement.prototype, {
        alt: {
            enumerable: true
        },
        coords: {
            enumerable: true
        },
        shape: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        rel: {
            enumerable: true
        },
        relList: {
            enumerable: true
        },
        noHref: {
            enumerable: true
        },
        href: {
            enumerable: true
        },
        toString: {
            enumerable: true
        },
        origin: {
            enumerable: true
        },
        protocol: {
            enumerable: true
        },
        username: {
            enumerable: true
        },
        password: {
            enumerable: true
        },
        host: {
            enumerable: true
        },
        hostname: {
            enumerable: true
        },
        port: {
            enumerable: true
        },
        pathname: {
            enumerable: true
        },
        search: {
            enumerable: true
        },
        hash: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLAreaElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLAreaElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLAreaElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLAreaElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLBRElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLBRElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLBRElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLBRElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLBRElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get clear() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get clear' called on an object that is not a valid instance of HTMLBRElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("clear");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set clear(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set clear' called on an object that is not a valid instance of HTMLBRElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'clear' property on 'HTMLBRElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("clear", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLBRElement.prototype, {
        clear: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLBRElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLBRElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLBRElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLBRElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ValidityState.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "ValidityState";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'ValidityState'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["ValidityState"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class ValidityState {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get valueMissing() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get valueMissing' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["valueMissing"];
        }
        get typeMismatch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get typeMismatch' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["typeMismatch"];
        }
        get patternMismatch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get patternMismatch' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["patternMismatch"];
        }
        get tooLong() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tooLong' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["tooLong"];
        }
        get tooShort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tooShort' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["tooShort"];
        }
        get rangeUnderflow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rangeUnderflow' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["rangeUnderflow"];
        }
        get rangeOverflow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rangeOverflow' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["rangeOverflow"];
        }
        get stepMismatch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get stepMismatch' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["stepMismatch"];
        }
        get badInput() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get badInput' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["badInput"];
        }
        get customError() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get customError' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["customError"];
        }
        get valid() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get valid' called on an object that is not a valid instance of ValidityState.");
            }
            return esValue[implSymbol]["valid"];
        }
    }
    Object.defineProperties(ValidityState.prototype, {
        valueMissing: {
            enumerable: true
        },
        typeMismatch: {
            enumerable: true
        },
        patternMismatch: {
            enumerable: true
        },
        tooLong: {
            enumerable: true
        },
        tooShort: {
            enumerable: true
        },
        rangeUnderflow: {
            enumerable: true
        },
        rangeOverflow: {
            enumerable: true
        },
        stepMismatch: {
            enumerable: true
        },
        badInput: {
            enumerable: true
        },
        customError: {
            enumerable: true
        },
        valid: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "ValidityState",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = ValidityState;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: ValidityState
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/constraint-validation/ValidityState-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLButtonElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLButtonElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLButtonElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLButtonElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLButtonElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLButtonElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLButtonElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        get autofocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autofocus' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("autofocus") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autofocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autofocus' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'autofocus' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("autofocus", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("autofocus");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get formNoValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get formNoValidate' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("formnovalidate") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set formNoValidate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set formNoValidate' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'formNoValidate' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("formnovalidate", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("formnovalidate");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get formTarget() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get formTarget' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("formtarget");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set formTarget(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set formTarget' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'formTarget' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("formtarget", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["type"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["type"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("value");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLButtonElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("value", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLButtonElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
    }
    Object.defineProperties(HTMLButtonElement.prototype, {
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        autofocus: {
            enumerable: true
        },
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        formNoValidate: {
            enumerable: true
        },
        formTarget: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLButtonElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLButtonElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLButtonElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLButtonElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/BlobCallback.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(blob) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        blob = utils.tryWrapperForImpl(blob);
        callResult = Reflect.apply(value, thisArg, [
            blob
        ]);
    }
    invokeTheCallbackFunction.construct = (blob)=>{
        blob = utils.tryWrapperForImpl(blob);
        let callResult = Reflect.construct(value, [
            blob
        ]);
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const BlobCallback = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/BlobCallback.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLCanvasElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLCanvasElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLCanvasElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLCanvasElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        getContext(contextId) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getContext' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getContext' on 'HTMLCanvasElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getContext' on 'HTMLCanvasElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            for(let i = 1; i < arguments.length; i++){
                let curArg = arguments[i];
                curArg = conversions["any"](curArg, {
                    context: "Failed to execute 'getContext' on 'HTMLCanvasElement': parameter " + (i + 1),
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getContext(...args));
        }
        toDataURL() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toDataURL' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'toDataURL' on 'HTMLCanvasElement': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'toDataURL' on 'HTMLCanvasElement': parameter 2",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].toDataURL(...args);
        }
        toBlob(callback) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toBlob' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'toBlob' on 'HTMLCanvasElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = BlobCallback.convert(globalObject, curArg, {
                    context: "Failed to execute 'toBlob' on 'HTMLCanvasElement': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'toBlob' on 'HTMLCanvasElement': parameter 2",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'toBlob' on 'HTMLCanvasElement': parameter 3",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].toBlob(...args);
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["width"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'width' property on 'HTMLCanvasElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["width"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["height"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLCanvasElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'height' property on 'HTMLCanvasElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["height"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLCanvasElement.prototype, {
        getContext: {
            enumerable: true
        },
        toDataURL: {
            enumerable: true
        },
        toBlob: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLCanvasElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLCanvasElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLCanvasElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDataElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDataElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDataElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDataElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDataElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLDataElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("value");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLDataElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLDataElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("value", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDataElement.prototype, {
        value: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDataElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDataElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDataElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDataElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDataListElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDataListElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDataListElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDataListElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDataListElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get options() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get options' called on an object that is not a valid instance of HTMLDataListElement.");
            }
            return utils.getSameObject(this, "options", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["options"]);
            });
        }
    }
    Object.defineProperties(HTMLDataListElement.prototype, {
        options: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDataListElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDataListElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDataListElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDataListElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDetailsElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDetailsElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDetailsElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDetailsElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDetailsElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get open() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get open' called on an object that is not a valid instance of HTMLDetailsElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("open") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set open(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set open' called on an object that is not a valid instance of HTMLDetailsElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'open' property on 'HTMLDetailsElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("open", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("open");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDetailsElement.prototype, {
        open: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDetailsElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDetailsElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDetailsElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDetailsElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDialogElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDialogElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDialogElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDialogElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDialogElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get open() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get open' called on an object that is not a valid instance of HTMLDialogElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("open") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set open(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set open' called on an object that is not a valid instance of HTMLDialogElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'open' property on 'HTMLDialogElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("open", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("open");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDialogElement.prototype, {
        open: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDialogElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDialogElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDialogElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDialogElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLDirectoryElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLDirectoryElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLDirectoryElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLDirectoryElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLDirectoryElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get compact() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get compact' called on an object that is not a valid instance of HTMLDirectoryElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("compact") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set compact(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set compact' called on an object that is not a valid instance of HTMLDirectoryElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'compact' property on 'HTMLDirectoryElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("compact", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("compact");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLDirectoryElement.prototype, {
        compact: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLDirectoryElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLDirectoryElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLDirectoryElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLDirectoryElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFieldSetElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLFieldSetElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFieldSetElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFieldSetElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFieldSetElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLFieldSetElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLFieldSetElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLFieldSetElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLFieldSetElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return esValue[implSymbol]["type"];
        }
        get elements() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get elements' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return utils.getSameObject(this, "elements", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["elements"]);
            });
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return utils.getSameObject(this, "validity", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
            });
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLFieldSetElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
    }
    Object.defineProperties(HTMLFieldSetElement.prototype, {
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        elements: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFieldSetElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFieldSetElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFieldSetElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFieldSetElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFontElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLFontElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFontElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFontElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFontElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get color() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get color' called on an object that is not a valid instance of HTMLFontElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("color");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set color(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set color' called on an object that is not a valid instance of HTMLFontElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'color' property on 'HTMLFontElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("color", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get face() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get face' called on an object that is not a valid instance of HTMLFontElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("face");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set face(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set face' called on an object that is not a valid instance of HTMLFontElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'face' property on 'HTMLFontElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("face", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get size() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of HTMLFontElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("size");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set size(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set size' called on an object that is not a valid instance of HTMLFontElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'size' property on 'HTMLFontElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("size", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLFontElement.prototype, {
        color: {
            enumerable: true
        },
        face: {
            enumerable: true
        },
        size: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFontElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFontElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFontElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFontElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFormControlsCollection.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLCollection = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLCollection.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLFormControlsCollection";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFormControlsCollection'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFormControlsCollection"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLCollection._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFormControlsCollection extends globalObject.HTMLCollection {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of HTMLFormControlsCollection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'HTMLFormControlsCollection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'HTMLFormControlsCollection': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].namedItem(...args));
        }
    }
    Object.defineProperties(HTMLFormControlsCollection.prototype, {
        namedItem: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFormControlsCollection",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFormControlsCollection;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFormControlsCollection
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!(key in target)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        const namedValue = target[implSymbol].namedItem(P);
        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
            return {
                writable: false,
                enumerable: true,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        if (!utils.hasOwn(target, P)) {
            const creating = !(target[implSymbol].namedItem(P) !== null);
            if (!creating) {
                return false;
            }
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
            return false;
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFormControlsCollection-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SubmitEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "submitter";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = HTMLElement.convert(globalObject, value, {
                    context: context + " has member 'submitter' that"
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SubmitEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const SubmitEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SubmitEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "SubmitEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SubmitEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SubmitEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SubmitEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'SubmitEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'SubmitEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = SubmitEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'SubmitEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get submitter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get submitter' called on an object that is not a valid instance of SubmitEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["submitter"]);
        }
    }
    Object.defineProperties(SubmitEvent.prototype, {
        submitter: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SubmitEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SubmitEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SubmitEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/SubmitEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFormElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "HTMLFormElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFormElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFormElement"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFormElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        submit() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'submit' called on an object that is not a valid instance of HTMLFormElement.");
            }
            return esValue[implSymbol].submit();
        }
        requestSubmit() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'requestSubmit' called on an object that is not a valid instance of HTMLFormElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = HTMLElement.convert(globalObject, curArg, {
                        context: "Failed to execute 'requestSubmit' on 'HTMLFormElement': parameter 1"
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].requestSubmit(...args);
        }
        reset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reset' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].reset();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLFormElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLFormElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        get acceptCharset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get acceptCharset' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("accept-charset");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set acceptCharset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set acceptCharset' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'acceptCharset' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("accept-charset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get action() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get action' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["action"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set action(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set action' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'action' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["action"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get enctype() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get enctype' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["enctype"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set enctype(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set enctype' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'enctype' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["enctype"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get method() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get method' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["method"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set method(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set method' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'method' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["method"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get noValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get noValidate' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("novalidate") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set noValidate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set noValidate' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'noValidate' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("novalidate", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("novalidate");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get target() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get target' called on an object that is not a valid instance of HTMLFormElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("target");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set target(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set target' called on an object that is not a valid instance of HTMLFormElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'target' property on 'HTMLFormElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("target", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get elements() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get elements' called on an object that is not a valid instance of HTMLFormElement.");
            }
            return utils.getSameObject(this, "elements", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["elements"]);
            });
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of HTMLFormElement.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(HTMLFormElement.prototype, {
        submit: {
            enumerable: true
        },
        requestSubmit: {
            enumerable: true
        },
        reset: {
            enumerable: true
        },
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        acceptCharset: {
            enumerable: true
        },
        action: {
            enumerable: true
        },
        enctype: {
            enumerable: true
        },
        method: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        noValidate: {
            enumerable: true
        },
        target: {
            enumerable: true
        },
        elements: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFormElement",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFormElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFormElement
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol][utils.indexedGet](index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol][utils.indexedGet](index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol][utils.indexedGet](index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFormElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLHtmlElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLHtmlElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLHtmlElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLHtmlElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLHtmlElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get version() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get version' called on an object that is not a valid instance of HTMLHtmlElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("version");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set version(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set version' called on an object that is not a valid instance of HTMLHtmlElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'version' property on 'HTMLHtmlElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("version", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLHtmlElement.prototype, {
        version: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLHtmlElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLHtmlElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLHtmlElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLHtmlElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLImageElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLImageElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLImageElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLImageElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLImageElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get alt() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get alt' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("alt");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set alt(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set alt' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'alt' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("alt", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get srcset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get srcset' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("srcset");
                return value === null ? "" : conversions.USVString(value);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set srcset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set srcset' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'srcset' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("srcset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get sizes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get sizes' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("sizes");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set sizes(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set sizes' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'sizes' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("sizes", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get crossOrigin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get crossOrigin' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("crossorigin");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set crossOrigin(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set crossOrigin' called on an object that is not a valid instance of HTMLImageElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'crossOrigin' property on 'HTMLImageElement': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("crossorigin");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("crossorigin", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get useMap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get useMap' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("usemap");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set useMap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set useMap' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'useMap' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("usemap", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get isMap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get isMap' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("ismap") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set isMap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set isMap' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'isMap' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("ismap", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("ismap");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["width"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'width' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["width"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["height"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'height' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["height"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get naturalWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get naturalWidth' called on an object that is not a valid instance of HTMLImageElement.");
            }
            return esValue[implSymbol]["naturalWidth"];
        }
        get naturalHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get naturalHeight' called on an object that is not a valid instance of HTMLImageElement.");
            }
            return esValue[implSymbol]["naturalHeight"];
        }
        get complete() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get complete' called on an object that is not a valid instance of HTMLImageElement.");
            }
            return esValue[implSymbol]["complete"];
        }
        get currentSrc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get currentSrc' called on an object that is not a valid instance of HTMLImageElement.");
            }
            return esValue[implSymbol]["currentSrc"];
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get lowsrc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lowsrc' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("lowsrc");
                if (value === null) {
                    return "";
                }
                if (this._lowsrcURLCacheKey === value) {
                    return this._lowsrcURLCache;
                }
                this._lowsrcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._lowsrcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._lowsrcURLCache;
                }
                this._lowsrcURLCache = conversions.USVString(value);
                return this._lowsrcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set lowsrc(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set lowsrc' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'lowsrc' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("lowsrc", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hspace' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("hspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hspace' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'hspace' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("hspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vspace' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("vspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vspace' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'vspace' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("vspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get longDesc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get longDesc' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("longdesc");
                if (value === null) {
                    return "";
                }
                if (this._longdescURLCacheKey === value) {
                    return this._longdescURLCache;
                }
                this._longdescURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._longdescURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._longdescURLCache;
                }
                this._longdescURLCache = conversions.USVString(value);
                return this._longdescURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set longDesc(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set longDesc' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'longDesc' property on 'HTMLImageElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("longdesc", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get border() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get border' called on an object that is not a valid instance of HTMLImageElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("border");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set border(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set border' called on an object that is not a valid instance of HTMLImageElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'border' property on 'HTMLImageElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("border", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLImageElement.prototype, {
        alt: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        srcset: {
            enumerable: true
        },
        sizes: {
            enumerable: true
        },
        crossOrigin: {
            enumerable: true
        },
        useMap: {
            enumerable: true
        },
        isMap: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        naturalWidth: {
            enumerable: true
        },
        naturalHeight: {
            enumerable: true
        },
        complete: {
            enumerable: true
        },
        currentSrc: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        lowsrc: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        hspace: {
            enumerable: true
        },
        vspace: {
            enumerable: true
        },
        longDesc: {
            enumerable: true
        },
        border: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLImageElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLImageElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLImageElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLImageElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FileList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "FileList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'FileList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["FileList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class FileList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of FileList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'FileList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'FileList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of FileList.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(FileList.prototype, {
        item: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "FileList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = FileList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: FileList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/file-api/FileList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SelectionMode.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "select",
    "start",
    "end",
    "preserve"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for SelectionMode`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLInputElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const SelectionMode = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SelectionMode.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const FileList = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/FileList.js [middleware-edge] (ecmascript)");
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const create_DOMException = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMException.js [middleware-edge] (ecmascript)").create;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLInputElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLInputElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLInputElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLInputElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        stepUp() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'stepUp' called on an object that is not a valid instance of HTMLInputElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'stepUp' on 'HTMLInputElement': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = 1;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].stepUp(...args);
        }
        stepDown() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'stepDown' called on an object that is not a valid instance of HTMLInputElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'stepDown' on 'HTMLInputElement': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = 1;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].stepDown(...args);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLInputElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLInputElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        select() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'select' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol].select();
        }
        setRangeText(replacement) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setRangeText' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setRangeText' on 'HTMLInputElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            switch(arguments.length){
                case 1:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                case 2:
                    throw new globalObject.TypeError(`Failed to execute 'setRangeText' on 'HTMLInputElement': only ${arguments.length} arguments present.`);
                    break;
                case 3:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[3];
                        if (curArg !== undefined) {
                            curArg = SelectionMode.convert(globalObject, curArg, {
                                context: "Failed to execute 'setRangeText' on 'HTMLInputElement': parameter 4"
                            });
                        } else {
                            curArg = "preserve";
                        }
                        args.push(curArg);
                    }
            }
            return esValue[implSymbol].setRangeText(...args);
        }
        setSelectionRange(start, end) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setSelectionRange' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setSelectionRange' on 'HTMLInputElement': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setSelectionRange' on 'HTMLInputElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setSelectionRange' on 'HTMLInputElement': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'setSelectionRange' on 'HTMLInputElement': parameter 3",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].setSelectionRange(...args);
        }
        get accept() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get accept' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("accept");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set accept(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set accept' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'accept' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("accept", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get alt() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get alt' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("alt");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set alt(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set alt' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'alt' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("alt", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get autocomplete() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autocomplete' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("autocomplete");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autocomplete(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autocomplete' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'autocomplete' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("autocomplete", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get autofocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autofocus' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("autofocus") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autofocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autofocus' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'autofocus' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("autofocus", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("autofocus");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get defaultChecked() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultChecked' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("checked") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultChecked(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultChecked' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'defaultChecked' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("checked", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("checked");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get checked() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get checked' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["checked"];
        }
        set checked(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set checked' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'checked' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["checked"] = V;
        }
        get dirName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dirName' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("dirname");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set dirName(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set dirName' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'dirName' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("dirname", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get files() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get files' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["files"]);
        }
        set files(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set files' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = FileList.convert(globalObject, V, {
                    context: "Failed to set the 'files' property on 'HTMLInputElement': The provided value"
                });
            }
            esValue[implSymbol]["files"] = V;
        }
        get formNoValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get formNoValidate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("formnovalidate") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set formNoValidate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set formNoValidate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'formNoValidate' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("formnovalidate", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("formnovalidate");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get formTarget() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get formTarget' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("formtarget");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set formTarget(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set formTarget' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'formTarget' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("formtarget", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get indeterminate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get indeterminate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["indeterminate"];
        }
        set indeterminate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set indeterminate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'indeterminate' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["indeterminate"] = V;
        }
        get inputMode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get inputMode' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("inputmode");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set inputMode(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set inputMode' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'inputMode' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("inputmode", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get list() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get list' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["list"]);
        }
        get max() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get max' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("max");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set max(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set max' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'max' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("max", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get maxLength() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get maxLength' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("maxlength");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return -1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set maxLength(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set maxLength' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'maxLength' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V < 0) {
                    throw create_DOMException(globalObject, [
                        `The negative value ${V} cannot be set for the maxLength property.`,
                        "IndexSizeError"
                    ]);
                }
                esValue[implSymbol]._reflectSetTheContentAttribute("maxlength", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get min() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get min' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("min");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set min(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set min' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'min' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("min", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get minLength() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get minLength' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("minlength");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return -1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set minLength(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set minLength' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'minLength' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V < 0) {
                    throw create_DOMException(globalObject, [
                        `The negative value ${V} cannot be set for the minLength property.`,
                        "IndexSizeError"
                    ]);
                }
                esValue[implSymbol]._reflectSetTheContentAttribute("minlength", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get multiple() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get multiple' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("multiple") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set multiple(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set multiple' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'multiple' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("multiple", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("multiple");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get pattern() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pattern' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("pattern");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set pattern(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set pattern' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'pattern' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("pattern", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get placeholder() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get placeholder' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("placeholder");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set placeholder(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set placeholder' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'placeholder' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("placeholder", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get readOnly() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readOnly' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("readonly") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set readOnly(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set readOnly' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'readOnly' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("readonly", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("readonly");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get required() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get required' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("required") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set required(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set required' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'required' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("required", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("required");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get size() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("size");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 1 && value <= 2147483647) {
                        return value;
                    }
                }
                return 20;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set size(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set size' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'size' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === 0) {
                    throw create_DOMException(globalObject, [
                        `The value ${V} cannot be set for the size property.`,
                        "IndexSizeError"
                    ]);
                }
                const newValue = V <= 2147483647 && V >= 1 ? V : 20;
                esValue[implSymbol]._reflectSetTheContentAttribute("size", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get step() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get step' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("step");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set step(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set step' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'step' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("step", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["type"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["type"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get defaultValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultValue' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("value");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultValue(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultValue' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'defaultValue' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("value", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLInputElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get valueAsDate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get valueAsDate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["valueAsDate"];
        }
        set valueAsDate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set valueAsDate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["object"](V, {
                    context: "Failed to set the 'valueAsDate' property on 'HTMLInputElement': The provided value",
                    globals: globalObject
                });
            }
            esValue[implSymbol]["valueAsDate"] = V;
        }
        get valueAsNumber() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get valueAsNumber' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["valueAsNumber"];
        }
        set valueAsNumber(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set valueAsNumber' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["unrestricted double"](V, {
                context: "Failed to set the 'valueAsNumber' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["valueAsNumber"] = V;
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
        get selectionStart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionStart' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["selectionStart"];
        }
        set selectionStart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionStart' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["unsigned long"](V, {
                    context: "Failed to set the 'selectionStart' property on 'HTMLInputElement': The provided value",
                    globals: globalObject
                });
            }
            esValue[implSymbol]["selectionStart"] = V;
        }
        get selectionEnd() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionEnd' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["selectionEnd"];
        }
        set selectionEnd(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionEnd' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["unsigned long"](V, {
                    context: "Failed to set the 'selectionEnd' property on 'HTMLInputElement': The provided value",
                    globals: globalObject
                });
            }
            esValue[implSymbol]["selectionEnd"] = V;
        }
        get selectionDirection() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionDirection' called on an object that is not a valid instance of HTMLInputElement.");
            }
            return esValue[implSymbol]["selectionDirection"];
        }
        set selectionDirection(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionDirection' called on an object that is not a valid instance of HTMLInputElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'selectionDirection' property on 'HTMLInputElement': The provided value",
                    globals: globalObject
                });
            }
            esValue[implSymbol]["selectionDirection"] = V;
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get useMap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get useMap' called on an object that is not a valid instance of HTMLInputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("usemap");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set useMap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set useMap' called on an object that is not a valid instance of HTMLInputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'useMap' property on 'HTMLInputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("usemap", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLInputElement.prototype, {
        stepUp: {
            enumerable: true
        },
        stepDown: {
            enumerable: true
        },
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        select: {
            enumerable: true
        },
        setRangeText: {
            enumerable: true
        },
        setSelectionRange: {
            enumerable: true
        },
        accept: {
            enumerable: true
        },
        alt: {
            enumerable: true
        },
        autocomplete: {
            enumerable: true
        },
        autofocus: {
            enumerable: true
        },
        defaultChecked: {
            enumerable: true
        },
        checked: {
            enumerable: true
        },
        dirName: {
            enumerable: true
        },
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        files: {
            enumerable: true
        },
        formNoValidate: {
            enumerable: true
        },
        formTarget: {
            enumerable: true
        },
        indeterminate: {
            enumerable: true
        },
        inputMode: {
            enumerable: true
        },
        list: {
            enumerable: true
        },
        max: {
            enumerable: true
        },
        maxLength: {
            enumerable: true
        },
        min: {
            enumerable: true
        },
        minLength: {
            enumerable: true
        },
        multiple: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        pattern: {
            enumerable: true
        },
        placeholder: {
            enumerable: true
        },
        readOnly: {
            enumerable: true
        },
        required: {
            enumerable: true
        },
        size: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        step: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        defaultValue: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        valueAsDate: {
            enumerable: true
        },
        valueAsNumber: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        selectionStart: {
            enumerable: true
        },
        selectionEnd: {
            enumerable: true
        },
        selectionDirection: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        useMap: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLInputElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLInputElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLInputElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLInputElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLLabelElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLLabelElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLLabelElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLLabelElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLLabelElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLLabelElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get htmlFor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get htmlFor' called on an object that is not a valid instance of HTMLLabelElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("for");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set htmlFor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set htmlFor' called on an object that is not a valid instance of HTMLLabelElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'htmlFor' property on 'HTMLLabelElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("for", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get control() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get control' called on an object that is not a valid instance of HTMLLabelElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["control"]);
        }
    }
    Object.defineProperties(HTMLLabelElement.prototype, {
        form: {
            enumerable: true
        },
        htmlFor: {
            enumerable: true
        },
        control: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLLabelElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLLabelElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLLabelElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLLabelElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLLegendElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLLegendElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLLegendElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLLegendElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLLegendElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLLegendElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLLegendElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLLegendElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLLegendElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLLegendElement.prototype, {
        form: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLLegendElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLLegendElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLLegendElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLLegendElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMapElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMapElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMapElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMapElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMapElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLMapElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLMapElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLMapElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get areas() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get areas' called on an object that is not a valid instance of HTMLMapElement.");
            }
            return utils.getSameObject(this, "areas", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["areas"]);
            });
        }
    }
    Object.defineProperties(HTMLMapElement.prototype, {
        name: {
            enumerable: true
        },
        areas: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMapElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMapElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMapElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMapElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMarqueeElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMarqueeElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMarqueeElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMarqueeElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMarqueeElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get behavior() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get behavior' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("behavior");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set behavior(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set behavior' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'behavior' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("behavior", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get bgColor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bgColor' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("bgcolor");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set bgColor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set bgColor' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'bgColor' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("bgcolor", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get direction() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get direction' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("direction");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set direction(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set direction' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'direction' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("direction", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'height' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("height", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hspace' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("hspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hspace' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'hspace' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("hspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get scrollAmount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scrollAmount' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("scrollamount");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scrollAmount(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scrollAmount' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'scrollAmount' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("scrollamount", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get scrollDelay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scrollDelay' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("scrolldelay");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scrollDelay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scrollDelay' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'scrollDelay' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("scrolldelay", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get trueSpeed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get trueSpeed' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("truespeed") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set trueSpeed(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set trueSpeed' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'trueSpeed' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("truespeed", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("truespeed");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vspace' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("vspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vspace' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'vspace' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("vspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLMarqueeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLMarqueeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLMarqueeElement.prototype, {
        behavior: {
            enumerable: true
        },
        bgColor: {
            enumerable: true
        },
        direction: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        hspace: {
            enumerable: true
        },
        scrollAmount: {
            enumerable: true
        },
        scrollDelay: {
            enumerable: true
        },
        trueSpeed: {
            enumerable: true
        },
        vspace: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMarqueeElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMarqueeElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMarqueeElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMarqueeElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/TextTrackKind.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "subtitles",
    "captions",
    "descriptions",
    "chapters",
    "metadata"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for TextTrackKind`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMediaElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const TextTrackKind = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/TextTrackKind.js [middleware-edge] (ecmascript)");
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMediaElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMediaElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMediaElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMediaElement extends globalObject.HTMLElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        load() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'load' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol].load();
        }
        canPlayType(type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'canPlayType' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'canPlayType' on 'HTMLMediaElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'canPlayType' on 'HTMLMediaElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].canPlayType(...args));
        }
        play() {
            try {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'play' called on an object that is not a valid instance of HTMLMediaElement.");
                }
                return utils.tryWrapperForImpl(esValue[implSymbol].play());
            } catch (e) {
                return globalObject.Promise.reject(e);
            }
        }
        pause() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'pause' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol].pause();
        }
        addTextTrack(kind) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'addTextTrack' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'addTextTrack' on 'HTMLMediaElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = TextTrackKind.convert(globalObject, curArg, {
                    context: "Failed to execute 'addTextTrack' on 'HTMLMediaElement': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'addTextTrack' on 'HTMLMediaElement': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'addTextTrack' on 'HTMLMediaElement': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].addTextTrack(...args));
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get currentSrc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get currentSrc' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["currentSrc"];
        }
        get crossOrigin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get crossOrigin' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("crossorigin");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set crossOrigin(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set crossOrigin' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'crossOrigin' property on 'HTMLMediaElement': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("crossorigin");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("crossorigin", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get networkState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get networkState' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["networkState"];
        }
        get preload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get preload' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("preload");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set preload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set preload' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'preload' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("preload", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get buffered() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get buffered' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["buffered"]);
        }
        get readyState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readyState' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["readyState"];
        }
        get seeking() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get seeking' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["seeking"];
        }
        get currentTime() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get currentTime' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["currentTime"];
        }
        set currentTime(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set currentTime' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'currentTime' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["currentTime"] = V;
        }
        get duration() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get duration' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["duration"];
        }
        get paused() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get paused' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["paused"];
        }
        get defaultPlaybackRate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultPlaybackRate' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["defaultPlaybackRate"];
        }
        set defaultPlaybackRate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultPlaybackRate' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'defaultPlaybackRate' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["defaultPlaybackRate"] = V;
        }
        get playbackRate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get playbackRate' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["playbackRate"];
        }
        set playbackRate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set playbackRate' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'playbackRate' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["playbackRate"] = V;
        }
        get played() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get played' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["played"]);
        }
        get seekable() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get seekable' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["seekable"]);
        }
        get ended() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ended' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["ended"];
        }
        get autoplay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autoplay' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("autoplay") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autoplay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autoplay' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'autoplay' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("autoplay", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("autoplay");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get loop() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get loop' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("loop") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set loop(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set loop' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'loop' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("loop", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("loop");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get controls() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get controls' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("controls") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set controls(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set controls' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'controls' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("controls", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("controls");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get volume() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get volume' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["volume"];
        }
        set volume(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set volume' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'volume' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["volume"] = V;
        }
        get muted() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get muted' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return esValue[implSymbol]["muted"];
        }
        set muted(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set muted' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'muted' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["muted"] = V;
        }
        get defaultMuted() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultMuted' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("muted") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultMuted(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultMuted' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'defaultMuted' property on 'HTMLMediaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("muted", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("muted");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get audioTracks() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get audioTracks' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.getSameObject(this, "audioTracks", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["audioTracks"]);
            });
        }
        get videoTracks() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get videoTracks' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.getSameObject(this, "videoTracks", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["videoTracks"]);
            });
        }
        get textTracks() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get textTracks' called on an object that is not a valid instance of HTMLMediaElement.");
            }
            return utils.getSameObject(this, "textTracks", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["textTracks"]);
            });
        }
    }
    Object.defineProperties(HTMLMediaElement.prototype, {
        load: {
            enumerable: true
        },
        canPlayType: {
            enumerable: true
        },
        play: {
            enumerable: true
        },
        pause: {
            enumerable: true
        },
        addTextTrack: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        currentSrc: {
            enumerable: true
        },
        crossOrigin: {
            enumerable: true
        },
        networkState: {
            enumerable: true
        },
        preload: {
            enumerable: true
        },
        buffered: {
            enumerable: true
        },
        readyState: {
            enumerable: true
        },
        seeking: {
            enumerable: true
        },
        currentTime: {
            enumerable: true
        },
        duration: {
            enumerable: true
        },
        paused: {
            enumerable: true
        },
        defaultPlaybackRate: {
            enumerable: true
        },
        playbackRate: {
            enumerable: true
        },
        played: {
            enumerable: true
        },
        seekable: {
            enumerable: true
        },
        ended: {
            enumerable: true
        },
        autoplay: {
            enumerable: true
        },
        loop: {
            enumerable: true
        },
        controls: {
            enumerable: true
        },
        volume: {
            enumerable: true
        },
        muted: {
            enumerable: true
        },
        defaultMuted: {
            enumerable: true
        },
        audioTracks: {
            enumerable: true
        },
        videoTracks: {
            enumerable: true
        },
        textTracks: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMediaElement",
            configurable: true
        },
        NETWORK_EMPTY: {
            value: 0,
            enumerable: true
        },
        NETWORK_IDLE: {
            value: 1,
            enumerable: true
        },
        NETWORK_LOADING: {
            value: 2,
            enumerable: true
        },
        NETWORK_NO_SOURCE: {
            value: 3,
            enumerable: true
        },
        HAVE_NOTHING: {
            value: 0,
            enumerable: true
        },
        HAVE_METADATA: {
            value: 1,
            enumerable: true
        },
        HAVE_CURRENT_DATA: {
            value: 2,
            enumerable: true
        },
        HAVE_FUTURE_DATA: {
            value: 3,
            enumerable: true
        },
        HAVE_ENOUGH_DATA: {
            value: 4,
            enumerable: true
        }
    });
    Object.defineProperties(HTMLMediaElement, {
        NETWORK_EMPTY: {
            value: 0,
            enumerable: true
        },
        NETWORK_IDLE: {
            value: 1,
            enumerable: true
        },
        NETWORK_LOADING: {
            value: 2,
            enumerable: true
        },
        NETWORK_NO_SOURCE: {
            value: 3,
            enumerable: true
        },
        HAVE_NOTHING: {
            value: 0,
            enumerable: true
        },
        HAVE_METADATA: {
            value: 1,
            enumerable: true
        },
        HAVE_CURRENT_DATA: {
            value: 2,
            enumerable: true
        },
        HAVE_FUTURE_DATA: {
            value: 3,
            enumerable: true
        },
        HAVE_ENOUGH_DATA: {
            value: 4,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMediaElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMediaElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMediaElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMeterElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLMeterElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLMeterElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLMeterElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLMeterElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'value' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get min() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get min' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["min"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set min(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set min' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'min' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["min"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get max() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get max' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["max"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set max(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set max' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'max' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["max"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get low() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get low' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["low"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set low(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set low' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'low' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["low"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get high() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get high' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["high"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set high(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set high' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'high' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["high"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get optimum() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get optimum' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["optimum"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set optimum(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set optimum' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'optimum' property on 'HTMLMeterElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["optimum"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLMeterElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
    }
    Object.defineProperties(HTMLMeterElement.prototype, {
        value: {
            enumerable: true
        },
        min: {
            enumerable: true
        },
        max: {
            enumerable: true
        },
        low: {
            enumerable: true
        },
        high: {
            enumerable: true
        },
        optimum: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLMeterElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLMeterElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLMeterElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLMeterElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLModElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLModElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLModElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLModElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLModElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get cite() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cite' called on an object that is not a valid instance of HTMLModElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("cite");
                if (value === null) {
                    return "";
                }
                if (this._citeURLCacheKey === value) {
                    return this._citeURLCache;
                }
                this._citeURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._citeURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._citeURLCache;
                }
                this._citeURLCache = conversions.USVString(value);
                return this._citeURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cite(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cite' called on an object that is not a valid instance of HTMLModElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'cite' property on 'HTMLModElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("cite", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get dateTime() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dateTime' called on an object that is not a valid instance of HTMLModElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("datetime");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set dateTime(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set dateTime' called on an object that is not a valid instance of HTMLModElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'dateTime' property on 'HTMLModElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("datetime", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLModElement.prototype, {
        cite: {
            enumerable: true
        },
        dateTime: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLModElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLModElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLModElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLModElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOutputElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLOutputElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLOutputElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLOutputElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLOutputElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLOutputElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLOutputElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        get htmlFor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get htmlFor' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return utils.getSameObject(this, "htmlFor", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["htmlFor"]);
            });
        }
        set htmlFor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set htmlFor' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            const Q = esValue["htmlFor"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'htmlFor' is not an object");
            }
            Reflect.set(Q, "value", V);
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLOutputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return esValue[implSymbol]["type"];
        }
        get defaultValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultValue' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["defaultValue"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultValue(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultValue' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'defaultValue' property on 'HTMLOutputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["defaultValue"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLOutputElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLOutputElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
    }
    Object.defineProperties(HTMLOutputElement.prototype, {
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        htmlFor: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        defaultValue: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLOutputElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLOutputElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLOutputElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOutputElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLPictureElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLPictureElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLPictureElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLPictureElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLPictureElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
    }
    Object.defineProperties(HTMLPictureElement.prototype, {
        [Symbol.toStringTag]: {
            value: "HTMLPictureElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLPictureElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLPictureElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLPictureElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLProgressElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const parseFloatingPointNumber_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseFloatingPointNumber;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLProgressElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLProgressElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLProgressElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLProgressElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'value' property on 'HTMLProgressElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get max() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get max' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("max");
                if (value !== null) {
                    value = parseFloatingPointNumber_helpers_strings(value);
                    if (value !== null && value > 0) {
                        return value;
                    }
                }
                return 1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set max(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set max' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            V = conversions["double"](V, {
                context: "Failed to set the 'max' property on 'HTMLProgressElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V > 0) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("max", String(V));
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get position() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get position' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            return esValue[implSymbol]["position"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLProgressElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
    }
    Object.defineProperties(HTMLProgressElement.prototype, {
        value: {
            enumerable: true
        },
        max: {
            enumerable: true
        },
        position: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLProgressElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLProgressElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLProgressElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLProgressElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLQuoteElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLQuoteElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLQuoteElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLQuoteElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLQuoteElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get cite() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cite' called on an object that is not a valid instance of HTMLQuoteElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("cite");
                if (value === null) {
                    return "";
                }
                if (this._citeURLCacheKey === value) {
                    return this._citeURLCache;
                }
                this._citeURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._citeURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._citeURLCache;
                }
                this._citeURLCache = conversions.USVString(value);
                return this._citeURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cite(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cite' called on an object that is not a valid instance of HTMLQuoteElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'cite' property on 'HTMLQuoteElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("cite", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLQuoteElement.prototype, {
        cite: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLQuoteElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLQuoteElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLQuoteElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLQuoteElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLScriptElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLScriptElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLScriptElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLScriptElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLScriptElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get defer() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defer' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("defer") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defer(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defer' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'defer' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("defer", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("defer");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get crossOrigin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get crossOrigin' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("crossorigin");
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set crossOrigin(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set crossOrigin' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = conversions["DOMString"](V, {
                    context: "Failed to set the 'crossOrigin' property on 'HTMLScriptElement': The provided value",
                    globals: globalObject
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V === null) {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("crossorigin");
                } else {
                    esValue[implSymbol]._reflectSetTheContentAttribute("crossorigin", V);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get text() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get text' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["text"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set text(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set text' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'text' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["text"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get charset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get charset' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charset");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set charset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set charset' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'charset' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get event() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get event' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("event");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set event(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set event' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'event' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("event", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get htmlFor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get htmlFor' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("for");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set htmlFor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set htmlFor' called on an object that is not a valid instance of HTMLScriptElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'htmlFor' property on 'HTMLScriptElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("for", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLScriptElement.prototype, {
        src: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        defer: {
            enumerable: true
        },
        crossOrigin: {
            enumerable: true
        },
        text: {
            enumerable: true
        },
        charset: {
            enumerable: true
        },
        event: {
            enumerable: true
        },
        htmlFor: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLScriptElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLScriptElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLScriptElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLScriptElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLSelectElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const HTMLOptionElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptionElement.js [middleware-edge] (ecmascript)");
const HTMLOptGroupElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptGroupElement.js [middleware-edge] (ecmascript)");
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "HTMLSelectElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLSelectElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLSelectElement"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLSelectElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'HTMLSelectElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'HTMLSelectElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'HTMLSelectElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'HTMLSelectElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].namedItem(...args));
        }
        add(element) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'add' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'add' on 'HTMLSelectElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (HTMLOptionElement.is(curArg) || HTMLOptGroupElement.is(curArg)) {
                    curArg = utils.implForWrapper(curArg);
                } else {
                    throw new globalObject.TypeError("Failed to execute 'add' on 'HTMLSelectElement': parameter 1" + " is not of any supported type.");
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        if (HTMLElement.is(curArg)) {
                            curArg = utils.implForWrapper(curArg);
                        } else if (typeof curArg === "number") {
                            curArg = conversions["long"](curArg, {
                                context: "Failed to execute 'add' on 'HTMLSelectElement': parameter 2",
                                globals: globalObject
                            });
                        } else {
                            curArg = conversions["long"](curArg, {
                                context: "Failed to execute 'add' on 'HTMLSelectElement': parameter 2",
                                globals: globalObject
                            });
                        }
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].add(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        remove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'remove' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            const args = [];
            switch(arguments.length){
                case 0:
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["long"](curArg, {
                            context: "Failed to execute 'remove' on 'HTMLSelectElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].remove(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLSelectElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLSelectElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        get autofocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autofocus' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("autofocus") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autofocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autofocus' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'autofocus' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("autofocus", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("autofocus");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get multiple() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get multiple' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("multiple") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set multiple(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set multiple' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'multiple' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("multiple", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("multiple");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get required() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get required' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("required") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set required(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set required' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'required' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("required", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("required");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get size() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("size");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set size(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set size' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'size' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("size", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol]["type"];
        }
        get options() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get options' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return utils.getSameObject(this, "options", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["options"]);
            });
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["length"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set length(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set length' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'length' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["length"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get selectedOptions() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectedOptions' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return utils.getSameObject(this, "selectedOptions", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["selectedOptions"]);
            });
        }
        get selectedIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectedIndex' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol]["selectedIndex"];
        }
        set selectedIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectedIndex' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'selectedIndex' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selectedIndex"] = V;
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol]["value"];
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLSelectElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["value"] = V;
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLSelectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
    }
    Object.defineProperties(HTMLSelectElement.prototype, {
        item: {
            enumerable: true
        },
        namedItem: {
            enumerable: true
        },
        add: {
            enumerable: true
        },
        remove: {
            enumerable: true
        },
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        autofocus: {
            enumerable: true
        },
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        multiple: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        required: {
            enumerable: true
        },
        size: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        options: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        selectedOptions: {
            enumerable: true
        },
        selectedIndex: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLSelectElement",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLSelectElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLSelectElement
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
            if (utils.isArrayIndexPropName(P)) {
                const index = P >>> 0;
                let indexedValue = V;
                if (indexedValue === null || indexedValue === undefined) {
                    indexedValue = null;
                } else {
                    indexedValue = HTMLOptionElement.convert(globalObject, indexedValue, {
                        context: "Failed to set the " + index + " property on 'HTMLSelectElement': The provided value"
                    });
                }
                ceReactionsPreSteps_helpers_custom_elements(globalObject);
                try {
                    const creating = !(target[implSymbol].item(index) !== null);
                    if (creating) {
                        target[implSymbol][utils.indexedSetNew](index, indexedValue);
                    } else {
                        target[implSymbol][utils.indexedSetExisting](index, indexedValue);
                    }
                } finally{
                    ceReactionsPostSteps_helpers_custom_elements(globalObject);
                }
                return true;
            }
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            if (desc.get || desc.set) {
                return false;
            }
            const index = P >>> 0;
            let indexedValue = desc.value;
            if (indexedValue === null || indexedValue === undefined) {
                indexedValue = null;
            } else {
                indexedValue = HTMLOptionElement.convert(globalObject, indexedValue, {
                    context: "Failed to set the " + index + " property on 'HTMLSelectElement': The provided value"
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const creating = !(target[implSymbol].item(index) !== null);
                if (creating) {
                    target[implSymbol][utils.indexedSetNew](index, indexedValue);
                } else {
                    target[implSymbol][utils.indexedSetExisting](index, indexedValue);
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
            return true;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLSelectElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/AssignedNodesOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "flatten";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'flatten' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLSlotElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const AssignedNodesOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/AssignedNodesOptions.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLSlotElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLSlotElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLSlotElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLSlotElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        assignedNodes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'assignedNodes' called on an object that is not a valid instance of HTMLSlotElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = AssignedNodesOptions.convert(globalObject, curArg, {
                    context: "Failed to execute 'assignedNodes' on 'HTMLSlotElement': parameter 1"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].assignedNodes(...args));
        }
        assignedElements() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'assignedElements' called on an object that is not a valid instance of HTMLSlotElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = AssignedNodesOptions.convert(globalObject, curArg, {
                    context: "Failed to execute 'assignedElements' on 'HTMLSlotElement': parameter 1"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].assignedElements(...args));
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLSlotElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLSlotElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLSlotElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLSlotElement.prototype, {
        assignedNodes: {
            enumerable: true
        },
        assignedElements: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLSlotElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLSlotElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLSlotElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLSlotElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLSourceElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLSourceElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLSourceElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLSourceElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLSourceElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLSourceElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLSourceElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get srcset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get srcset' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("srcset");
                return value === null ? "" : conversions.USVString(value);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set srcset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set srcset' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'srcset' property on 'HTMLSourceElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("srcset", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get sizes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get sizes' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("sizes");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set sizes(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set sizes' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'sizes' property on 'HTMLSourceElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("sizes", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get media() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get media' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("media");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set media(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set media' called on an object that is not a valid instance of HTMLSourceElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'media' property on 'HTMLSourceElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("media", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLSourceElement.prototype, {
        src: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        srcset: {
            enumerable: true
        },
        sizes: {
            enumerable: true
        },
        media: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLSourceElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLSourceElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLSourceElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLSourceElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLSpanElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLSpanElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLSpanElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLSpanElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLSpanElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
    }
    Object.defineProperties(HTMLSpanElement.prototype, {
        [Symbol.toStringTag]: {
            value: "HTMLSpanElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLSpanElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLSpanElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLSpanElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableCaptionElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableCaptionElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableCaptionElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableCaptionElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableCaptionElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableCaptionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableCaptionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableCaptionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableCaptionElement.prototype, {
        align: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableCaptionElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableCaptionElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableCaptionElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableCaptionElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableCellElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableCellElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableCellElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableCellElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableCellElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get colSpan() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get colSpan' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("colspan");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null) {
                        if (value < 1) {
                            return 1;
                        } else if (value >= 1 && value <= 1000) {
                            return value;
                        } else {
                            return 1000;
                        }
                    }
                }
                return 1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set colSpan(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set colSpan' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'colSpan' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 1;
                esValue[implSymbol]._reflectSetTheContentAttribute("colspan", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rowSpan() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rowSpan' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("rowspan");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null) {
                        if (value < 0) {
                            return 0;
                        } else if (value >= 0 && value <= 65534) {
                            return value;
                        } else {
                            return 65534;
                        }
                    }
                }
                return 1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rowSpan(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rowSpan' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'rowSpan' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 1;
                esValue[implSymbol]._reflectSetTheContentAttribute("rowspan", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get headers() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get headers' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("headers");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set headers(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set headers' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'headers' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("headers", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get cellIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cellIndex' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            return esValue[implSymbol]["cellIndex"];
        }
        get scope() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scope' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["scope"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scope(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scope' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'scope' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["scope"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get abbr() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get abbr' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("abbr");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set abbr(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set abbr' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'abbr' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("abbr", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get axis() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get axis' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("axis");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set axis(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set axis' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'axis' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("axis", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'height' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("height", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ch' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("char");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ch' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'ch' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("char", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get chOff() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get chOff' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charoff");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set chOff(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set chOff' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'chOff' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charoff", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get noWrap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get noWrap' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("nowrap") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set noWrap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set noWrap' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'noWrap' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("nowrap", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("nowrap");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vAlign() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vAlign' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("valign");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vAlign(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vAlign' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'vAlign' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("valign", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get bgColor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bgColor' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("bgcolor");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set bgColor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set bgColor' called on an object that is not a valid instance of HTMLTableCellElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'bgColor' property on 'HTMLTableCellElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("bgcolor", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableCellElement.prototype, {
        colSpan: {
            enumerable: true
        },
        rowSpan: {
            enumerable: true
        },
        headers: {
            enumerable: true
        },
        cellIndex: {
            enumerable: true
        },
        scope: {
            enumerable: true
        },
        abbr: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        axis: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        ch: {
            enumerable: true
        },
        chOff: {
            enumerable: true
        },
        noWrap: {
            enumerable: true
        },
        vAlign: {
            enumerable: true
        },
        bgColor: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableCellElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableCellElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableCellElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableCellElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableColElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableColElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableColElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableColElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableColElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get span() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get span' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("span");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null) {
                        if (value < 1) {
                            return 1;
                        } else if (value >= 1 && value <= 1000) {
                            return value;
                        } else {
                            return 1000;
                        }
                    }
                }
                return 1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set span(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set span' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'span' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 1;
                esValue[implSymbol]._reflectSetTheContentAttribute("span", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ch' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("char");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ch' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'ch' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("char", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get chOff() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get chOff' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charoff");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set chOff(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set chOff' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'chOff' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charoff", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vAlign() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vAlign' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("valign");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vAlign(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vAlign' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'vAlign' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("valign", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLTableColElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLTableColElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableColElement.prototype, {
        span: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        ch: {
            enumerable: true
        },
        chOff: {
            enumerable: true
        },
        vAlign: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableColElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableColElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableColElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableColElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableSectionElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableSectionElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableSectionElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableSectionElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableSectionElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        insertRow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertRow' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'insertRow' on 'HTMLTableSectionElement': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = -1;
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].insertRow(...args));
        }
        deleteRow(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteRow' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'deleteRow' on 'HTMLTableSectionElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["long"](curArg, {
                    context: "Failed to execute 'deleteRow' on 'HTMLTableSectionElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteRow(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rows() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rows' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            return utils.getSameObject(this, "rows", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["rows"]);
            });
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableSectionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ch' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("char");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ch' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'ch' property on 'HTMLTableSectionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("char", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get chOff() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get chOff' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charoff");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set chOff(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set chOff' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'chOff' property on 'HTMLTableSectionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charoff", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vAlign() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vAlign' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("valign");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vAlign(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vAlign' called on an object that is not a valid instance of HTMLTableSectionElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'vAlign' property on 'HTMLTableSectionElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("valign", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableSectionElement.prototype, {
        insertRow: {
            enumerable: true
        },
        deleteRow: {
            enumerable: true
        },
        rows: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        ch: {
            enumerable: true
        },
        chOff: {
            enumerable: true
        },
        vAlign: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableSectionElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableSectionElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableSectionElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableSectionElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const HTMLTableCaptionElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableCaptionElement.js [middleware-edge] (ecmascript)");
const HTMLTableSectionElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableSectionElement.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        createCaption() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createCaption' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createCaption());
        }
        deleteCaption() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteCaption' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteCaption();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        createTHead() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createTHead' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createTHead());
        }
        deleteTHead() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteTHead' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteTHead();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        createTFoot() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createTFoot' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createTFoot());
        }
        deleteTFoot() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteTFoot' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteTFoot();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        createTBody() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createTBody' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createTBody());
        }
        insertRow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertRow' called on an object that is not a valid instance of HTMLTableElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'insertRow' on 'HTMLTableElement': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = -1;
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].insertRow(...args));
        }
        deleteRow(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteRow' called on an object that is not a valid instance of HTMLTableElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'deleteRow' on 'HTMLTableElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["long"](curArg, {
                    context: "Failed to execute 'deleteRow' on 'HTMLTableElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteRow(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get caption() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get caption' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol]["caption"]);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set caption(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set caption' called on an object that is not a valid instance of HTMLTableElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = HTMLTableCaptionElement.convert(globalObject, V, {
                    context: "Failed to set the 'caption' property on 'HTMLTableElement': The provided value"
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["caption"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get tHead() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tHead' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol]["tHead"]);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set tHead(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set tHead' called on an object that is not a valid instance of HTMLTableElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = HTMLTableSectionElement.convert(globalObject, V, {
                    context: "Failed to set the 'tHead' property on 'HTMLTableElement': The provided value"
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["tHead"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get tFoot() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tFoot' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return utils.tryWrapperForImpl(esValue[implSymbol]["tFoot"]);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set tFoot(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set tFoot' called on an object that is not a valid instance of HTMLTableElement.");
            }
            if (V === null || V === undefined) {
                V = null;
            } else {
                V = HTMLTableSectionElement.convert(globalObject, V, {
                    context: "Failed to set the 'tFoot' property on 'HTMLTableElement': The provided value"
                });
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["tFoot"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get tBodies() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tBodies' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.getSameObject(this, "tBodies", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["tBodies"]);
            });
        }
        get rows() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rows' called on an object that is not a valid instance of HTMLTableElement.");
            }
            return utils.getSameObject(this, "rows", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["rows"]);
            });
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get border() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get border' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("border");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set border(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set border' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'border' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("border", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get frame() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get frame' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("frame");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set frame(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set frame' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'frame' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("frame", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rules() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rules' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rules");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rules(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rules' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rules' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rules", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get summary() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get summary' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("summary");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set summary(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set summary' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'summary' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("summary", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLTableElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get bgColor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bgColor' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("bgcolor");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set bgColor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set bgColor' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'bgColor' property on 'HTMLTableElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("bgcolor", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get cellPadding() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cellPadding' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("cellpadding");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cellPadding(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cellPadding' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'cellPadding' property on 'HTMLTableElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("cellpadding", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get cellSpacing() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cellSpacing' called on an object that is not a valid instance of HTMLTableElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("cellspacing");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cellSpacing(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cellSpacing' called on an object that is not a valid instance of HTMLTableElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'cellSpacing' property on 'HTMLTableElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("cellspacing", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableElement.prototype, {
        createCaption: {
            enumerable: true
        },
        deleteCaption: {
            enumerable: true
        },
        createTHead: {
            enumerable: true
        },
        deleteTHead: {
            enumerable: true
        },
        createTFoot: {
            enumerable: true
        },
        deleteTFoot: {
            enumerable: true
        },
        createTBody: {
            enumerable: true
        },
        insertRow: {
            enumerable: true
        },
        deleteRow: {
            enumerable: true
        },
        caption: {
            enumerable: true
        },
        tHead: {
            enumerable: true
        },
        tFoot: {
            enumerable: true
        },
        tBodies: {
            enumerable: true
        },
        rows: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        border: {
            enumerable: true
        },
        frame: {
            enumerable: true
        },
        rules: {
            enumerable: true
        },
        summary: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        bgColor: {
            enumerable: true
        },
        cellPadding: {
            enumerable: true
        },
        cellSpacing: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTimeElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTimeElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTimeElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTimeElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTimeElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get dateTime() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dateTime' called on an object that is not a valid instance of HTMLTimeElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("datetime");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set dateTime(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set dateTime' called on an object that is not a valid instance of HTMLTimeElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'dateTime' property on 'HTMLTimeElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("datetime", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTimeElement.prototype, {
        dateTime: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTimeElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTimeElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTimeElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTimeElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTableRowElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTableRowElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTableRowElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTableRowElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTableRowElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        insertCell() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertCell' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long"](curArg, {
                        context: "Failed to execute 'insertCell' on 'HTMLTableRowElement': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = -1;
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].insertCell(...args));
        }
        deleteCell(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteCell' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'deleteCell' on 'HTMLTableRowElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["long"](curArg, {
                    context: "Failed to execute 'deleteCell' on 'HTMLTableRowElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteCell(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rowIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rowIndex' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            return esValue[implSymbol]["rowIndex"];
        }
        get sectionRowIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get sectionRowIndex' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            return esValue[implSymbol]["sectionRowIndex"];
        }
        get cells() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cells' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            return utils.getSameObject(this, "cells", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["cells"]);
            });
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLTableRowElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get ch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ch' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("char");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set ch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ch' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'ch' property on 'HTMLTableRowElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("char", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get chOff() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get chOff' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("charoff");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set chOff(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set chOff' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'chOff' property on 'HTMLTableRowElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("charoff", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vAlign() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vAlign' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("valign");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vAlign(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vAlign' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'vAlign' property on 'HTMLTableRowElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("valign", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get bgColor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bgColor' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("bgcolor");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set bgColor(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set bgColor' called on an object that is not a valid instance of HTMLTableRowElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'bgColor' property on 'HTMLTableRowElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("bgcolor", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLTableRowElement.prototype, {
        insertCell: {
            enumerable: true
        },
        deleteCell: {
            enumerable: true
        },
        rowIndex: {
            enumerable: true
        },
        sectionRowIndex: {
            enumerable: true
        },
        cells: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        ch: {
            enumerable: true
        },
        chOff: {
            enumerable: true
        },
        vAlign: {
            enumerable: true
        },
        bgColor: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTableRowElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTableRowElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTableRowElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTableRowElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTemplateElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTemplateElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTemplateElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTemplateElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTemplateElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get content() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get content' called on an object that is not a valid instance of HTMLTemplateElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["content"]);
        }
    }
    Object.defineProperties(HTMLTemplateElement.prototype, {
        content: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTemplateElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTemplateElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTemplateElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTemplateElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTextAreaElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const SelectionMode = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SelectionMode.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const create_DOMException = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMException.js [middleware-edge] (ecmascript)").create;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTextAreaElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTextAreaElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTextAreaElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTextAreaElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLTextAreaElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLTextAreaElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        select() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'select' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol].select();
        }
        setRangeText(replacement) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setRangeText' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setRangeText' on 'HTMLTextAreaElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            switch(arguments.length){
                case 1:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                case 2:
                    throw new globalObject.TypeError(`Failed to execute 'setRangeText' on 'HTMLTextAreaElement': only ${arguments.length} arguments present.`);
                    break;
                case 3:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["unsigned long"](curArg, {
                            context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[3];
                        if (curArg !== undefined) {
                            curArg = SelectionMode.convert(globalObject, curArg, {
                                context: "Failed to execute 'setRangeText' on 'HTMLTextAreaElement': parameter 4"
                            });
                        } else {
                            curArg = "preserve";
                        }
                        args.push(curArg);
                    }
            }
            return esValue[implSymbol].setRangeText(...args);
        }
        setSelectionRange(start, end) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setSelectionRange' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setSelectionRange' on 'HTMLTextAreaElement': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setSelectionRange' on 'HTMLTextAreaElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setSelectionRange' on 'HTMLTextAreaElement': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'setSelectionRange' on 'HTMLTextAreaElement': parameter 3",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].setSelectionRange(...args);
        }
        get autocomplete() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autocomplete' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("autocomplete");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autocomplete(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autocomplete' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'autocomplete' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("autocomplete", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get autofocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get autofocus' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("autofocus") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set autofocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set autofocus' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'autofocus' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("autofocus", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("autofocus");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get cols() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cols' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("cols");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 1 && value <= 2147483647) {
                        return value;
                    }
                }
                return 20;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cols(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cols' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'cols' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 1 ? V : 20;
                esValue[implSymbol]._reflectSetTheContentAttribute("cols", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get dirName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dirName' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("dirname");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set dirName(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set dirName' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'dirName' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("dirname", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get disabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get disabled' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("disabled") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set disabled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set disabled' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'disabled' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("disabled", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("disabled");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get inputMode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get inputMode' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("inputmode");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set inputMode(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set inputMode' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'inputMode' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("inputmode", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get maxLength() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get maxLength' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("maxlength");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return -1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set maxLength(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set maxLength' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'maxLength' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V < 0) {
                    throw create_DOMException(globalObject, [
                        `The negative value ${V} cannot be set for the maxLength property.`,
                        "IndexSizeError"
                    ]);
                }
                esValue[implSymbol]._reflectSetTheContentAttribute("maxlength", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get minLength() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get minLength' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("minlength");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && conversions.long(value) === value) {
                        return value;
                    }
                }
                return -1;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set minLength(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set minLength' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'minLength' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V < 0) {
                    throw create_DOMException(globalObject, [
                        `The negative value ${V} cannot be set for the minLength property.`,
                        "IndexSizeError"
                    ]);
                }
                esValue[implSymbol]._reflectSetTheContentAttribute("minlength", String(V));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get placeholder() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get placeholder' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("placeholder");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set placeholder(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set placeholder' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'placeholder' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("placeholder", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get readOnly() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readOnly' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("readonly") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set readOnly(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set readOnly' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'readOnly' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("readonly", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("readonly");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get required() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get required' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("required") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set required(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set required' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'required' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("required", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("required");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rows() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rows' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("rows");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 1 && value <= 2147483647) {
                        return value;
                    }
                }
                return 2;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rows(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rows' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'rows' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 1 ? V : 2;
                esValue[implSymbol]._reflectSetTheContentAttribute("rows", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get wrap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get wrap' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("wrap");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set wrap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set wrap' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'wrap' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("wrap", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["type"];
        }
        get defaultValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get defaultValue' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["defaultValue"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set defaultValue(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set defaultValue' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'defaultValue' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["defaultValue"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["value"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["value"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get textLength() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get textLength' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["textLength"];
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get labels() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get labels' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["labels"]);
        }
        get selectionStart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionStart' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["selectionStart"];
        }
        set selectionStart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionStart' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'selectionStart' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selectionStart"] = V;
        }
        get selectionEnd() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionEnd' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["selectionEnd"];
        }
        set selectionEnd(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionEnd' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'selectionEnd' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selectionEnd"] = V;
        }
        get selectionDirection() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get selectionDirection' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            return esValue[implSymbol]["selectionDirection"];
        }
        set selectionDirection(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set selectionDirection' called on an object that is not a valid instance of HTMLTextAreaElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'selectionDirection' property on 'HTMLTextAreaElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["selectionDirection"] = V;
        }
    }
    Object.defineProperties(HTMLTextAreaElement.prototype, {
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        select: {
            enumerable: true
        },
        setRangeText: {
            enumerable: true
        },
        setSelectionRange: {
            enumerable: true
        },
        autocomplete: {
            enumerable: true
        },
        autofocus: {
            enumerable: true
        },
        cols: {
            enumerable: true
        },
        dirName: {
            enumerable: true
        },
        disabled: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        inputMode: {
            enumerable: true
        },
        maxLength: {
            enumerable: true
        },
        minLength: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        placeholder: {
            enumerable: true
        },
        readOnly: {
            enumerable: true
        },
        required: {
            enumerable: true
        },
        rows: {
            enumerable: true
        },
        wrap: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        defaultValue: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        textLength: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        labels: {
            enumerable: true
        },
        selectionStart: {
            enumerable: true
        },
        selectionEnd: {
            enumerable: true
        },
        selectionDirection: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTextAreaElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTextAreaElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTextAreaElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTextAreaElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLUnknownElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLUnknownElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLUnknownElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLUnknownElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLUnknownElement extends globalObject.HTMLElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(HTMLUnknownElement.prototype, {
        [Symbol.toStringTag]: {
            value: "HTMLUnknownElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLUnknownElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLUnknownElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLUnknownElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFrameElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLFrameElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFrameElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFrameElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFrameElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get scrolling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scrolling' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("scrolling");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scrolling(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scrolling' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'scrolling' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("scrolling", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get frameBorder() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get frameBorder' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("frameborder");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set frameBorder(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set frameBorder' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'frameBorder' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("frameborder", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get longDesc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get longDesc' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("longdesc");
                if (value === null) {
                    return "";
                }
                if (this._longdescURLCacheKey === value) {
                    return this._longdescURLCache;
                }
                this._longdescURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._longdescURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._longdescURLCache;
                }
                this._longdescURLCache = conversions.USVString(value);
                return this._longdescURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set longDesc(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set longDesc' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'longDesc' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("longdesc", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get noResize() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get noResize' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("noresize") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set noResize(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set noResize' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'noResize' property on 'HTMLFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("noresize", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("noresize");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get contentDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get contentDocument' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["contentDocument"]);
        }
        get contentWindow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get contentWindow' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["contentWindow"]);
        }
        get marginHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get marginHeight' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("marginheight");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set marginHeight(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set marginHeight' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'marginHeight' property on 'HTMLFrameElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("marginheight", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get marginWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get marginWidth' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("marginwidth");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set marginWidth(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set marginWidth' called on an object that is not a valid instance of HTMLFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'marginWidth' property on 'HTMLFrameElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("marginwidth", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLFrameElement.prototype, {
        name: {
            enumerable: true
        },
        scrolling: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        frameBorder: {
            enumerable: true
        },
        longDesc: {
            enumerable: true
        },
        noResize: {
            enumerable: true
        },
        contentDocument: {
            enumerable: true
        },
        contentWindow: {
            enumerable: true
        },
        marginHeight: {
            enumerable: true
        },
        marginWidth: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFrameElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFrameElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFrameElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFrameElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFrameSetElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const OnBeforeUnloadEventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/OnBeforeUnloadEventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLFrameSetElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLFrameSetElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLFrameSetElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLFrameSetElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get cols() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cols' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("cols");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set cols(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set cols' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'cols' property on 'HTMLFrameSetElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("cols", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get rows() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rows' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("rows");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set rows(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set rows' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'rows' property on 'HTMLFrameSetElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("rows", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get onafterprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onafterprint' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onafterprint"]);
        }
        set onafterprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onafterprint' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onafterprint' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onafterprint"] = V;
        }
        get onbeforeprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeprint' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeprint"]);
        }
        set onbeforeprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeprint' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeprint' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeprint"] = V;
        }
        get onbeforeunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeunload' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeunload"]);
        }
        set onbeforeunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeunload' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = OnBeforeUnloadEventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeunload' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeunload"] = V;
        }
        get onhashchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onhashchange' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onhashchange"]);
        }
        set onhashchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onhashchange' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onhashchange' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onhashchange"] = V;
        }
        get onlanguagechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onlanguagechange' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onlanguagechange"]);
        }
        set onlanguagechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onlanguagechange' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onlanguagechange' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onlanguagechange"] = V;
        }
        get onmessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessage' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessage"]);
        }
        set onmessage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessage' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessage' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessage"] = V;
        }
        get onmessageerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessageerror' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessageerror"]);
        }
        set onmessageerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessageerror' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessageerror' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessageerror"] = V;
        }
        get onoffline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onoffline' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onoffline"]);
        }
        set onoffline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onoffline' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onoffline' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onoffline"] = V;
        }
        get ononline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ononline' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ononline"]);
        }
        set ononline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ononline' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ononline' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["ononline"] = V;
        }
        get onpagehide() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpagehide' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpagehide"]);
        }
        set onpagehide(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpagehide' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpagehide' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onpagehide"] = V;
        }
        get onpageshow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpageshow' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpageshow"]);
        }
        set onpageshow(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpageshow' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpageshow' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onpageshow"] = V;
        }
        get onpopstate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpopstate' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpopstate"]);
        }
        set onpopstate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpopstate' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpopstate' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onpopstate"] = V;
        }
        get onrejectionhandled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onrejectionhandled' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onrejectionhandled"]);
        }
        set onrejectionhandled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onrejectionhandled' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onrejectionhandled' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onrejectionhandled"] = V;
        }
        get onstorage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onstorage' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onstorage"]);
        }
        set onstorage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onstorage' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onstorage' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onstorage"] = V;
        }
        get onunhandledrejection() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunhandledrejection' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunhandledrejection"]);
        }
        set onunhandledrejection(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunhandledrejection' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunhandledrejection' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onunhandledrejection"] = V;
        }
        get onunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunload' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunload"]);
        }
        set onunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunload' called on an object that is not a valid instance of HTMLFrameSetElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunload' property on 'HTMLFrameSetElement': The provided value"
                });
            }
            esValue[implSymbol]["onunload"] = V;
        }
    }
    Object.defineProperties(HTMLFrameSetElement.prototype, {
        cols: {
            enumerable: true
        },
        rows: {
            enumerable: true
        },
        onafterprint: {
            enumerable: true
        },
        onbeforeprint: {
            enumerable: true
        },
        onbeforeunload: {
            enumerable: true
        },
        onhashchange: {
            enumerable: true
        },
        onlanguagechange: {
            enumerable: true
        },
        onmessage: {
            enumerable: true
        },
        onmessageerror: {
            enumerable: true
        },
        onoffline: {
            enumerable: true
        },
        ononline: {
            enumerable: true
        },
        onpagehide: {
            enumerable: true
        },
        onpageshow: {
            enumerable: true
        },
        onpopstate: {
            enumerable: true
        },
        onrejectionhandled: {
            enumerable: true
        },
        onstorage: {
            enumerable: true
        },
        onunhandledrejection: {
            enumerable: true
        },
        onunload: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLFrameSetElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLFrameSetElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLFrameSetElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLFrameSetElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLIFrameElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLIFrameElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLIFrameElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLIFrameElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLIFrameElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        getSVGDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getSVGDocument' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getSVGDocument());
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get srcdoc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get srcdoc' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("srcdoc");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set srcdoc(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set srcdoc' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'srcdoc' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("srcdoc", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get allowFullscreen() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get allowFullscreen' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("allowfullscreen") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set allowFullscreen(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set allowFullscreen' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'allowFullscreen' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("allowfullscreen", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("allowfullscreen");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'height' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("height", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get contentDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get contentDocument' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["contentDocument"]);
        }
        get contentWindow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get contentWindow' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["contentWindow"]);
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get scrolling() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get scrolling' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("scrolling");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set scrolling(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set scrolling' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'scrolling' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("scrolling", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get frameBorder() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get frameBorder' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("frameborder");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set frameBorder(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set frameBorder' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'frameBorder' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("frameborder", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get longDesc() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get longDesc' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("longdesc");
                if (value === null) {
                    return "";
                }
                if (this._longdescURLCacheKey === value) {
                    return this._longdescURLCache;
                }
                this._longdescURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._longdescURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._longdescURLCache;
                }
                this._longdescURLCache = conversions.USVString(value);
                return this._longdescURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set longDesc(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set longDesc' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'longDesc' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("longdesc", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get marginHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get marginHeight' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("marginheight");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set marginHeight(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set marginHeight' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'marginHeight' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("marginheight", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get marginWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get marginWidth' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("marginwidth");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set marginWidth(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set marginWidth' called on an object that is not a valid instance of HTMLIFrameElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'marginWidth' property on 'HTMLIFrameElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("marginwidth", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLIFrameElement.prototype, {
        getSVGDocument: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        srcdoc: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        allowFullscreen: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        contentDocument: {
            enumerable: true
        },
        contentWindow: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        scrolling: {
            enumerable: true
        },
        frameBorder: {
            enumerable: true
        },
        longDesc: {
            enumerable: true
        },
        marginHeight: {
            enumerable: true
        },
        marginWidth: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLIFrameElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLIFrameElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLIFrameElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLIFrameElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLEmbedElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLEmbedElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLEmbedElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLEmbedElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLEmbedElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'height' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("height", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLEmbedElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLEmbedElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLEmbedElement.prototype, {
        src: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLEmbedElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLEmbedElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLEmbedElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLEmbedElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLObjectElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLObjectElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLObjectElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLObjectElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLObjectElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        checkValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'checkValidity' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return esValue[implSymbol].checkValidity();
        }
        reportValidity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'reportValidity' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return esValue[implSymbol].reportValidity();
        }
        setCustomValidity(error) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setCustomValidity' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setCustomValidity' on 'HTMLObjectElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setCustomValidity' on 'HTMLObjectElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setCustomValidity(...args);
        }
        get data() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get data' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("data");
                if (value === null) {
                    return "";
                }
                if (this._dataURLCacheKey === value) {
                    return this._dataURLCache;
                }
                this._dataURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._dataURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._dataURLCache;
                }
                this._dataURLCache = conversions.USVString(value);
                return this._dataURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set data(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set data' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'data' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("data", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get useMap() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get useMap' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("usemap");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set useMap(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set useMap' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'useMap' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("usemap", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get form() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get form' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["form"]);
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'width' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("width", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'height' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("height", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get contentDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get contentDocument' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["contentDocument"]);
        }
        get willValidate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get willValidate' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return esValue[implSymbol]["willValidate"];
        }
        get validity() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validity' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["validity"]);
        }
        get validationMessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get validationMessage' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            return esValue[implSymbol]["validationMessage"];
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("align");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'align' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("align", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get archive() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get archive' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("archive");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set archive(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set archive' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'archive' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("archive", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get code() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get code' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("code");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set code(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set code' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'code' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("code", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get declare() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get declare' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("declare") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set declare(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set declare' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'declare' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("declare", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("declare");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get hspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hspace' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("hspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set hspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set hspace' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'hspace' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("hspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get standby() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get standby' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("standby");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set standby(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set standby' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'standby' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("standby", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get vspace() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vspace' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("vspace");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set vspace(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set vspace' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'vspace' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("vspace", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get codeBase() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get codeBase' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("codebase");
                if (value === null) {
                    return "";
                }
                if (this._codebaseURLCacheKey === value) {
                    return this._codebaseURLCache;
                }
                this._codebaseURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._codebaseURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._codebaseURLCache;
                }
                this._codebaseURLCache = conversions.USVString(value);
                return this._codebaseURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set codeBase(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set codeBase' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'codeBase' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("codebase", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get codeType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get codeType' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("codetype");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set codeType(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set codeType' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'codeType' property on 'HTMLObjectElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("codetype", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get border() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get border' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("border");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set border(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set border' called on an object that is not a valid instance of HTMLObjectElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'border' property on 'HTMLObjectElement': The provided value",
                globals: globalObject,
                treatNullAsEmptyString: true
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("border", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLObjectElement.prototype, {
        checkValidity: {
            enumerable: true
        },
        reportValidity: {
            enumerable: true
        },
        setCustomValidity: {
            enumerable: true
        },
        data: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        useMap: {
            enumerable: true
        },
        form: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        contentDocument: {
            enumerable: true
        },
        willValidate: {
            enumerable: true
        },
        validity: {
            enumerable: true
        },
        validationMessage: {
            enumerable: true
        },
        align: {
            enumerable: true
        },
        archive: {
            enumerable: true
        },
        code: {
            enumerable: true
        },
        declare: {
            enumerable: true
        },
        hspace: {
            enumerable: true
        },
        standby: {
            enumerable: true
        },
        vspace: {
            enumerable: true
        },
        codeBase: {
            enumerable: true
        },
        codeType: {
            enumerable: true
        },
        border: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLObjectElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLObjectElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLObjectElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLObjectElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLParamElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLParamElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLParamElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLParamElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLParamElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of HTMLParamElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("name");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set name(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set name' called on an object that is not a valid instance of HTMLParamElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'name' property on 'HTMLParamElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("name", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of HTMLParamElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("value");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of HTMLParamElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'value' property on 'HTMLParamElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("value", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of HTMLParamElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("type");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set type(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set type' called on an object that is not a valid instance of HTMLParamElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'type' property on 'HTMLParamElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("type", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get valueType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get valueType' called on an object that is not a valid instance of HTMLParamElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("valuetype");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set valueType(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set valueType' called on an object that is not a valid instance of HTMLParamElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'valueType' property on 'HTMLParamElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("valuetype", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLParamElement.prototype, {
        name: {
            enumerable: true
        },
        value: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        valueType: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLParamElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLParamElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLParamElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLParamElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLVideoElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const parseNonNegativeInteger_helpers_strings = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/strings.js [middleware-edge] (ecmascript)").parseNonNegativeInteger;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLMediaElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMediaElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLVideoElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLVideoElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLVideoElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLMediaElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLVideoElement extends globalObject.HTMLMediaElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("width");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'width' property on 'HTMLVideoElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("width", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                let value = esValue[implSymbol]._reflectGetTheContentAttribute("height");
                if (value !== null) {
                    value = parseNonNegativeInteger_helpers_strings(value);
                    if (value !== null && value >= 0 && value <= 2147483647) {
                        return value;
                    }
                }
                return 0;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'height' property on 'HTMLVideoElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const newValue = V <= 2147483647 && V >= 0 ? V : 0;
                esValue[implSymbol]._reflectSetTheContentAttribute("height", String(newValue));
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get videoWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get videoWidth' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            return esValue[implSymbol]["videoWidth"];
        }
        get videoHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get videoHeight' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            return esValue[implSymbol]["videoHeight"];
        }
        get poster() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get poster' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("poster");
                if (value === null) {
                    return "";
                }
                if (this._posterURLCacheKey === value) {
                    return this._posterURLCache;
                }
                this._posterURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._posterURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._posterURLCache;
                }
                this._posterURLCache = conversions.USVString(value);
                return this._posterURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set poster(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set poster' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'poster' property on 'HTMLVideoElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("poster", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get playsInline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get playsInline' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("playsinline") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set playsInline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set playsInline' called on an object that is not a valid instance of HTMLVideoElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'playsInline' property on 'HTMLVideoElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("playsinline", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("playsinline");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(HTMLVideoElement.prototype, {
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        videoWidth: {
            enumerable: true
        },
        videoHeight: {
            enumerable: true
        },
        poster: {
            enumerable: true
        },
        playsInline: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLVideoElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLVideoElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLVideoElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLVideoElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLAudioElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLMediaElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLMediaElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLAudioElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLAudioElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLAudioElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLMediaElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLAudioElement extends globalObject.HTMLMediaElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
    }
    Object.defineProperties(HTMLAudioElement.prototype, {
        [Symbol.toStringTag]: {
            value: "HTMLAudioElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLAudioElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLAudioElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLAudioElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLTrackElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLConstructor_helpers_html_constructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/html-constructor.js [middleware-edge] (ecmascript)").HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const serializeURLwhatwg_url = __turbopack_context__.r("[project]/node_modules/whatwg-url/index.js [middleware-edge] (ecmascript)").serializeURL;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const interfaceName = "HTMLTrackElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'HTMLTrackElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["HTMLTrackElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    HTMLElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class HTMLTrackElement extends globalObject.HTMLElement {
        constructor(){
            return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
        }
        get kind() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get kind' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("kind");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set kind(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set kind' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'kind' property on 'HTMLTrackElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("kind", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get src() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get src' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("src");
                if (value === null) {
                    return "";
                }
                if (this._srcURLCacheKey === value) {
                    return this._srcURLCache;
                }
                this._srcURLCacheKey = value;
                const urlRecord = esValue[implSymbol]._ownerDocument.encodingParseAURL(value);
                if (urlRecord !== null) {
                    this._srcURLCache = serializeURLwhatwg_url(urlRecord);
                    return this._srcURLCache;
                }
                this._srcURLCache = conversions.USVString(value);
                return this._srcURLCache;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set src(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set src' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            V = conversions["USVString"](V, {
                context: "Failed to set the 'src' property on 'HTMLTrackElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("src", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get srclang() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get srclang' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("srclang");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set srclang(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set srclang' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'srclang' property on 'HTMLTrackElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("srclang", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get label() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get label' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                const value = esValue[implSymbol]._reflectGetTheContentAttribute("label");
                return value === null ? "" : value;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set label(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set label' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'label' property on 'HTMLTrackElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]._reflectSetTheContentAttribute("label", V);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get default() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get default' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]._reflectGetTheContentAttribute("default") !== null;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set default(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set default' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'default' property on 'HTMLTrackElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                if (V) {
                    esValue[implSymbol]._reflectSetTheContentAttribute("default", "");
                } else {
                    esValue[implSymbol]._reflectDeleteTheContentAttribute("default");
                }
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get readyState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readyState' called on an object that is not a valid instance of HTMLTrackElement.");
            }
            return esValue[implSymbol]["readyState"];
        }
    }
    Object.defineProperties(HTMLTrackElement.prototype, {
        kind: {
            enumerable: true
        },
        src: {
            enumerable: true
        },
        srclang: {
            enumerable: true
        },
        label: {
            enumerable: true
        },
        default: {
            enumerable: true
        },
        readyState: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "HTMLTrackElement",
            configurable: true
        },
        NONE: {
            value: 0,
            enumerable: true
        },
        LOADING: {
            value: 1,
            enumerable: true
        },
        LOADED: {
            value: 2,
            enumerable: true
        },
        ERROR: {
            value: 3,
            enumerable: true
        }
    });
    Object.defineProperties(HTMLTrackElement, {
        NONE: {
            value: 0,
            enumerable: true
        },
        LOADING: {
            value: 1,
            enumerable: true
        },
        LOADED: {
            value: 2,
            enumerable: true
        },
        ERROR: {
            value: 3,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = HTMLTrackElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: HTMLTrackElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/HTMLTrackElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedString.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGAnimatedString";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGAnimatedString'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGAnimatedString"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGAnimatedString {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get baseVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get baseVal' called on an object that is not a valid instance of SVGAnimatedString.");
            }
            return esValue[implSymbol]["baseVal"];
        }
        set baseVal(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set baseVal' called on an object that is not a valid instance of SVGAnimatedString.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'baseVal' property on 'SVGAnimatedString': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["baseVal"] = V;
        }
        get animVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get animVal' called on an object that is not a valid instance of SVGAnimatedString.");
            }
            return esValue[implSymbol]["animVal"];
        }
    }
    Object.defineProperties(SVGAnimatedString.prototype, {
        baseVal: {
            enumerable: true
        },
        animVal: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGAnimatedString",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGAnimatedString;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGAnimatedString
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGAnimatedString-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const create_SVGAnimatedString = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedString.js [middleware-edge] (ecmascript)").create;
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const OnErrorEventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/OnErrorEventHandlerNonNull.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Element = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Element.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Element._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGElement extends globalObject.Element {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        focus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'focus' called on an object that is not a valid instance of SVGElement.");
            }
            return esValue[implSymbol].focus();
        }
        blur() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'blur' called on an object that is not a valid instance of SVGElement.");
            }
            return esValue[implSymbol].blur();
        }
        get className() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get className' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.getSameObject(this, "className", ()=>{
                return create_SVGAnimatedString(globalObject, [], {
                    element: esValue[implSymbol],
                    attribute: "class"
                });
            });
        }
        get ownerSVGElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ownerSVGElement' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ownerSVGElement"]);
        }
        get viewportElement() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get viewportElement' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["viewportElement"]);
        }
        get style() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get style' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.getSameObject(this, "style", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["style"]);
            });
        }
        set style(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set style' called on an object that is not a valid instance of SVGElement.");
            }
            const Q = esValue["style"];
            if (!utils.isObject(Q)) {
                throw new globalObject.TypeError("Property 'style' is not an object");
            }
            Reflect.set(Q, "cssText", V);
        }
        get onabort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onabort' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onabort"]);
        }
        set onabort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onabort' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onabort' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onabort"] = V;
        }
        get onauxclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onauxclick' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onauxclick"]);
        }
        set onauxclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onauxclick' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onauxclick' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onauxclick"] = V;
        }
        get onbeforeinput() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeinput' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeinput"]);
        }
        set onbeforeinput(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeinput' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeinput' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeinput"] = V;
        }
        get onbeforematch() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforematch' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforematch"]);
        }
        set onbeforematch(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforematch' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforematch' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforematch"] = V;
        }
        get onbeforetoggle() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforetoggle' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforetoggle"]);
        }
        set onbeforetoggle(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforetoggle' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforetoggle' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforetoggle"] = V;
        }
        get onblur() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onblur' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onblur"]);
        }
        set onblur(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onblur' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onblur' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onblur"] = V;
        }
        get oncancel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncancel' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncancel"]);
        }
        set oncancel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncancel' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncancel' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncancel"] = V;
        }
        get oncanplay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncanplay' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncanplay"]);
        }
        set oncanplay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncanplay' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncanplay' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncanplay"] = V;
        }
        get oncanplaythrough() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncanplaythrough' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncanplaythrough"]);
        }
        set oncanplaythrough(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncanplaythrough' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncanplaythrough' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncanplaythrough"] = V;
        }
        get onchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onchange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onchange"]);
        }
        set onchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onchange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onchange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onchange"] = V;
        }
        get onclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onclick' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onclick"]);
        }
        set onclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onclick' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onclick' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onclick"] = V;
        }
        get onclose() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onclose' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onclose"]);
        }
        set onclose(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onclose' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onclose' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onclose"] = V;
        }
        get oncontextlost() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextlost' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextlost"]);
        }
        set oncontextlost(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextlost' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextlost' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextlost"] = V;
        }
        get oncontextmenu() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextmenu' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextmenu"]);
        }
        set oncontextmenu(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextmenu' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextmenu' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextmenu"] = V;
        }
        get oncontextrestored() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncontextrestored' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncontextrestored"]);
        }
        set oncontextrestored(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncontextrestored' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncontextrestored' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncontextrestored"] = V;
        }
        get oncopy() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncopy' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncopy"]);
        }
        set oncopy(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncopy' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncopy' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncopy"] = V;
        }
        get oncuechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncuechange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncuechange"]);
        }
        set oncuechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncuechange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncuechange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncuechange"] = V;
        }
        get oncut() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oncut' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oncut"]);
        }
        set oncut(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oncut' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oncut' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oncut"] = V;
        }
        get ondblclick() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondblclick' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondblclick"]);
        }
        set ondblclick(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondblclick' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondblclick' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondblclick"] = V;
        }
        get ondrag() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondrag' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondrag"]);
        }
        set ondrag(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondrag' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondrag' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondrag"] = V;
        }
        get ondragend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragend"]);
        }
        set ondragend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragend"] = V;
        }
        get ondragenter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragenter' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragenter"]);
        }
        set ondragenter(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragenter' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragenter' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragenter"] = V;
        }
        get ondragleave() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragleave' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragleave"]);
        }
        set ondragleave(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragleave' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragleave' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragleave"] = V;
        }
        get ondragover() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragover' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragover"]);
        }
        set ondragover(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragover' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragover' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragover"] = V;
        }
        get ondragstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondragstart' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondragstart"]);
        }
        set ondragstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondragstart' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondragstart' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondragstart"] = V;
        }
        get ondrop() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondrop' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondrop"]);
        }
        set ondrop(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondrop' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondrop' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondrop"] = V;
        }
        get ondurationchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ondurationchange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ondurationchange"]);
        }
        set ondurationchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ondurationchange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ondurationchange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ondurationchange"] = V;
        }
        get onemptied() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onemptied' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onemptied"]);
        }
        set onemptied(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onemptied' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onemptied' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onemptied"] = V;
        }
        get onended() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onended' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onended"]);
        }
        set onended(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onended' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onended' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onended"] = V;
        }
        get onerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onerror' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onerror"]);
        }
        set onerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onerror' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = OnErrorEventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onerror' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onerror"] = V;
        }
        get onfocus() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onfocus' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onfocus"]);
        }
        set onfocus(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onfocus' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onfocus' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onfocus"] = V;
        }
        get onformdata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onformdata' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onformdata"]);
        }
        set onformdata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onformdata' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onformdata' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onformdata"] = V;
        }
        get oninput() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oninput' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oninput"]);
        }
        set oninput(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oninput' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oninput' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oninput"] = V;
        }
        get oninvalid() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oninvalid' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["oninvalid"]);
        }
        set oninvalid(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set oninvalid' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'oninvalid' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["oninvalid"] = V;
        }
        get onkeydown() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeydown' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeydown"]);
        }
        set onkeydown(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeydown' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeydown' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeydown"] = V;
        }
        get onkeypress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeypress' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeypress"]);
        }
        set onkeypress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeypress' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeypress' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeypress"] = V;
        }
        get onkeyup() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onkeyup' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onkeyup"]);
        }
        set onkeyup(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onkeyup' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onkeyup' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onkeyup"] = V;
        }
        get onload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onload' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onload"]);
        }
        set onload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onload' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onload' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onload"] = V;
        }
        get onloadeddata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadeddata' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadeddata"]);
        }
        set onloadeddata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadeddata' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadeddata' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadeddata"] = V;
        }
        get onloadedmetadata() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadedmetadata' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadedmetadata"]);
        }
        set onloadedmetadata(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadedmetadata' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadedmetadata' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadedmetadata"] = V;
        }
        get onloadstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadstart' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadstart"]);
        }
        set onloadstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadstart' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadstart' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onloadstart"] = V;
        }
        get onmousedown() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmousedown' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmousedown"]);
        }
        set onmousedown(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmousedown' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmousedown' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmousedown"] = V;
        }
        get onmouseenter() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseenter"]);
        }
        set onmouseenter(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseenter' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseenter"] = V;
        }
        get onmouseleave() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseleave"]);
        }
        set onmouseleave(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                return;
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseleave' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseleave"] = V;
        }
        get onmousemove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmousemove' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmousemove"]);
        }
        set onmousemove(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmousemove' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmousemove' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmousemove"] = V;
        }
        get onmouseout() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseout' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseout"]);
        }
        set onmouseout(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseout' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseout' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseout"] = V;
        }
        get onmouseover() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseover' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseover"]);
        }
        set onmouseover(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseover' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseover' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseover"] = V;
        }
        get onmouseup() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmouseup' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseup"]);
        }
        set onmouseup(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmouseup' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmouseup' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmouseup"] = V;
        }
        get onpaste() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpaste' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpaste"]);
        }
        set onpaste(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpaste' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpaste' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onpaste"] = V;
        }
        get onpause() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpause' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpause"]);
        }
        set onpause(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpause' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpause' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onpause"] = V;
        }
        get onplay() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onplay' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onplay"]);
        }
        set onplay(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onplay' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onplay' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onplay"] = V;
        }
        get onplaying() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onplaying' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onplaying"]);
        }
        set onplaying(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onplaying' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onplaying' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onplaying"] = V;
        }
        get onprogress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onprogress' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onprogress"]);
        }
        set onprogress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onprogress' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onprogress' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onprogress"] = V;
        }
        get onratechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onratechange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onratechange"]);
        }
        set onratechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onratechange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onratechange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onratechange"] = V;
        }
        get onreset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onreset' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onreset"]);
        }
        set onreset(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onreset' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onreset' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onreset"] = V;
        }
        get onresize() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onresize' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onresize"]);
        }
        set onresize(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onresize' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onresize' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onresize"] = V;
        }
        get onscroll() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onscroll' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onscroll"]);
        }
        set onscroll(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onscroll' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onscroll' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onscroll"] = V;
        }
        get onscrollend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onscrollend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onscrollend"]);
        }
        set onscrollend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onscrollend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onscrollend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onscrollend"] = V;
        }
        get onsecuritypolicyviolation() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsecuritypolicyviolation' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsecuritypolicyviolation"]);
        }
        set onsecuritypolicyviolation(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsecuritypolicyviolation' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsecuritypolicyviolation' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onsecuritypolicyviolation"] = V;
        }
        get onseeked() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onseeked' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onseeked"]);
        }
        set onseeked(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onseeked' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onseeked' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onseeked"] = V;
        }
        get onseeking() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onseeking' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onseeking"]);
        }
        set onseeking(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onseeking' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onseeking' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onseeking"] = V;
        }
        get onselect() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onselect' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onselect"]);
        }
        set onselect(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onselect' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onselect' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onselect"] = V;
        }
        get onslotchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onslotchange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onslotchange"]);
        }
        set onslotchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onslotchange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onslotchange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onslotchange"] = V;
        }
        get onstalled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onstalled' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onstalled"]);
        }
        set onstalled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onstalled' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onstalled' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onstalled"] = V;
        }
        get onsubmit() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsubmit' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsubmit"]);
        }
        set onsubmit(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsubmit' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsubmit' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onsubmit"] = V;
        }
        get onsuspend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onsuspend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onsuspend"]);
        }
        set onsuspend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onsuspend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onsuspend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onsuspend"] = V;
        }
        get ontimeupdate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontimeupdate' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontimeupdate"]);
        }
        set ontimeupdate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontimeupdate' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontimeupdate' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontimeupdate"] = V;
        }
        get ontoggle() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontoggle' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontoggle"]);
        }
        set ontoggle(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontoggle' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontoggle' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontoggle"] = V;
        }
        get onvolumechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onvolumechange' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onvolumechange"]);
        }
        set onvolumechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onvolumechange' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onvolumechange' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onvolumechange"] = V;
        }
        get onwaiting() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwaiting' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwaiting"]);
        }
        set onwaiting(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwaiting' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwaiting' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwaiting"] = V;
        }
        get onwebkitanimationend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationend"]);
        }
        set onwebkitanimationend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationend"] = V;
        }
        get onwebkitanimationiteration() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationiteration' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationiteration"]);
        }
        set onwebkitanimationiteration(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationiteration' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationiteration' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationiteration"] = V;
        }
        get onwebkitanimationstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkitanimationstart' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkitanimationstart"]);
        }
        set onwebkitanimationstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkitanimationstart' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkitanimationstart' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkitanimationstart"] = V;
        }
        get onwebkittransitionend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwebkittransitionend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwebkittransitionend"]);
        }
        set onwebkittransitionend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwebkittransitionend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwebkittransitionend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwebkittransitionend"] = V;
        }
        get onwheel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onwheel' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onwheel"]);
        }
        set onwheel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onwheel' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onwheel' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onwheel"] = V;
        }
        get ontouchstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchstart' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchstart"]);
        }
        set ontouchstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchstart' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchstart' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchstart"] = V;
        }
        get ontouchend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchend' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchend"]);
        }
        set ontouchend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchend' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchend' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchend"] = V;
        }
        get ontouchmove() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchmove' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchmove"]);
        }
        set ontouchmove(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchmove' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchmove' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchmove"] = V;
        }
        get ontouchcancel() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontouchcancel' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontouchcancel"]);
        }
        set ontouchcancel(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontouchcancel' called on an object that is not a valid instance of SVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontouchcancel' property on 'SVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ontouchcancel"] = V;
        }
        get dataset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get dataset' called on an object that is not a valid instance of SVGElement.");
            }
            return utils.getSameObject(this, "dataset", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["dataset"]);
            });
        }
        get nonce() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get nonce' called on an object that is not a valid instance of SVGElement.");
            }
            const value = esValue[implSymbol]._reflectGetTheContentAttribute("nonce");
            return value === null ? "" : value;
        }
        set nonce(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set nonce' called on an object that is not a valid instance of SVGElement.");
            }
            V = conversions["DOMString"](V, {
                context: "Failed to set the 'nonce' property on 'SVGElement': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]._reflectSetTheContentAttribute("nonce", V);
        }
        get tabIndex() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get tabIndex' called on an object that is not a valid instance of SVGElement.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol]["tabIndex"];
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        set tabIndex(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set tabIndex' called on an object that is not a valid instance of SVGElement.");
            }
            V = conversions["long"](V, {
                context: "Failed to set the 'tabIndex' property on 'SVGElement': The provided value",
                globals: globalObject
            });
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                esValue[implSymbol]["tabIndex"] = V;
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(SVGElement.prototype, {
        focus: {
            enumerable: true
        },
        blur: {
            enumerable: true
        },
        className: {
            enumerable: true
        },
        ownerSVGElement: {
            enumerable: true
        },
        viewportElement: {
            enumerable: true
        },
        style: {
            enumerable: true
        },
        onabort: {
            enumerable: true
        },
        onauxclick: {
            enumerable: true
        },
        onbeforeinput: {
            enumerable: true
        },
        onbeforematch: {
            enumerable: true
        },
        onbeforetoggle: {
            enumerable: true
        },
        onblur: {
            enumerable: true
        },
        oncancel: {
            enumerable: true
        },
        oncanplay: {
            enumerable: true
        },
        oncanplaythrough: {
            enumerable: true
        },
        onchange: {
            enumerable: true
        },
        onclick: {
            enumerable: true
        },
        onclose: {
            enumerable: true
        },
        oncontextlost: {
            enumerable: true
        },
        oncontextmenu: {
            enumerable: true
        },
        oncontextrestored: {
            enumerable: true
        },
        oncopy: {
            enumerable: true
        },
        oncuechange: {
            enumerable: true
        },
        oncut: {
            enumerable: true
        },
        ondblclick: {
            enumerable: true
        },
        ondrag: {
            enumerable: true
        },
        ondragend: {
            enumerable: true
        },
        ondragenter: {
            enumerable: true
        },
        ondragleave: {
            enumerable: true
        },
        ondragover: {
            enumerable: true
        },
        ondragstart: {
            enumerable: true
        },
        ondrop: {
            enumerable: true
        },
        ondurationchange: {
            enumerable: true
        },
        onemptied: {
            enumerable: true
        },
        onended: {
            enumerable: true
        },
        onerror: {
            enumerable: true
        },
        onfocus: {
            enumerable: true
        },
        onformdata: {
            enumerable: true
        },
        oninput: {
            enumerable: true
        },
        oninvalid: {
            enumerable: true
        },
        onkeydown: {
            enumerable: true
        },
        onkeypress: {
            enumerable: true
        },
        onkeyup: {
            enumerable: true
        },
        onload: {
            enumerable: true
        },
        onloadeddata: {
            enumerable: true
        },
        onloadedmetadata: {
            enumerable: true
        },
        onloadstart: {
            enumerable: true
        },
        onmousedown: {
            enumerable: true
        },
        onmouseenter: {
            enumerable: true
        },
        onmouseleave: {
            enumerable: true
        },
        onmousemove: {
            enumerable: true
        },
        onmouseout: {
            enumerable: true
        },
        onmouseover: {
            enumerable: true
        },
        onmouseup: {
            enumerable: true
        },
        onpaste: {
            enumerable: true
        },
        onpause: {
            enumerable: true
        },
        onplay: {
            enumerable: true
        },
        onplaying: {
            enumerable: true
        },
        onprogress: {
            enumerable: true
        },
        onratechange: {
            enumerable: true
        },
        onreset: {
            enumerable: true
        },
        onresize: {
            enumerable: true
        },
        onscroll: {
            enumerable: true
        },
        onscrollend: {
            enumerable: true
        },
        onsecuritypolicyviolation: {
            enumerable: true
        },
        onseeked: {
            enumerable: true
        },
        onseeking: {
            enumerable: true
        },
        onselect: {
            enumerable: true
        },
        onslotchange: {
            enumerable: true
        },
        onstalled: {
            enumerable: true
        },
        onsubmit: {
            enumerable: true
        },
        onsuspend: {
            enumerable: true
        },
        ontimeupdate: {
            enumerable: true
        },
        ontoggle: {
            enumerable: true
        },
        onvolumechange: {
            enumerable: true
        },
        onwaiting: {
            enumerable: true
        },
        onwebkitanimationend: {
            enumerable: true
        },
        onwebkitanimationiteration: {
            enumerable: true
        },
        onwebkitanimationstart: {
            enumerable: true
        },
        onwebkittransitionend: {
            enumerable: true
        },
        onwheel: {
            enumerable: true
        },
        ontouchstart: {
            enumerable: true
        },
        ontouchend: {
            enumerable: true
        },
        ontouchmove: {
            enumerable: true
        },
        ontouchcancel: {
            enumerable: true
        },
        dataset: {
            enumerable: true
        },
        nonce: {
            enumerable: true
        },
        tabIndex: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGStringList.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGStringList";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGStringList'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGStringList"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGStringList {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        clear() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'clear' called on an object that is not a valid instance of SVGStringList.");
            }
            return esValue[implSymbol].clear();
        }
        initialize(newItem) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initialize' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initialize' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initialize' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].initialize(...args);
        }
        getItem(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getItem' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getItem' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'getItem' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].getItem(...args);
        }
        insertItemBefore(newItem, index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'insertItemBefore' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'insertItemBefore' on 'SVGStringList': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'insertItemBefore' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'insertItemBefore' on 'SVGStringList': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].insertItemBefore(...args);
        }
        replaceItem(newItem, index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'replaceItem' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'replaceItem' on 'SVGStringList': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'replaceItem' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'replaceItem' on 'SVGStringList': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].replaceItem(...args);
        }
        removeItem(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeItem' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'removeItem' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'removeItem' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].removeItem(...args);
        }
        appendItem(newItem) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'appendItem' called on an object that is not a valid instance of SVGStringList.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'appendItem' on 'SVGStringList': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'appendItem' on 'SVGStringList': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].appendItem(...args);
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of SVGStringList.");
            }
            return esValue[implSymbol]["length"];
        }
        get numberOfItems() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get numberOfItems' called on an object that is not a valid instance of SVGStringList.");
            }
            return esValue[implSymbol]["numberOfItems"];
        }
    }
    Object.defineProperties(SVGStringList.prototype, {
        clear: {
            enumerable: true
        },
        initialize: {
            enumerable: true
        },
        getItem: {
            enumerable: true
        },
        insertItemBefore: {
            enumerable: true
        },
        replaceItem: {
            enumerable: true
        },
        removeItem: {
            enumerable: true
        },
        appendItem: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        numberOfItems: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGStringList",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = SVGStringList;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGStringList
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            if (target[implSymbol][utils.supportsPropertyIndex](index)) {
                const indexedValue = target[implSymbol].getItem(index);
                return {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
            if (utils.isArrayIndexPropName(P)) {
                const index = P >>> 0;
                let indexedValue = V;
                indexedValue = conversions["DOMString"](indexedValue, {
                    context: "Failed to set the " + index + " property on 'SVGStringList': The provided value",
                    globals: globalObject
                });
                const creating = !target[implSymbol][utils.supportsPropertyIndex](index);
                if (creating) {
                    target[implSymbol][utils.indexedSetNew](index, indexedValue);
                } else {
                    target[implSymbol][utils.indexedSetExisting](index, indexedValue);
                }
                return true;
            }
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            if (target[implSymbol][utils.supportsPropertyIndex](index)) {
                const indexedValue = target[implSymbol].getItem(index);
                ownDesc = {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            if (desc.get || desc.set) {
                return false;
            }
            const index = P >>> 0;
            let indexedValue = desc.value;
            indexedValue = conversions["DOMString"](indexedValue, {
                context: "Failed to set the " + index + " property on 'SVGStringList': The provided value",
                globals: globalObject
            });
            const creating = !target[implSymbol][utils.supportsPropertyIndex](index);
            if (creating) {
                target[implSymbol][utils.indexedSetNew](index, indexedValue);
            } else {
                target[implSymbol][utils.indexedSetExisting](index, indexedValue);
            }
            return true;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !target[implSymbol][utils.supportsPropertyIndex](index);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGStringList-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGGraphicsElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGGraphicsElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGGraphicsElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGGraphicsElement extends globalObject.SVGElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get requiredExtensions() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get requiredExtensions' called on an object that is not a valid instance of SVGGraphicsElement.");
            }
            return utils.getSameObject(this, "requiredExtensions", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["requiredExtensions"]);
            });
        }
        get systemLanguage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get systemLanguage' called on an object that is not a valid instance of SVGGraphicsElement.");
            }
            return utils.getSameObject(this, "systemLanguage", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["systemLanguage"]);
            });
        }
    }
    Object.defineProperties(SVGGraphicsElement.prototype, {
        requiredExtensions: {
            enumerable: true
        },
        systemLanguage: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGGraphicsElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGGraphicsElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGGraphicsElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGGraphicsElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGNumber.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGNumber";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGNumber'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGNumber"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGNumber {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get value() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get value' called on an object that is not a valid instance of SVGNumber.");
            }
            return esValue[implSymbol]["value"];
        }
        set value(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set value' called on an object that is not a valid instance of SVGNumber.");
            }
            V = conversions["float"](V, {
                context: "Failed to set the 'value' property on 'SVGNumber': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["value"] = V;
        }
    }
    Object.defineProperties(SVGNumber.prototype, {
        value: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGNumber",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGNumber;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGNumber
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGNumber-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGRect.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGRect";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGRect'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGRect"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGRect {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get x() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get x' called on an object that is not a valid instance of SVGRect.");
            }
            return esValue[implSymbol]["x"];
        }
        set x(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set x' called on an object that is not a valid instance of SVGRect.");
            }
            V = conversions["float"](V, {
                context: "Failed to set the 'x' property on 'SVGRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["x"] = V;
        }
        get y() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get y' called on an object that is not a valid instance of SVGRect.");
            }
            return esValue[implSymbol]["y"];
        }
        set y(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set y' called on an object that is not a valid instance of SVGRect.");
            }
            V = conversions["float"](V, {
                context: "Failed to set the 'y' property on 'SVGRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["y"] = V;
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of SVGRect.");
            }
            return esValue[implSymbol]["width"];
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of SVGRect.");
            }
            V = conversions["float"](V, {
                context: "Failed to set the 'width' property on 'SVGRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["width"] = V;
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of SVGRect.");
            }
            return esValue[implSymbol]["height"];
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of SVGRect.");
            }
            V = conversions["float"](V, {
                context: "Failed to set the 'height' property on 'SVGRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["height"] = V;
        }
    }
    Object.defineProperties(SVGRect.prototype, {
        x: {
            enumerable: true
        },
        y: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGRect",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGRect;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGRect
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGRect-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedRect.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGAnimatedRect";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGAnimatedRect'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGAnimatedRect"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGAnimatedRect {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get baseVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get baseVal' called on an object that is not a valid instance of SVGAnimatedRect.");
            }
            return utils.getSameObject(this, "baseVal", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["baseVal"]);
            });
        }
        get animVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get animVal' called on an object that is not a valid instance of SVGAnimatedRect.");
            }
            return utils.getSameObject(this, "animVal", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["animVal"]);
            });
        }
    }
    Object.defineProperties(SVGAnimatedRect.prototype, {
        baseVal: {
            enumerable: true
        },
        animVal: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGAnimatedRect",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGAnimatedRect;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGAnimatedRect
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGAnimatedRect-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGPreserveAspectRatio.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGPreserveAspectRatio";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGPreserveAspectRatio'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGPreserveAspectRatio"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGPreserveAspectRatio {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get align() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get align' called on an object that is not a valid instance of SVGPreserveAspectRatio.");
            }
            return esValue[implSymbol]["align"];
        }
        set align(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set align' called on an object that is not a valid instance of SVGPreserveAspectRatio.");
            }
            V = conversions["unsigned short"](V, {
                context: "Failed to set the 'align' property on 'SVGPreserveAspectRatio': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["align"] = V;
        }
        get meetOrSlice() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get meetOrSlice' called on an object that is not a valid instance of SVGPreserveAspectRatio.");
            }
            return esValue[implSymbol]["meetOrSlice"];
        }
        set meetOrSlice(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set meetOrSlice' called on an object that is not a valid instance of SVGPreserveAspectRatio.");
            }
            V = conversions["unsigned short"](V, {
                context: "Failed to set the 'meetOrSlice' property on 'SVGPreserveAspectRatio': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["meetOrSlice"] = V;
        }
    }
    Object.defineProperties(SVGPreserveAspectRatio.prototype, {
        align: {
            enumerable: true
        },
        meetOrSlice: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGPreserveAspectRatio",
            configurable: true
        },
        SVG_PRESERVEASPECTRATIO_UNKNOWN: {
            value: 0,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_NONE: {
            value: 1,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMIN: {
            value: 2,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMIN: {
            value: 3,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMIN: {
            value: 4,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMID: {
            value: 5,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMID: {
            value: 6,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMID: {
            value: 7,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMAX: {
            value: 8,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMAX: {
            value: 9,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMAX: {
            value: 10,
            enumerable: true
        },
        SVG_MEETORSLICE_UNKNOWN: {
            value: 0,
            enumerable: true
        },
        SVG_MEETORSLICE_MEET: {
            value: 1,
            enumerable: true
        },
        SVG_MEETORSLICE_SLICE: {
            value: 2,
            enumerable: true
        }
    });
    Object.defineProperties(SVGPreserveAspectRatio, {
        SVG_PRESERVEASPECTRATIO_UNKNOWN: {
            value: 0,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_NONE: {
            value: 1,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMIN: {
            value: 2,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMIN: {
            value: 3,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMIN: {
            value: 4,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMID: {
            value: 5,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMID: {
            value: 6,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMID: {
            value: 7,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMINYMAX: {
            value: 8,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMIDYMAX: {
            value: 9,
            enumerable: true
        },
        SVG_PRESERVEASPECTRATIO_XMAXYMAX: {
            value: 10,
            enumerable: true
        },
        SVG_MEETORSLICE_UNKNOWN: {
            value: 0,
            enumerable: true
        },
        SVG_MEETORSLICE_MEET: {
            value: 1,
            enumerable: true
        },
        SVG_MEETORSLICE_SLICE: {
            value: 2,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = SVGPreserveAspectRatio;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGPreserveAspectRatio
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGPreserveAspectRatio-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedPreserveAspectRatio.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "SVGAnimatedPreserveAspectRatio";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGAnimatedPreserveAspectRatio'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGAnimatedPreserveAspectRatio"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGAnimatedPreserveAspectRatio {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get baseVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get baseVal' called on an object that is not a valid instance of SVGAnimatedPreserveAspectRatio.");
            }
            return utils.getSameObject(this, "baseVal", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["baseVal"]);
            });
        }
        get animVal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get animVal' called on an object that is not a valid instance of SVGAnimatedPreserveAspectRatio.");
            }
            return utils.getSameObject(this, "animVal", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["animVal"]);
            });
        }
    }
    Object.defineProperties(SVGAnimatedPreserveAspectRatio.prototype, {
        baseVal: {
            enumerable: true
        },
        animVal: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGAnimatedPreserveAspectRatio",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGAnimatedPreserveAspectRatio;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGAnimatedPreserveAspectRatio
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/svg/SVGAnimatedPreserveAspectRatio-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGSVGElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const create_SVGAnimatedRect = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedRect.js [middleware-edge] (ecmascript)").create;
const create_SVGAnimatedPreserveAspectRatio = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedPreserveAspectRatio.js [middleware-edge] (ecmascript)").create;
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const OnBeforeUnloadEventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/OnBeforeUnloadEventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGGraphicsElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGSVGElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGSVGElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGSVGElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGGraphicsElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGSVGElement extends globalObject.SVGGraphicsElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        createSVGNumber() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createSVGNumber' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createSVGNumber());
        }
        createSVGRect() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'createSVGRect' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].createSVGRect());
        }
        getElementById(elementId) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getElementById' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getElementById' on 'SVGSVGElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getElementById' on 'SVGSVGElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getElementById(...args));
        }
        suspendRedraw(maxWaitMilliseconds) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'suspendRedraw' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'suspendRedraw' on 'SVGSVGElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'suspendRedraw' on 'SVGSVGElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].suspendRedraw(...args);
        }
        unsuspendRedraw(suspendHandleID) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'unsuspendRedraw' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'unsuspendRedraw' on 'SVGSVGElement': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'unsuspendRedraw' on 'SVGSVGElement': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].unsuspendRedraw(...args);
        }
        unsuspendRedrawAll() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'unsuspendRedrawAll' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return esValue[implSymbol].unsuspendRedrawAll();
        }
        forceRedraw() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'forceRedraw' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return esValue[implSymbol].forceRedraw();
        }
        get viewBox() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get viewBox' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.getSameObject(this, "viewBox", ()=>{
                return create_SVGAnimatedRect(globalObject, [], {
                    element: esValue[implSymbol],
                    attribute: "viewBox"
                });
            });
        }
        get preserveAspectRatio() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get preserveAspectRatio' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.getSameObject(this, "preserveAspectRatio", ()=>{
                return create_SVGAnimatedPreserveAspectRatio(globalObject, [], {
                    element: esValue[implSymbol]
                });
            });
        }
        get onafterprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onafterprint' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onafterprint"]);
        }
        set onafterprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onafterprint' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onafterprint' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onafterprint"] = V;
        }
        get onbeforeprint() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeprint' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeprint"]);
        }
        set onbeforeprint(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeprint' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeprint' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeprint"] = V;
        }
        get onbeforeunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onbeforeunload' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onbeforeunload"]);
        }
        set onbeforeunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onbeforeunload' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = OnBeforeUnloadEventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onbeforeunload' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onbeforeunload"] = V;
        }
        get onhashchange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onhashchange' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onhashchange"]);
        }
        set onhashchange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onhashchange' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onhashchange' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onhashchange"] = V;
        }
        get onlanguagechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onlanguagechange' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onlanguagechange"]);
        }
        set onlanguagechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onlanguagechange' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onlanguagechange' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onlanguagechange"] = V;
        }
        get onmessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessage' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessage"]);
        }
        set onmessage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessage' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessage' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessage"] = V;
        }
        get onmessageerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessageerror' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessageerror"]);
        }
        set onmessageerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessageerror' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessageerror' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onmessageerror"] = V;
        }
        get onoffline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onoffline' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onoffline"]);
        }
        set onoffline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onoffline' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onoffline' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onoffline"] = V;
        }
        get ononline() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ononline' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ononline"]);
        }
        set ononline(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ononline' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ononline' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["ononline"] = V;
        }
        get onpagehide() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpagehide' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpagehide"]);
        }
        set onpagehide(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpagehide' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpagehide' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onpagehide"] = V;
        }
        get onpageshow() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpageshow' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpageshow"]);
        }
        set onpageshow(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpageshow' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpageshow' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onpageshow"] = V;
        }
        get onpopstate() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onpopstate' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onpopstate"]);
        }
        set onpopstate(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onpopstate' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onpopstate' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onpopstate"] = V;
        }
        get onrejectionhandled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onrejectionhandled' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onrejectionhandled"]);
        }
        set onrejectionhandled(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onrejectionhandled' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onrejectionhandled' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onrejectionhandled"] = V;
        }
        get onstorage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onstorage' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onstorage"]);
        }
        set onstorage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onstorage' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onstorage' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onstorage"] = V;
        }
        get onunhandledrejection() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunhandledrejection' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunhandledrejection"]);
        }
        set onunhandledrejection(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunhandledrejection' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunhandledrejection' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onunhandledrejection"] = V;
        }
        get onunload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onunload' called on an object that is not a valid instance of SVGSVGElement.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onunload"]);
        }
        set onunload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onunload' called on an object that is not a valid instance of SVGSVGElement.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onunload' property on 'SVGSVGElement': The provided value"
                });
            }
            esValue[implSymbol]["onunload"] = V;
        }
    }
    Object.defineProperties(SVGSVGElement.prototype, {
        createSVGNumber: {
            enumerable: true
        },
        createSVGRect: {
            enumerable: true
        },
        getElementById: {
            enumerable: true
        },
        suspendRedraw: {
            enumerable: true
        },
        unsuspendRedraw: {
            enumerable: true
        },
        unsuspendRedrawAll: {
            enumerable: true
        },
        forceRedraw: {
            enumerable: true
        },
        viewBox: {
            enumerable: true
        },
        preserveAspectRatio: {
            enumerable: true
        },
        onafterprint: {
            enumerable: true
        },
        onbeforeprint: {
            enumerable: true
        },
        onbeforeunload: {
            enumerable: true
        },
        onhashchange: {
            enumerable: true
        },
        onlanguagechange: {
            enumerable: true
        },
        onmessage: {
            enumerable: true
        },
        onmessageerror: {
            enumerable: true
        },
        onoffline: {
            enumerable: true
        },
        ononline: {
            enumerable: true
        },
        onpagehide: {
            enumerable: true
        },
        onpageshow: {
            enumerable: true
        },
        onpopstate: {
            enumerable: true
        },
        onrejectionhandled: {
            enumerable: true
        },
        onstorage: {
            enumerable: true
        },
        onunhandledrejection: {
            enumerable: true
        },
        onunload: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGSVGElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGSVGElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGSVGElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGSVGElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGGraphicsElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGGElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGGElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGGElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGGraphicsElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGGElement extends globalObject.SVGGraphicsElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGGElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGGElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGGElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGGElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGGElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGDefsElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGGraphicsElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGDefsElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGDefsElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGDefsElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGGraphicsElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGDefsElement extends globalObject.SVGGraphicsElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGDefsElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGDefsElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGDefsElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGDefsElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGDefsElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGDescElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGDescElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGDescElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGDescElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGDescElement extends globalObject.SVGElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGDescElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGDescElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGDescElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGDescElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGDescElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGMetadataElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGMetadataElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGMetadataElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGMetadataElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGMetadataElement extends globalObject.SVGElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGMetadataElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGMetadataElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGMetadataElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGMetadataElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGMetadataElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGTitleElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGTitleElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGTitleElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGTitleElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGTitleElement extends globalObject.SVGElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGTitleElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGTitleElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGTitleElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGTitleElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGTitleElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGSymbolElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const create_SVGAnimatedRect = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedRect.js [middleware-edge] (ecmascript)").create;
const create_SVGAnimatedPreserveAspectRatio = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGAnimatedPreserveAspectRatio.js [middleware-edge] (ecmascript)").create;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGGraphicsElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGSymbolElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGSymbolElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGSymbolElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGGraphicsElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGSymbolElement extends globalObject.SVGGraphicsElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get viewBox() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get viewBox' called on an object that is not a valid instance of SVGSymbolElement.");
            }
            return utils.getSameObject(this, "viewBox", ()=>{
                return create_SVGAnimatedRect(globalObject, [], {
                    element: esValue[implSymbol],
                    attribute: "viewBox"
                });
            });
        }
        get preserveAspectRatio() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get preserveAspectRatio' called on an object that is not a valid instance of SVGSymbolElement.");
            }
            return utils.getSameObject(this, "preserveAspectRatio", ()=>{
                return create_SVGAnimatedPreserveAspectRatio(globalObject, [], {
                    element: esValue[implSymbol]
                });
            });
        }
    }
    Object.defineProperties(SVGSymbolElement.prototype, {
        viewBox: {
            enumerable: true
        },
        preserveAspectRatio: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "SVGSymbolElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGSymbolElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGSymbolElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGSymbolElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGSwitchElement.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const SVGGraphicsElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SVGGraphicsElement.js [middleware-edge] (ecmascript)");
const interfaceName = "SVGSwitchElement";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'SVGSwitchElement'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["SVGSwitchElement"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    SVGGraphicsElement._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class SVGSwitchElement extends globalObject.SVGGraphicsElement {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(SVGSwitchElement.prototype, {
        [Symbol.toStringTag]: {
            value: "SVGSwitchElement",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = SVGSwitchElement;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: SVGSwitchElement
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/nodes/SVGSwitchElement-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CloseEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "code";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned short"](value, {
                context: context + " has member 'code' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "reason";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'reason' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "wasClean";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'wasClean' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CloseEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const CloseEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CloseEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "CloseEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CloseEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CloseEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CloseEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'CloseEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'CloseEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = CloseEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'CloseEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get wasClean() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get wasClean' called on an object that is not a valid instance of CloseEvent.");
            }
            return esValue[implSymbol]["wasClean"];
        }
        get code() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get code' called on an object that is not a valid instance of CloseEvent.");
            }
            return esValue[implSymbol]["code"];
        }
        get reason() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get reason' called on an object that is not a valid instance of CloseEvent.");
            }
            return esValue[implSymbol]["reason"];
        }
    }
    Object.defineProperties(CloseEvent.prototype, {
        wasClean: {
            enumerable: true
        },
        code: {
            enumerable: true
        },
        reason: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "CloseEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CloseEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CloseEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/CloseEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Storage.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Storage";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Storage'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Storage"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Storage {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        key(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'key' called on an object that is not a valid instance of Storage.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'key' on 'Storage': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'key' on 'Storage': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].key(...args);
        }
        getItem(key) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getItem' called on an object that is not a valid instance of Storage.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getItem' on 'Storage': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'getItem' on 'Storage': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].getItem(...args);
        }
        setItem(key, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setItem' called on an object that is not a valid instance of Storage.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setItem' on 'Storage': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setItem' on 'Storage': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'setItem' on 'Storage': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setItem(...args);
        }
        removeItem(key) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeItem' called on an object that is not a valid instance of Storage.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'removeItem' on 'Storage': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'removeItem' on 'Storage': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].removeItem(...args);
        }
        clear() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'clear' called on an object that is not a valid instance of Storage.");
            }
            return esValue[implSymbol].clear();
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of Storage.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(Storage.prototype, {
        key: {
            enumerable: true
        },
        getItem: {
            enumerable: true
        },
        setItem: {
            enumerable: true
        },
        removeItem: {
            enumerable: true
        },
        clear: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Storage",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Storage;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Storage
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyNames]){
            if (!(key in target)) {
                keys.add(`${key}`);
            }
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        const namedValue = target[implSymbol].getItem(P);
        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
            return {
                writable: true,
                enumerable: true,
                configurable: true,
                value: utils.tryWrapperForImpl(namedValue)
            };
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
            if (typeof P === "string") {
                let namedValue = V;
                namedValue = conversions["DOMString"](namedValue, {
                    context: "Failed to set the '" + P + "' property on 'Storage': The provided value",
                    globals: globalObject
                });
                target[implSymbol].setItem(P, namedValue);
                return true;
            }
        }
        let ownDesc;
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (!utils.hasOwn(target, P)) {
            if (desc.get || desc.set) {
                return false;
            }
            let namedValue = desc.value;
            namedValue = conversions["DOMString"](namedValue, {
                context: "Failed to set the '" + P + "' property on 'Storage': The provided value",
                globals: globalObject
            });
            target[implSymbol].setItem(P, namedValue);
            return true;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (target[implSymbol].getItem(P) !== null && !(P in target)) {
            target[implSymbol].removeItem(P);
            return true;
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/webstorage/Storage-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/StorageEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Storage = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Storage.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "key";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = conversions["DOMString"](value, {
                    context: context + " has member 'key' that",
                    globals: globalObject
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "newValue";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = conversions["DOMString"](value, {
                    context: context + " has member 'newValue' that",
                    globals: globalObject
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "oldValue";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = conversions["DOMString"](value, {
                    context: context + " has member 'oldValue' that",
                    globals: globalObject
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "storageArea";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = Storage.convert(globalObject, value, {
                    context: context + " has member 'storageArea' that"
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "url";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["USVString"](value, {
                context: context + " has member 'url' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/StorageEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const StorageEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/StorageEventInit.js [middleware-edge] (ecmascript)");
const Storage = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Storage.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "StorageEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'StorageEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["StorageEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class StorageEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'StorageEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'StorageEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = StorageEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'StorageEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        initStorageEvent(type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initStorageEvent' called on an object that is not a valid instance of StorageEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initStorageEvent' on 'StorageEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 4",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 5",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[5];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 6",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[6];
                if (curArg !== undefined) {
                    curArg = conversions["USVString"](curArg, {
                        context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 7",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[7];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = Storage.convert(globalObject, curArg, {
                            context: "Failed to execute 'initStorageEvent' on 'StorageEvent': parameter 8"
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initStorageEvent(...args);
        }
        get key() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get key' called on an object that is not a valid instance of StorageEvent.");
            }
            return esValue[implSymbol]["key"];
        }
        get oldValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get oldValue' called on an object that is not a valid instance of StorageEvent.");
            }
            return esValue[implSymbol]["oldValue"];
        }
        get newValue() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get newValue' called on an object that is not a valid instance of StorageEvent.");
            }
            return esValue[implSymbol]["newValue"];
        }
        get url() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get url' called on an object that is not a valid instance of StorageEvent.");
            }
            return esValue[implSymbol]["url"];
        }
        get storageArea() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get storageArea' called on an object that is not a valid instance of StorageEvent.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["storageArea"]);
        }
    }
    Object.defineProperties(StorageEvent.prototype, {
        initStorageEvent: {
            enumerable: true
        },
        key: {
            enumerable: true
        },
        oldValue: {
            enumerable: true
        },
        newValue: {
            enumerable: true
        },
        url: {
            enumerable: true
        },
        storageArea: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "StorageEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = StorageEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: StorageEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/StorageEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/PageTransitionEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    EventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "persisted";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'persisted' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/PageTransitionEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const PageTransitionEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/PageTransitionEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Event = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Event.js [middleware-edge] (ecmascript)");
const interfaceName = "PageTransitionEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'PageTransitionEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["PageTransitionEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Event._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class PageTransitionEvent extends globalObject.Event {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'PageTransitionEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'PageTransitionEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = PageTransitionEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'PageTransitionEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get persisted() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get persisted' called on an object that is not a valid instance of PageTransitionEvent.");
            }
            return esValue[implSymbol]["persisted"];
        }
    }
    Object.defineProperties(PageTransitionEvent.prototype, {
        persisted: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "PageTransitionEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = PageTransitionEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: PageTransitionEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/PageTransitionEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/InputEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const UIEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    UIEventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "data";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (value === null || value === undefined) {
                value = null;
            } else {
                value = conversions["DOMString"](value, {
                    context: context + " has member 'data' that",
                    globals: globalObject
                });
            }
            ret[key] = value;
        } else {
            ret[key] = null;
        }
    }
    {
        const key = "inputType";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'inputType' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
    {
        const key = "isComposing";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'isComposing' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/InputEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const InputEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/InputEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "InputEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'InputEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["InputEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class InputEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'InputEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'InputEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = InputEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'InputEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get data() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get data' called on an object that is not a valid instance of InputEvent.");
            }
            return esValue[implSymbol]["data"];
        }
        get isComposing() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get isComposing' called on an object that is not a valid instance of InputEvent.");
            }
            return esValue[implSymbol]["isComposing"];
        }
        get inputType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get inputType' called on an object that is not a valid instance of InputEvent.");
            }
            return esValue[implSymbol]["inputType"];
        }
    }
    Object.defineProperties(InputEvent.prototype, {
        data: {
            enumerable: true
        },
        isComposing: {
            enumerable: true
        },
        inputType: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "InputEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = InputEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: InputEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/InputEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CompositionEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const UIEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    UIEventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "data";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'data' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CompositionEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const CompositionEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CompositionEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const UIEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/UIEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "CompositionEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CompositionEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CompositionEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    UIEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CompositionEvent extends globalObject.UIEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'CompositionEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'CompositionEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = CompositionEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'CompositionEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        initCompositionEvent(typeArg) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'initCompositionEvent' called on an object that is not a valid instance of CompositionEvent.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'initCompositionEvent' on 'CompositionEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'initCompositionEvent' on 'CompositionEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initCompositionEvent' on 'CompositionEvent': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'initCompositionEvent' on 'CompositionEvent': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = utils.tryImplForWrapper(curArg);
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[4];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'initCompositionEvent' on 'CompositionEvent': parameter 5",
                        globals: globalObject
                    });
                } else {
                    curArg = "";
                }
                args.push(curArg);
            }
            return esValue[implSymbol].initCompositionEvent(...args);
        }
        get data() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get data' called on an object that is not a valid instance of CompositionEvent.");
            }
            return esValue[implSymbol]["data"];
        }
    }
    Object.defineProperties(CompositionEvent.prototype, {
        initCompositionEvent: {
            enumerable: true
        },
        data: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "CompositionEvent",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CompositionEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CompositionEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/CompositionEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/WheelEventInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const MouseEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MouseEventInit.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    MouseEventInit._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "deltaMode";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'deltaMode' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "deltaX";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'deltaX' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
    {
        const key = "deltaY";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'deltaY' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
    {
        const key = "deltaZ";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["double"](value, {
                context: context + " has member 'deltaZ' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0.0;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/WheelEvent.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const WheelEventInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/WheelEventInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const MouseEvent = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MouseEvent.js [middleware-edge] (ecmascript)");
const interfaceName = "WheelEvent";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'WheelEvent'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["WheelEvent"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    MouseEvent._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class WheelEvent extends globalObject.MouseEvent {
        constructor(type){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'WheelEvent': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to construct 'WheelEvent': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = WheelEventInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'WheelEvent': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get deltaX() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get deltaX' called on an object that is not a valid instance of WheelEvent.");
            }
            return esValue[implSymbol]["deltaX"];
        }
        get deltaY() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get deltaY' called on an object that is not a valid instance of WheelEvent.");
            }
            return esValue[implSymbol]["deltaY"];
        }
        get deltaZ() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get deltaZ' called on an object that is not a valid instance of WheelEvent.");
            }
            return esValue[implSymbol]["deltaZ"];
        }
        get deltaMode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get deltaMode' called on an object that is not a valid instance of WheelEvent.");
            }
            return esValue[implSymbol]["deltaMode"];
        }
    }
    Object.defineProperties(WheelEvent.prototype, {
        deltaX: {
            enumerable: true
        },
        deltaY: {
            enumerable: true
        },
        deltaZ: {
            enumerable: true
        },
        deltaMode: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "WheelEvent",
            configurable: true
        },
        DOM_DELTA_PIXEL: {
            value: 0x00,
            enumerable: true
        },
        DOM_DELTA_LINE: {
            value: 0x01,
            enumerable: true
        },
        DOM_DELTA_PAGE: {
            value: 0x02,
            enumerable: true
        }
    });
    Object.defineProperties(WheelEvent, {
        DOM_DELTA_PIXEL: {
            value: 0x00,
            enumerable: true
        },
        DOM_DELTA_LINE: {
            value: 0x01,
            enumerable: true
        },
        DOM_DELTA_PAGE: {
            value: 0x02,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = WheelEvent;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: WheelEvent
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/events/WheelEvent-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/BarProp.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "BarProp";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'BarProp'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["BarProp"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class BarProp {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get visible() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get visible' called on an object that is not a valid instance of BarProp.");
            }
            return esValue[implSymbol]["visible"];
        }
    }
    Object.defineProperties(BarProp.prototype, {
        visible: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "BarProp",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = BarProp;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: BarProp
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/window/BarProp-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/External.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "External";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'External'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["External"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class External {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        AddSearchProvider() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'AddSearchProvider' called on an object that is not a valid instance of External.");
            }
            return esValue[implSymbol].AddSearchProvider();
        }
        IsSearchProviderInstalled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'IsSearchProviderInstalled' called on an object that is not a valid instance of External.");
            }
            return esValue[implSymbol].IsSearchProviderInstalled();
        }
    }
    Object.defineProperties(External.prototype, {
        AddSearchProvider: {
            enumerable: true
        },
        IsSearchProviderInstalled: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "External",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = External;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: External
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/window/External-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Screen.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Screen";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Screen'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Screen"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Screen {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get availWidth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get availWidth' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["availWidth"];
        }
        get availHeight() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get availHeight' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["availHeight"];
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["width"];
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["height"];
        }
        get colorDepth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get colorDepth' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["colorDepth"];
        }
        get pixelDepth() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get pixelDepth' called on an object that is not a valid instance of Screen.");
            }
            return esValue[implSymbol]["pixelDepth"];
        }
    }
    Object.defineProperties(Screen.prototype, {
        availWidth: {
            enumerable: true
        },
        availHeight: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        colorDepth: {
            enumerable: true
        },
        pixelDepth: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Screen",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Screen;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Screen
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/window/Screen-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Performance.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "Performance";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Performance'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Performance"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Performance extends globalObject.EventTarget {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        now() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'now' called on an object that is not a valid instance of Performance.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].now());
        }
        toJSON() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of Performance.");
            }
            return esValue[implSymbol].toJSON();
        }
        get timeOrigin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get timeOrigin' called on an object that is not a valid instance of Performance.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["timeOrigin"]);
        }
    }
    Object.defineProperties(Performance.prototype, {
        now: {
            enumerable: true
        },
        toJSON: {
            enumerable: true
        },
        timeOrigin: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Performance",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Performance;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Performance
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/hr-time/Performance-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/PluginArray.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "PluginArray";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'PluginArray'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["PluginArray"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class PluginArray {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        refresh() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'refresh' called on an object that is not a valid instance of PluginArray.");
            }
            return esValue[implSymbol].refresh();
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of PluginArray.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'PluginArray': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'PluginArray': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].item(...args);
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of PluginArray.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'PluginArray': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'PluginArray': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].namedItem(...args);
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of PluginArray.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(PluginArray.prototype, {
        refresh: {
            enumerable: true
        },
        item: {
            enumerable: true
        },
        namedItem: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "PluginArray",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = PluginArray;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: PluginArray
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/navigator/PluginArray-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MimeTypeArray.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "MimeTypeArray";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MimeTypeArray'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MimeTypeArray"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MimeTypeArray {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of MimeTypeArray.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'MimeTypeArray': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'MimeTypeArray': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].item(...args);
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of MimeTypeArray.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'MimeTypeArray': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'MimeTypeArray': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].namedItem(...args);
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of MimeTypeArray.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(MimeTypeArray.prototype, {
        item: {
            enumerable: true
        },
        namedItem: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MimeTypeArray",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = MimeTypeArray;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MimeTypeArray
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            const indexedValue = target[implSymbol].item(index);
            if (indexedValue !== null) {
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !(target[implSymbol].item(index) !== null);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/navigator/MimeTypeArray-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Navigator.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Navigator";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Navigator'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Navigator"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Navigator {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        javaEnabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'javaEnabled' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol].javaEnabled();
        }
        get appCodeName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get appCodeName' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["appCodeName"];
        }
        get appName() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get appName' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["appName"];
        }
        get appVersion() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get appVersion' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["appVersion"];
        }
        get platform() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get platform' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["platform"];
        }
        get product() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get product' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["product"];
        }
        get productSub() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get productSub' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["productSub"];
        }
        get userAgent() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get userAgent' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["userAgent"];
        }
        get vendor() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vendor' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["vendor"];
        }
        get vendorSub() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get vendorSub' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["vendorSub"];
        }
        get language() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get language' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["language"];
        }
        get languages() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get languages' called on an object that is not a valid instance of Navigator.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["languages"]);
        }
        get onLine() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onLine' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["onLine"];
        }
        get cookieEnabled() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get cookieEnabled' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["cookieEnabled"];
        }
        get plugins() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get plugins' called on an object that is not a valid instance of Navigator.");
            }
            return utils.getSameObject(this, "plugins", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["plugins"]);
            });
        }
        get mimeTypes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get mimeTypes' called on an object that is not a valid instance of Navigator.");
            }
            return utils.getSameObject(this, "mimeTypes", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["mimeTypes"]);
            });
        }
        get hardwareConcurrency() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get hardwareConcurrency' called on an object that is not a valid instance of Navigator.");
            }
            return esValue[implSymbol]["hardwareConcurrency"];
        }
    }
    Object.defineProperties(Navigator.prototype, {
        javaEnabled: {
            enumerable: true
        },
        appCodeName: {
            enumerable: true
        },
        appName: {
            enumerable: true
        },
        appVersion: {
            enumerable: true
        },
        platform: {
            enumerable: true
        },
        product: {
            enumerable: true
        },
        productSub: {
            enumerable: true
        },
        userAgent: {
            enumerable: true
        },
        vendor: {
            enumerable: true
        },
        vendorSub: {
            enumerable: true
        },
        language: {
            enumerable: true
        },
        languages: {
            enumerable: true
        },
        onLine: {
            enumerable: true
        },
        cookieEnabled: {
            enumerable: true
        },
        plugins: {
            enumerable: true
        },
        mimeTypes: {
            enumerable: true
        },
        hardwareConcurrency: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Navigator",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Navigator;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Navigator
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/navigator/Navigator-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Crypto.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Crypto";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Crypto'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Crypto"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Crypto {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        getRandomValues(array) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getRandomValues' called on an object that is not a valid instance of Crypto.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getRandomValues' on 'Crypto': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (ArrayBuffer.isView(curArg)) {} else {
                    throw new globalObject.TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1" + " is not of any supported type.");
                }
                args.push(curArg);
            }
            return esValue[implSymbol].getRandomValues(...args);
        }
        randomUUID() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'randomUUID' called on an object that is not a valid instance of Crypto.");
            }
            return esValue[implSymbol].randomUUID();
        }
    }
    Object.defineProperties(Crypto.prototype, {
        getRandomValues: {
            enumerable: true
        },
        randomUUID: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Crypto",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Crypto;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Crypto
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/crypto/Crypto-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Plugin.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Plugin";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Plugin'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Plugin"].prototype;
    }
    return Object.create(proto);
}
function makeProxy(wrapper, globalObject) {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
        proxyHandler = new ProxyHandler(globalObject);
        proxyHandlerCache.set(globalObject, proxyHandler);
    }
    return new Proxy(wrapper, proxyHandler);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    let wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper = makeProxy(wrapper, globalObject);
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Plugin {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        item(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'item' called on an object that is not a valid instance of Plugin.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'item' on 'Plugin': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'item' on 'Plugin': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].item(...args);
        }
        namedItem(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'namedItem' called on an object that is not a valid instance of Plugin.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'namedItem' on 'Plugin': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'namedItem' on 'Plugin': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].namedItem(...args);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of Plugin.");
            }
            return esValue[implSymbol]["name"];
        }
        get description() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get description' called on an object that is not a valid instance of Plugin.");
            }
            return esValue[implSymbol]["description"];
        }
        get filename() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get filename' called on an object that is not a valid instance of Plugin.");
            }
            return esValue[implSymbol]["filename"];
        }
        get length() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get length' called on an object that is not a valid instance of Plugin.");
            }
            return esValue[implSymbol]["length"];
        }
    }
    Object.defineProperties(Plugin.prototype, {
        item: {
            enumerable: true
        },
        namedItem: {
            enumerable: true
        },
        name: {
            enumerable: true
        },
        description: {
            enumerable: true
        },
        filename: {
            enumerable: true
        },
        length: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Plugin",
            configurable: true
        },
        [Symbol.iterator]: {
            value: globalObject.Array.prototype[Symbol.iterator],
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = Plugin;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Plugin
    });
};
const proxyHandlerCache = new WeakMap();
class ProxyHandler {
    constructor(globalObject){
        this._globalObject = globalObject;
    }
    get(target, P, receiver) {
        if (typeof P === "symbol") {
            return Reflect.get(target, P, receiver);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc === undefined) {
            const parent = Object.getPrototypeOf(target);
            if (parent === null) {
                return undefined;
            }
            return Reflect.get(target, P, receiver);
        }
        if (!desc.get && !desc.set) {
            return desc.value;
        }
        const getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return Reflect.apply(getter, receiver, []);
    }
    has(target, P) {
        if (typeof P === "symbol") {
            return Reflect.has(target, P);
        }
        const desc = this.getOwnPropertyDescriptor(target, P);
        if (desc !== undefined) {
            return true;
        }
        const parent = Object.getPrototypeOf(target);
        if (parent !== null) {
            return Reflect.has(parent, P);
        }
        return false;
    }
    ownKeys(target) {
        const keys = new Set();
        for (const key of target[implSymbol][utils.supportedPropertyIndices]){
            keys.add(`${key}`);
        }
        for (const key of Reflect.ownKeys(target)){
            keys.add(key);
        }
        return [
            ...keys
        ];
    }
    getOwnPropertyDescriptor(target, P) {
        if (typeof P === "symbol") {
            return Reflect.getOwnPropertyDescriptor(target, P);
        }
        let ignoreNamedProps = false;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            if (target[implSymbol][utils.supportsPropertyIndex](index)) {
                const indexedValue = target[implSymbol].item(index);
                return {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
            ignoreNamedProps = true;
        }
        return Reflect.getOwnPropertyDescriptor(target, P);
    }
    set(target, P, V, receiver) {
        if (typeof P === "symbol") {
            return Reflect.set(target, P, V, receiver);
        }
        // The `receiver` argument refers to the Proxy exotic object or an object
        // that inherits from it, whereas `target` refers to the Proxy target:
        if (target[implSymbol][utils.wrapperSymbol] === receiver) {
            const globalObject = this._globalObject;
        }
        let ownDesc;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            if (target[implSymbol][utils.supportsPropertyIndex](index)) {
                const indexedValue = target[implSymbol].item(index);
                ownDesc = {
                    writable: false,
                    enumerable: true,
                    configurable: true,
                    value: utils.tryWrapperForImpl(indexedValue)
                };
            }
        }
        if (ownDesc === undefined) {
            ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
        }
        if (ownDesc === undefined) {
            const parent = Reflect.getPrototypeOf(target);
            if (parent !== null) {
                return Reflect.set(parent, P, V, receiver);
            }
            ownDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: undefined
            };
        }
        if (!ownDesc.writable) {
            return false;
        }
        if (!utils.isObject(receiver)) {
            return false;
        }
        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
        let valueDesc;
        if (existingDesc !== undefined) {
            if (existingDesc.get || existingDesc.set) {
                return false;
            }
            if (!existingDesc.writable) {
                return false;
            }
            valueDesc = {
                value: V
            };
        } else {
            valueDesc = {
                writable: true,
                enumerable: true,
                configurable: true,
                value: V
            };
        }
        return Reflect.defineProperty(receiver, P, valueDesc);
    }
    defineProperty(target, P, desc) {
        if (typeof P === "symbol") {
            return Reflect.defineProperty(target, P, desc);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            return false;
        }
        return Reflect.defineProperty(target, P, desc);
    }
    deleteProperty(target, P) {
        if (typeof P === "symbol") {
            return Reflect.deleteProperty(target, P);
        }
        const globalObject = this._globalObject;
        if (utils.isArrayIndexPropName(P)) {
            const index = P >>> 0;
            return !target[implSymbol][utils.supportsPropertyIndex](index);
        }
        return Reflect.deleteProperty(target, P);
    }
    preventExtensions() {
        return false;
    }
}
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/navigator/Plugin-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MimeType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "MimeType";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MimeType'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MimeType"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MimeType {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of MimeType.");
            }
            return esValue[implSymbol]["type"];
        }
        get description() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get description' called on an object that is not a valid instance of MimeType.");
            }
            return esValue[implSymbol]["description"];
        }
        get suffixes() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get suffixes' called on an object that is not a valid instance of MimeType.");
            }
            return esValue[implSymbol]["suffixes"];
        }
        get enabledPlugin() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get enabledPlugin' called on an object that is not a valid instance of MimeType.");
            }
            return esValue[implSymbol]["enabledPlugin"];
        }
    }
    Object.defineProperties(MimeType.prototype, {
        type: {
            enumerable: true
        },
        description: {
            enumerable: true
        },
        suffixes: {
            enumerable: true
        },
        enabledPlugin: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MimeType",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = MimeType;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MimeType
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/navigator/MimeType-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/EndingType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "transparent",
    "native"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for EndingType`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/BlobPropertyBag.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EndingType = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EndingType.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "endings";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = EndingType.convert(globalObject, value, {
                context: context + " has member 'endings' that"
            });
            ret[key] = value;
        } else {
            ret[key] = "transparent";
        }
    }
    {
        const key = "type";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'type' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = "";
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const BlobPropertyBag = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/BlobPropertyBag.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Blob";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Blob'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Blob"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Blob {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    if (!utils.isObject(curArg)) {
                        throw new globalObject.TypeError("Failed to construct 'Blob': parameter 1" + " is not an iterable object.");
                    } else {
                        const V = [];
                        const tmp = curArg;
                        for (let nextItem of tmp){
                            if (exports.is(nextItem)) {
                                nextItem = utils.implForWrapper(nextItem);
                            } else if (utils.isArrayBuffer(nextItem)) {} else if (ArrayBuffer.isView(nextItem)) {} else {
                                nextItem = conversions["USVString"](nextItem, {
                                    context: "Failed to construct 'Blob': parameter 1" + "'s element",
                                    globals: globalObject
                                });
                            }
                            V.push(nextItem);
                        }
                        curArg = V;
                    }
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = BlobPropertyBag.convert(globalObject, curArg, {
                    context: "Failed to construct 'Blob': parameter 2"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        slice() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'slice' called on an object that is not a valid instance of Blob.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["long long"](curArg, {
                        context: "Failed to execute 'slice' on 'Blob': parameter 1",
                        globals: globalObject,
                        clamp: true
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["long long"](curArg, {
                        context: "Failed to execute 'slice' on 'Blob': parameter 2",
                        globals: globalObject,
                        clamp: true
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'slice' on 'Blob': parameter 3",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].slice(...args));
        }
        get size() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of Blob.");
            }
            return esValue[implSymbol]["size"];
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of Blob.");
            }
            return esValue[implSymbol]["type"];
        }
    }
    Object.defineProperties(Blob.prototype, {
        slice: {
            enumerable: true
        },
        size: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Blob",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Blob;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Blob
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/file-api/Blob-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FileReader.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Blob = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)");
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "FileReader";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'FileReader'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["FileReader"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class FileReader extends globalObject.EventTarget {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        readAsArrayBuffer(blob) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'readAsArrayBuffer' called on an object that is not a valid instance of FileReader.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'readAsArrayBuffer' on 'FileReader': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Blob.convert(globalObject, curArg, {
                    context: "Failed to execute 'readAsArrayBuffer' on 'FileReader': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].readAsArrayBuffer(...args);
        }
        readAsBinaryString(blob) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'readAsBinaryString' called on an object that is not a valid instance of FileReader.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'readAsBinaryString' on 'FileReader': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Blob.convert(globalObject, curArg, {
                    context: "Failed to execute 'readAsBinaryString' on 'FileReader': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].readAsBinaryString(...args);
        }
        readAsText(blob) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'readAsText' called on an object that is not a valid instance of FileReader.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'readAsText' on 'FileReader': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Blob.convert(globalObject, curArg, {
                    context: "Failed to execute 'readAsText' on 'FileReader': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'readAsText' on 'FileReader': parameter 2",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].readAsText(...args);
        }
        readAsDataURL(blob) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'readAsDataURL' called on an object that is not a valid instance of FileReader.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'readAsDataURL' on 'FileReader': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Blob.convert(globalObject, curArg, {
                    context: "Failed to execute 'readAsDataURL' on 'FileReader': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].readAsDataURL(...args);
        }
        abort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'abort' called on an object that is not a valid instance of FileReader.");
            }
            return esValue[implSymbol].abort();
        }
        get readyState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readyState' called on an object that is not a valid instance of FileReader.");
            }
            return esValue[implSymbol]["readyState"];
        }
        get result() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get result' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["result"]);
        }
        get error() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get error' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["error"]);
        }
        get onloadstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadstart' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadstart"]);
        }
        set onloadstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadstart' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadstart' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onloadstart"] = V;
        }
        get onprogress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onprogress' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onprogress"]);
        }
        set onprogress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onprogress' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onprogress' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onprogress"] = V;
        }
        get onload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onload' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onload"]);
        }
        set onload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onload' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onload' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onload"] = V;
        }
        get onabort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onabort' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onabort"]);
        }
        set onabort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onabort' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onabort' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onabort"] = V;
        }
        get onerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onerror' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onerror"]);
        }
        set onerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onerror' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onerror' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onerror"] = V;
        }
        get onloadend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadend' called on an object that is not a valid instance of FileReader.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadend"]);
        }
        set onloadend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadend' called on an object that is not a valid instance of FileReader.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadend' property on 'FileReader': The provided value"
                });
            }
            esValue[implSymbol]["onloadend"] = V;
        }
    }
    Object.defineProperties(FileReader.prototype, {
        readAsArrayBuffer: {
            enumerable: true
        },
        readAsBinaryString: {
            enumerable: true
        },
        readAsText: {
            enumerable: true
        },
        readAsDataURL: {
            enumerable: true
        },
        abort: {
            enumerable: true
        },
        readyState: {
            enumerable: true
        },
        result: {
            enumerable: true
        },
        error: {
            enumerable: true
        },
        onloadstart: {
            enumerable: true
        },
        onprogress: {
            enumerable: true
        },
        onload: {
            enumerable: true
        },
        onabort: {
            enumerable: true
        },
        onerror: {
            enumerable: true
        },
        onloadend: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "FileReader",
            configurable: true
        },
        EMPTY: {
            value: 0,
            enumerable: true
        },
        LOADING: {
            value: 1,
            enumerable: true
        },
        DONE: {
            value: 2,
            enumerable: true
        }
    });
    Object.defineProperties(FileReader, {
        EMPTY: {
            value: 0,
            enumerable: true
        },
        LOADING: {
            value: 1,
            enumerable: true
        },
        DONE: {
            value: 2,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = FileReader;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: FileReader
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/file-api/FileReader-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FilePropertyBag.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const BlobPropertyBag = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/BlobPropertyBag.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    BlobPropertyBag._convertInherit(globalObject, obj, ret, {
        context
    });
    {
        const key = "lastModified";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["long long"](value, {
                context: context + " has member 'lastModified' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/File.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Blob = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)");
const FilePropertyBag = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/FilePropertyBag.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "File";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'File'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["File"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    Blob._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class File extends globalObject.Blob {
        constructor(fileBits, fileName){
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError("Failed to construct 'File': parameter 1" + " is not an iterable object.");
                } else {
                    const V = [];
                    const tmp = curArg;
                    for (let nextItem of tmp){
                        if (Blob.is(nextItem)) {
                            nextItem = utils.implForWrapper(nextItem);
                        } else if (utils.isArrayBuffer(nextItem)) {} else if (ArrayBuffer.isView(nextItem)) {} else {
                            nextItem = conversions["USVString"](nextItem, {
                                context: "Failed to construct 'File': parameter 1" + "'s element",
                                globals: globalObject
                            });
                        }
                        V.push(nextItem);
                    }
                    curArg = V;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to construct 'File': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                curArg = FilePropertyBag.convert(globalObject, curArg, {
                    context: "Failed to construct 'File': parameter 3"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get name() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get name' called on an object that is not a valid instance of File.");
            }
            return esValue[implSymbol]["name"];
        }
        get lastModified() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get lastModified' called on an object that is not a valid instance of File.");
            }
            return esValue[implSymbol]["lastModified"];
        }
    }
    Object.defineProperties(File.prototype, {
        name: {
            enumerable: true
        },
        lastModified: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "File",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = File;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: File
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/file-api/File-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/SupportedType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "text/html",
    "text/xml",
    "application/xml",
    "application/xhtml+xml",
    "image/svg+xml"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for SupportedType`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMParser.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const SupportedType = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/SupportedType.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMParser";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMParser'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMParser"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMParser {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        parseFromString(str, type) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'parseFromString' called on an object that is not a valid instance of DOMParser.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'parseFromString' on 'DOMParser': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'parseFromString' on 'DOMParser': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = SupportedType.convert(globalObject, curArg, {
                    context: "Failed to execute 'parseFromString' on 'DOMParser': parameter 2"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].parseFromString(...args));
        }
    }
    Object.defineProperties(DOMParser.prototype, {
        parseFromString: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMParser",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = DOMParser;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMParser
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/domparsing/DOMParser-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLSerializer.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "XMLSerializer";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'XMLSerializer'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["XMLSerializer"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class XMLSerializer {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        serializeToString(root) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'serializeToString' called on an object that is not a valid instance of XMLSerializer.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'serializeToString' on 'XMLSerializer': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'serializeToString' on 'XMLSerializer': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].serializeToString(...args);
        }
    }
    Object.defineProperties(XMLSerializer.prototype, {
        serializeToString: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "XMLSerializer",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = XMLSerializer;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: XMLSerializer
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/domparsing/XMLSerializer-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Function.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        for(let i = 0; i < args.length; i++){
            args[i] = utils.tryWrapperForImpl(args[i]);
        }
        callResult = Reflect.apply(value, thisArg, args);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    }
    invokeTheCallbackFunction.construct = (...args)=>{
        for(let i = 0; i < args.length; i++){
            args[i] = utils.tryWrapperForImpl(args[i]);
        }
        let callResult = Reflect.construct(value, args);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/FormData.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const HTMLFormElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLFormElement.js [middleware-edge] (ecmascript)");
const HTMLElement = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js [middleware-edge] (ecmascript)");
const Blob = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)");
const Function = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Function.js [middleware-edge] (ecmascript)");
const newObjectInRealm = utils.newObjectInRealm;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "FormData";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'FormData'.`);
};
exports.createDefaultIterator = (globalObject, target, kind)=>{
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["FormData Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils.iterInternalSymbol, {
        value: {
            target,
            kind,
            index: 0
        },
        configurable: true
    });
    return iterator;
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["FormData"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class FormData {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = HTMLFormElement.convert(globalObject, curArg, {
                        context: "Failed to construct 'FormData': parameter 1"
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        curArg = HTMLElement.convert(globalObject, curArg, {
                            context: "Failed to construct 'FormData': parameter 2"
                        });
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'append' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            switch(arguments.length){
                case 2:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'append' on 'FormData': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        if (Blob.is(curArg)) {
                            {
                                let curArg = arguments[1];
                                curArg = Blob.convert(globalObject, curArg, {
                                    context: "Failed to execute 'append' on 'FormData': parameter 2"
                                });
                                args.push(curArg);
                            }
                        } else {
                            {
                                let curArg = arguments[1];
                                curArg = conversions["USVString"](curArg, {
                                    context: "Failed to execute 'append' on 'FormData': parameter 2",
                                    globals: globalObject
                                });
                                args.push(curArg);
                            }
                        }
                    }
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'append' on 'FormData': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = Blob.convert(globalObject, curArg, {
                            context: "Failed to execute 'append' on 'FormData': parameter 2"
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        if (curArg !== undefined) {
                            curArg = conversions["USVString"](curArg, {
                                context: "Failed to execute 'append' on 'FormData': parameter 3",
                                globals: globalObject
                            });
                        }
                        args.push(curArg);
                    }
            }
            return esValue[implSymbol].append(...args);
        }
        delete(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'delete' on 'FormData': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to execute 'delete' on 'FormData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].delete(...args);
        }
        get(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'get' on 'FormData': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to execute 'get' on 'FormData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].get(...args));
        }
        getAll(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getAll' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getAll' on 'FormData': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to execute 'getAll' on 'FormData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
        }
        has(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'has' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'has' on 'FormData': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to execute 'has' on 'FormData': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].has(...args);
        }
        set(name, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            switch(arguments.length){
                case 2:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'set' on 'FormData': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        if (Blob.is(curArg)) {
                            {
                                let curArg = arguments[1];
                                curArg = Blob.convert(globalObject, curArg, {
                                    context: "Failed to execute 'set' on 'FormData': parameter 2"
                                });
                                args.push(curArg);
                            }
                        } else {
                            {
                                let curArg = arguments[1];
                                curArg = conversions["USVString"](curArg, {
                                    context: "Failed to execute 'set' on 'FormData': parameter 2",
                                    globals: globalObject
                                });
                                args.push(curArg);
                            }
                        }
                    }
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'set' on 'FormData': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = Blob.convert(globalObject, curArg, {
                            context: "Failed to execute 'set' on 'FormData': parameter 2"
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        if (curArg !== undefined) {
                            curArg = conversions["USVString"](curArg, {
                                context: "Failed to execute 'set' on 'FormData': parameter 3",
                                globals: globalObject
                            });
                        }
                        args.push(curArg);
                    }
            }
            return esValue[implSymbol].set(...args);
        }
        keys() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of FormData.");
            }
            return exports.createDefaultIterator(globalObject, this, "key");
        }
        values() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'values' called on an object that is not a valid instance of FormData.");
            }
            return exports.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of FormData.");
            }
            return exports.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of FormData.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
            }
            callback = Function.convert(globalObject, callback, {
                context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
            });
            const thisArg = arguments[1];
            let pairs = Array.from(this[implSymbol]);
            let i = 0;
            while(i < pairs.length){
                const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
                callback.call(thisArg, value, key, this);
                pairs = Array.from(this[implSymbol]);
                i++;
            }
        }
    }
    Object.defineProperties(FormData.prototype, {
        append: {
            enumerable: true
        },
        delete: {
            enumerable: true
        },
        get: {
            enumerable: true
        },
        getAll: {
            enumerable: true
        },
        has: {
            enumerable: true
        },
        set: {
            enumerable: true
        },
        keys: {
            enumerable: true
        },
        values: {
            enumerable: true
        },
        entries: {
            enumerable: true
        },
        forEach: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "FormData",
            configurable: true
        },
        [Symbol.iterator]: {
            value: FormData.prototype.entries,
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = FormData;
    ctorRegistry["FormData Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
            configurable: true,
            value: "FormData Iterator"
        }
    });
    utils.define(ctorRegistry["FormData Iterator"], {
        next () {
            const internal = this && this[utils.iterInternalSymbol];
            if (!internal) {
                throw new globalObject.TypeError("next() called on a value that is not a FormData iterator object");
            }
            const { target, kind, index } = internal;
            const values = Array.from(target[implSymbol]);
            const len = values.length;
            if (index >= len) {
                return newObjectInRealm(globalObject, {
                    value: undefined,
                    done: true
                });
            }
            const pair = values[index];
            internal.index = index + 1;
            return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
        }
    });
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: FormData
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/xhr/FormData-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestEventTarget.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "XMLHttpRequestEventTarget";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'XMLHttpRequestEventTarget'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["XMLHttpRequestEventTarget"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "DedicatedWorker",
    "SharedWorker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class XMLHttpRequestEventTarget extends globalObject.EventTarget {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        get onloadstart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadstart' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadstart"]);
        }
        set onloadstart(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadstart' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadstart' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onloadstart"] = V;
        }
        get onprogress() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onprogress' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onprogress"]);
        }
        set onprogress(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onprogress' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onprogress' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onprogress"] = V;
        }
        get onabort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onabort' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onabort"]);
        }
        set onabort(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onabort' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onabort' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onabort"] = V;
        }
        get onerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onerror' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onerror"]);
        }
        set onerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onerror' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onerror' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onerror"] = V;
        }
        get onload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onload' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onload"]);
        }
        set onload(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onload' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onload' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onload"] = V;
        }
        get ontimeout() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get ontimeout' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["ontimeout"]);
        }
        set ontimeout(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set ontimeout' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'ontimeout' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["ontimeout"] = V;
        }
        get onloadend() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onloadend' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onloadend"]);
        }
        set onloadend(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onloadend' called on an object that is not a valid instance of XMLHttpRequestEventTarget.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onloadend' property on 'XMLHttpRequestEventTarget': The provided value"
                });
            }
            esValue[implSymbol]["onloadend"] = V;
        }
    }
    Object.defineProperties(XMLHttpRequestEventTarget.prototype, {
        onloadstart: {
            enumerable: true
        },
        onprogress: {
            enumerable: true
        },
        onabort: {
            enumerable: true
        },
        onerror: {
            enumerable: true
        },
        onload: {
            enumerable: true
        },
        ontimeout: {
            enumerable: true
        },
        onloadend: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "XMLHttpRequestEventTarget",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = XMLHttpRequestEventTarget;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: XMLHttpRequestEventTarget
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequestEventTarget-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestUpload.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const XMLHttpRequestEventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestEventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "XMLHttpRequestUpload";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'XMLHttpRequestUpload'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["XMLHttpRequestUpload"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    XMLHttpRequestEventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "DedicatedWorker",
    "SharedWorker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class XMLHttpRequestUpload extends globalObject.XMLHttpRequestEventTarget {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
    }
    Object.defineProperties(XMLHttpRequestUpload.prototype, {
        [Symbol.toStringTag]: {
            value: "XMLHttpRequestUpload",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = XMLHttpRequestUpload;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: XMLHttpRequestUpload
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequestUpload-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestResponseType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "",
    "arraybuffer",
    "blob",
    "document",
    "json",
    "text"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for XMLHttpRequestResponseType`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequest.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Document = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Document.js [middleware-edge] (ecmascript)");
const Blob = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)");
const FormData = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/FormData.js [middleware-edge] (ecmascript)");
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const XMLHttpRequestResponseType = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestResponseType.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const XMLHttpRequestEventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/XMLHttpRequestEventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "XMLHttpRequest";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'XMLHttpRequest'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["XMLHttpRequest"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    XMLHttpRequestEventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "DedicatedWorker",
    "SharedWorker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class XMLHttpRequest extends globalObject.XMLHttpRequestEventTarget {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        open(method, url) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'open' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'open' on 'XMLHttpRequest': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            switch(arguments.length){
                case 2:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["ByteString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                case 3:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["ByteString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    break;
                case 4:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["ByteString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[3];
                        if (curArg !== undefined) {
                            if (curArg === null || curArg === undefined) {
                                curArg = null;
                            } else {
                                curArg = conversions["USVString"](curArg, {
                                    context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 4",
                                    globals: globalObject
                                });
                            }
                        } else {
                            curArg = null;
                        }
                        args.push(curArg);
                    }
                    break;
                default:
                    {
                        let curArg = arguments[0];
                        curArg = conversions["ByteString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[1];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 2",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[2];
                        curArg = conversions["boolean"](curArg, {
                            context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 3",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[3];
                        if (curArg !== undefined) {
                            if (curArg === null || curArg === undefined) {
                                curArg = null;
                            } else {
                                curArg = conversions["USVString"](curArg, {
                                    context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 4",
                                    globals: globalObject
                                });
                            }
                        } else {
                            curArg = null;
                        }
                        args.push(curArg);
                    }
                    {
                        let curArg = arguments[4];
                        if (curArg !== undefined) {
                            if (curArg === null || curArg === undefined) {
                                curArg = null;
                            } else {
                                curArg = conversions["USVString"](curArg, {
                                    context: "Failed to execute 'open' on 'XMLHttpRequest': parameter 5",
                                    globals: globalObject
                                });
                            }
                        } else {
                            curArg = null;
                        }
                        args.push(curArg);
                    }
            }
            return esValue[implSymbol].open(...args);
        }
        setRequestHeader(name, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setRequestHeader' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'setRequestHeader' on 'XMLHttpRequest': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'setRequestHeader' on 'XMLHttpRequest': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'setRequestHeader' on 'XMLHttpRequest': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setRequestHeader(...args);
        }
        send() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'send' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    if (curArg === null || curArg === undefined) {
                        curArg = null;
                    } else {
                        if (Document.is(curArg) || Blob.is(curArg) || FormData.is(curArg)) {
                            curArg = utils.implForWrapper(curArg);
                        } else if (utils.isArrayBuffer(curArg)) {} else if (ArrayBuffer.isView(curArg)) {} else {
                            curArg = conversions["USVString"](curArg, {
                                context: "Failed to execute 'send' on 'XMLHttpRequest': parameter 1",
                                globals: globalObject
                            });
                        }
                    }
                } else {
                    curArg = null;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].send(...args);
        }
        abort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'abort' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol].abort();
        }
        getResponseHeader(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getResponseHeader' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getResponseHeader' on 'XMLHttpRequest': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'getResponseHeader' on 'XMLHttpRequest': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].getResponseHeader(...args);
        }
        getAllResponseHeaders() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getAllResponseHeaders' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol].getAllResponseHeaders();
        }
        overrideMimeType(mime) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'overrideMimeType' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'overrideMimeType' on 'XMLHttpRequest': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'overrideMimeType' on 'XMLHttpRequest': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].overrideMimeType(...args);
        }
        get onreadystatechange() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onreadystatechange' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onreadystatechange"]);
        }
        set onreadystatechange(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onreadystatechange' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onreadystatechange' property on 'XMLHttpRequest': The provided value"
                });
            }
            esValue[implSymbol]["onreadystatechange"] = V;
        }
        get readyState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readyState' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["readyState"];
        }
        get timeout() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get timeout' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["timeout"];
        }
        set timeout(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set timeout' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            V = conversions["unsigned long"](V, {
                context: "Failed to set the 'timeout' property on 'XMLHttpRequest': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["timeout"] = V;
        }
        get withCredentials() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get withCredentials' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["withCredentials"];
        }
        set withCredentials(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set withCredentials' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            V = conversions["boolean"](V, {
                context: "Failed to set the 'withCredentials' property on 'XMLHttpRequest': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["withCredentials"] = V;
        }
        get upload() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get upload' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return utils.getSameObject(this, "upload", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["upload"]);
            });
        }
        get responseURL() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get responseURL' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["responseURL"];
        }
        get status() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get status' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["status"];
        }
        get statusText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get statusText' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["statusText"];
        }
        get responseType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get responseType' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["responseType"]);
        }
        set responseType(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set responseType' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            V = `${V}`;
            if (!XMLHttpRequestResponseType.enumerationValues.has(V)) {
                return;
            }
            esValue[implSymbol]["responseType"] = V;
        }
        get response() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get response' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["response"];
        }
        get responseText() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get responseText' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return esValue[implSymbol]["responseText"];
        }
        get responseXML() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get responseXML' called on an object that is not a valid instance of XMLHttpRequest.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["responseXML"]);
        }
    }
    Object.defineProperties(XMLHttpRequest.prototype, {
        open: {
            enumerable: true
        },
        setRequestHeader: {
            enumerable: true
        },
        send: {
            enumerable: true
        },
        abort: {
            enumerable: true
        },
        getResponseHeader: {
            enumerable: true
        },
        getAllResponseHeaders: {
            enumerable: true
        },
        overrideMimeType: {
            enumerable: true
        },
        onreadystatechange: {
            enumerable: true
        },
        readyState: {
            enumerable: true
        },
        timeout: {
            enumerable: true
        },
        withCredentials: {
            enumerable: true
        },
        upload: {
            enumerable: true
        },
        responseURL: {
            enumerable: true
        },
        status: {
            enumerable: true
        },
        statusText: {
            enumerable: true
        },
        responseType: {
            enumerable: true
        },
        response: {
            enumerable: true
        },
        responseText: {
            enumerable: true
        },
        responseXML: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "XMLHttpRequest",
            configurable: true
        },
        UNSENT: {
            value: 0,
            enumerable: true
        },
        OPENED: {
            value: 1,
            enumerable: true
        },
        HEADERS_RECEIVED: {
            value: 2,
            enumerable: true
        },
        LOADING: {
            value: 3,
            enumerable: true
        },
        DONE: {
            value: 4,
            enumerable: true
        }
    });
    Object.defineProperties(XMLHttpRequest, {
        UNSENT: {
            value: 0,
            enumerable: true
        },
        OPENED: {
            value: 1,
            enumerable: true
        },
        HEADERS_RECEIVED: {
            value: 2,
            enumerable: true
        },
        LOADING: {
            value: 3,
            enumerable: true
        },
        DONE: {
            value: 4,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = XMLHttpRequest;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: XMLHttpRequest
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequest-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/BinaryType.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const enumerationValues = new Set([
    "blob",
    "arraybuffer"
]);
exports.enumerationValues = enumerationValues;
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    const string = `${value}`;
    if (!enumerationValues.has(string)) {
        throw new globalObject.TypeError(`${context} '${string}' is not a valid enumeration value for BinaryType`);
    }
    return string;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/WebSocket.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Blob = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Blob.js [middleware-edge] (ecmascript)");
const EventHandlerNonNull = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventHandlerNonNull.js [middleware-edge] (ecmascript)");
const BinaryType = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/BinaryType.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const EventTarget = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js [middleware-edge] (ecmascript)");
const interfaceName = "WebSocket";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'WebSocket'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["WebSocket"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    EventTarget._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class WebSocket extends globalObject.EventTarget {
        constructor(url){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'WebSocket': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["USVString"](curArg, {
                    context: "Failed to construct 'WebSocket': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    if (utils.isObject(curArg)) {
                        if (curArg[Symbol.iterator] !== undefined) {
                            if (!utils.isObject(curArg)) {
                                throw new globalObject.TypeError("Failed to construct 'WebSocket': parameter 2" + " sequence" + " is not an iterable object.");
                            } else {
                                const V = [];
                                const tmp = curArg;
                                for (let nextItem of tmp){
                                    nextItem = conversions["DOMString"](nextItem, {
                                        context: "Failed to construct 'WebSocket': parameter 2" + " sequence" + "'s element",
                                        globals: globalObject
                                    });
                                    V.push(nextItem);
                                }
                                curArg = V;
                            }
                        } else {}
                    } else {
                        curArg = conversions["DOMString"](curArg, {
                            context: "Failed to construct 'WebSocket': parameter 2",
                            globals: globalObject
                        });
                    }
                } else {
                    curArg = [];
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        close() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'close' called on an object that is not a valid instance of WebSocket.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["unsigned short"](curArg, {
                        context: "Failed to execute 'close' on 'WebSocket': parameter 1",
                        globals: globalObject,
                        clamp: true
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["USVString"](curArg, {
                        context: "Failed to execute 'close' on 'WebSocket': parameter 2",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].close(...args);
        }
        send(data) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'send' called on an object that is not a valid instance of WebSocket.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'send' on 'WebSocket': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (Blob.is(curArg)) {
                    {
                        let curArg = arguments[0];
                        curArg = Blob.convert(globalObject, curArg, {
                            context: "Failed to execute 'send' on 'WebSocket': parameter 1"
                        });
                        args.push(curArg);
                    }
                } else if (utils.isArrayBuffer(curArg)) {
                    {
                        let curArg = arguments[0];
                        curArg = conversions["ArrayBuffer"](curArg, {
                            context: "Failed to execute 'send' on 'WebSocket': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                } else if (ArrayBuffer.isView(curArg)) {
                    {
                        let curArg = arguments[0];
                        if (ArrayBuffer.isView(curArg)) {} else {
                            throw new globalObject.TypeError("Failed to execute 'send' on 'WebSocket': parameter 1" + " is not of any supported type.");
                        }
                        args.push(curArg);
                    }
                } else {
                    {
                        let curArg = arguments[0];
                        curArg = conversions["USVString"](curArg, {
                            context: "Failed to execute 'send' on 'WebSocket': parameter 1",
                            globals: globalObject
                        });
                        args.push(curArg);
                    }
                }
            }
            return esValue[implSymbol].send(...args);
        }
        get url() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get url' called on an object that is not a valid instance of WebSocket.");
            }
            return esValue[implSymbol]["url"];
        }
        get readyState() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get readyState' called on an object that is not a valid instance of WebSocket.");
            }
            return esValue[implSymbol]["readyState"];
        }
        get bufferedAmount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bufferedAmount' called on an object that is not a valid instance of WebSocket.");
            }
            return esValue[implSymbol]["bufferedAmount"];
        }
        get onopen() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onopen' called on an object that is not a valid instance of WebSocket.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onopen"]);
        }
        set onopen(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onopen' called on an object that is not a valid instance of WebSocket.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onopen' property on 'WebSocket': The provided value"
                });
            }
            esValue[implSymbol]["onopen"] = V;
        }
        get onerror() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onerror' called on an object that is not a valid instance of WebSocket.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onerror"]);
        }
        set onerror(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onerror' called on an object that is not a valid instance of WebSocket.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onerror' property on 'WebSocket': The provided value"
                });
            }
            esValue[implSymbol]["onerror"] = V;
        }
        get onclose() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onclose' called on an object that is not a valid instance of WebSocket.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onclose"]);
        }
        set onclose(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onclose' called on an object that is not a valid instance of WebSocket.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onclose' property on 'WebSocket': The provided value"
                });
            }
            esValue[implSymbol]["onclose"] = V;
        }
        get extensions() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get extensions' called on an object that is not a valid instance of WebSocket.");
            }
            return esValue[implSymbol]["extensions"];
        }
        get protocol() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of WebSocket.");
            }
            return esValue[implSymbol]["protocol"];
        }
        get onmessage() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get onmessage' called on an object that is not a valid instance of WebSocket.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["onmessage"]);
        }
        set onmessage(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set onmessage' called on an object that is not a valid instance of WebSocket.");
            }
            if (!utils.isObject(V)) {
                V = null;
            } else {
                V = EventHandlerNonNull.convert(globalObject, V, {
                    context: "Failed to set the 'onmessage' property on 'WebSocket': The provided value"
                });
            }
            esValue[implSymbol]["onmessage"] = V;
        }
        get binaryType() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get binaryType' called on an object that is not a valid instance of WebSocket.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["binaryType"]);
        }
        set binaryType(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set binaryType' called on an object that is not a valid instance of WebSocket.");
            }
            V = `${V}`;
            if (!BinaryType.enumerationValues.has(V)) {
                return;
            }
            esValue[implSymbol]["binaryType"] = V;
        }
    }
    Object.defineProperties(WebSocket.prototype, {
        close: {
            enumerable: true
        },
        send: {
            enumerable: true
        },
        url: {
            enumerable: true
        },
        readyState: {
            enumerable: true
        },
        bufferedAmount: {
            enumerable: true
        },
        onopen: {
            enumerable: true
        },
        onerror: {
            enumerable: true
        },
        onclose: {
            enumerable: true
        },
        extensions: {
            enumerable: true
        },
        protocol: {
            enumerable: true
        },
        onmessage: {
            enumerable: true
        },
        binaryType: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "WebSocket",
            configurable: true
        },
        CONNECTING: {
            value: 0,
            enumerable: true
        },
        OPEN: {
            value: 1,
            enumerable: true
        },
        CLOSING: {
            value: 2,
            enumerable: true
        },
        CLOSED: {
            value: 3,
            enumerable: true
        }
    });
    Object.defineProperties(WebSocket, {
        CONNECTING: {
            value: 0,
            enumerable: true
        },
        OPEN: {
            value: 1,
            enumerable: true
        },
        CLOSING: {
            value: 2,
            enumerable: true
        },
        CLOSED: {
            value: 3,
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = WebSocket;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: WebSocket
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/websockets/WebSocket-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/StaticRangeInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "endContainer";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = Node.convert(globalObject, value, {
                context: context + " has member 'endContainer' that"
            });
            ret[key] = value;
        } else {
            throw new globalObject.TypeError("endContainer is required in 'StaticRangeInit'");
        }
    }
    {
        const key = "endOffset";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'endOffset' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            throw new globalObject.TypeError("endOffset is required in 'StaticRangeInit'");
        }
    }
    {
        const key = "startContainer";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = Node.convert(globalObject, value, {
                context: context + " has member 'startContainer' that"
            });
            ret[key] = value;
        } else {
            throw new globalObject.TypeError("startContainer is required in 'StaticRangeInit'");
        }
    }
    {
        const key = "startOffset";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unsigned long"](value, {
                context: context + " has member 'startOffset' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            throw new globalObject.TypeError("startOffset is required in 'StaticRangeInit'");
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/StaticRange.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const StaticRangeInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/StaticRangeInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const AbstractRange = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/AbstractRange.js [middleware-edge] (ecmascript)");
const interfaceName = "StaticRange";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'StaticRange'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["StaticRange"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    AbstractRange._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class StaticRange extends globalObject.AbstractRange {
        constructor(init){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'StaticRange': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = StaticRangeInit.convert(globalObject, curArg, {
                    context: "Failed to construct 'StaticRange': parameter 1"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
    }
    Object.defineProperties(StaticRange.prototype, {
        [Symbol.toStringTag]: {
            value: "StaticRange",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = StaticRange;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: StaticRange
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/range/StaticRange-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Selection.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Range.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Selection";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Selection'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Selection"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Selection {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        getRangeAt(index) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getRangeAt' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'getRangeAt' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'getRangeAt' on 'Selection': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getRangeAt(...args));
        }
        addRange(range) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'addRange' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'addRange' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Range.convert(globalObject, curArg, {
                    context: "Failed to execute 'addRange' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].addRange(...args);
        }
        removeRange(range) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeRange' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'removeRange' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Range.convert(globalObject, curArg, {
                    context: "Failed to execute 'removeRange' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].removeRange(...args);
        }
        removeAllRanges() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'removeAllRanges' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol].removeAllRanges();
        }
        empty() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'empty' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol].empty();
        }
        collapse(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'collapse' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'collapse' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = Node.convert(globalObject, curArg, {
                        context: "Failed to execute 'collapse' on 'Selection': parameter 1"
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["unsigned long"](curArg, {
                        context: "Failed to execute 'collapse' on 'Selection': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].collapse(...args);
        }
        setPosition(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setPosition' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'setPosition' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg === null || curArg === undefined) {
                    curArg = null;
                } else {
                    curArg = Node.convert(globalObject, curArg, {
                        context: "Failed to execute 'setPosition' on 'Selection': parameter 1"
                    });
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["unsigned long"](curArg, {
                        context: "Failed to execute 'setPosition' on 'Selection': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].setPosition(...args);
        }
        collapseToStart() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'collapseToStart' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol].collapseToStart();
        }
        collapseToEnd() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'collapseToEnd' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol].collapseToEnd();
        }
        extend(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'extend' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'extend' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'extend' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["unsigned long"](curArg, {
                        context: "Failed to execute 'extend' on 'Selection': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].extend(...args);
        }
        setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'setBaseAndExtent' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 4) {
                throw new globalObject.TypeError(`Failed to execute 'setBaseAndExtent' on 'Selection': 4 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setBaseAndExtent' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setBaseAndExtent' on 'Selection': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'setBaseAndExtent' on 'Selection': parameter 3"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                curArg = conversions["unsigned long"](curArg, {
                    context: "Failed to execute 'setBaseAndExtent' on 'Selection': parameter 4",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].setBaseAndExtent(...args);
        }
        selectAllChildren(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'selectAllChildren' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'selectAllChildren' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'selectAllChildren' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].selectAllChildren(...args);
        }
        deleteFromDocument() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'deleteFromDocument' called on an object that is not a valid instance of Selection.");
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].deleteFromDocument();
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        containsNode(node) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'containsNode' called on an object that is not a valid instance of Selection.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'containsNode' on 'Selection': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'containsNode' on 'Selection': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["boolean"](curArg, {
                        context: "Failed to execute 'containsNode' on 'Selection': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = false;
                }
                args.push(curArg);
            }
            return esValue[implSymbol].containsNode(...args);
        }
        toString() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol].toString();
        }
        get anchorNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get anchorNode' called on an object that is not a valid instance of Selection.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["anchorNode"]);
        }
        get anchorOffset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get anchorOffset' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol]["anchorOffset"];
        }
        get focusNode() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get focusNode' called on an object that is not a valid instance of Selection.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol]["focusNode"]);
        }
        get focusOffset() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get focusOffset' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol]["focusOffset"];
        }
        get isCollapsed() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get isCollapsed' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol]["isCollapsed"];
        }
        get rangeCount() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get rangeCount' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol]["rangeCount"];
        }
        get type() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get type' called on an object that is not a valid instance of Selection.");
            }
            return esValue[implSymbol]["type"];
        }
    }
    Object.defineProperties(Selection.prototype, {
        getRangeAt: {
            enumerable: true
        },
        addRange: {
            enumerable: true
        },
        removeRange: {
            enumerable: true
        },
        removeAllRanges: {
            enumerable: true
        },
        empty: {
            enumerable: true
        },
        collapse: {
            enumerable: true
        },
        setPosition: {
            enumerable: true
        },
        collapseToStart: {
            enumerable: true
        },
        collapseToEnd: {
            enumerable: true
        },
        extend: {
            enumerable: true
        },
        setBaseAndExtent: {
            enumerable: true
        },
        selectAllChildren: {
            enumerable: true
        },
        deleteFromDocument: {
            enumerable: true
        },
        containsNode: {
            enumerable: true
        },
        toString: {
            enumerable: true
        },
        anchorNode: {
            enumerable: true
        },
        anchorOffset: {
            enumerable: true
        },
        focusNode: {
            enumerable: true
        },
        focusOffset: {
            enumerable: true
        },
        isCollapsed: {
            enumerable: true
        },
        rangeCount: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Selection",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = Selection;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Selection
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/selection/Selection-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomElementConstructor.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction() {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        callResult = Reflect.apply(value, thisArg, []);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    }
    invokeTheCallbackFunction.construct = ()=>{
        let callResult = Reflect.construct(value, []);
        callResult = conversions["any"](callResult, {
            context: context,
            globals: globalObject
        });
        return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/ElementDefinitionOptions.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "extends";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["DOMString"](value, {
                context: context + " has member 'extends' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomElementRegistry.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const CustomElementConstructor = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/CustomElementConstructor.js [middleware-edge] (ecmascript)");
const ElementDefinitionOptions = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/ElementDefinitionOptions.js [middleware-edge] (ecmascript)");
const ceReactionsPreSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/helpers/custom-elements.js [middleware-edge] (ecmascript)").ceReactionsPostSteps;
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "CustomElementRegistry";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'CustomElementRegistry'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["CustomElementRegistry"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class CustomElementRegistry {
        constructor(){
            throw new globalObject.TypeError("Illegal constructor");
        }
        define(name, constructor) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'define' called on an object that is not a valid instance of CustomElementRegistry.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'define' on 'CustomElementRegistry': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'define' on 'CustomElementRegistry': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = CustomElementConstructor.convert(globalObject, curArg, {
                    context: "Failed to execute 'define' on 'CustomElementRegistry': parameter 2"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                curArg = ElementDefinitionOptions.convert(globalObject, curArg, {
                    context: "Failed to execute 'define' on 'CustomElementRegistry': parameter 3"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].define(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
        get(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get' called on an object that is not a valid instance of CustomElementRegistry.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'get' on 'CustomElementRegistry': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["DOMString"](curArg, {
                    context: "Failed to execute 'get' on 'CustomElementRegistry': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].get(...args);
        }
        whenDefined(name) {
            try {
                const esValue = this !== null && this !== undefined ? this : globalObject;
                if (!exports.is(esValue)) {
                    throw new globalObject.TypeError("'whenDefined' called on an object that is not a valid instance of CustomElementRegistry.");
                }
                if (arguments.length < 1) {
                    throw new globalObject.TypeError(`Failed to execute 'whenDefined' on 'CustomElementRegistry': 1 argument required, but only ${arguments.length} present.`);
                }
                const args = [];
                {
                    let curArg = arguments[0];
                    curArg = conversions["DOMString"](curArg, {
                        context: "Failed to execute 'whenDefined' on 'CustomElementRegistry': parameter 1",
                        globals: globalObject
                    });
                    args.push(curArg);
                }
                return utils.tryWrapperForImpl(esValue[implSymbol].whenDefined(...args));
            } catch (e) {
                return globalObject.Promise.reject(e);
            }
        }
        upgrade(root) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'upgrade' called on an object that is not a valid instance of CustomElementRegistry.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'upgrade' on 'CustomElementRegistry': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'upgrade' on 'CustomElementRegistry': parameter 1"
                });
                args.push(curArg);
            }
            ceReactionsPreSteps_helpers_custom_elements(globalObject);
            try {
                return esValue[implSymbol].upgrade(...args);
            } finally{
                ceReactionsPostSteps_helpers_custom_elements(globalObject);
            }
        }
    }
    Object.defineProperties(CustomElementRegistry.prototype, {
        define: {
            enumerable: true
        },
        get: {
            enumerable: true
        },
        whenDefined: {
            enumerable: true
        },
        upgrade: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "CustomElementRegistry",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = CustomElementRegistry;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: CustomElementRegistry
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/custom-elements/CustomElementRegistry-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationCallback.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(mutations, observer) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        mutations = utils.tryWrapperForImpl(mutations);
        observer = utils.tryWrapperForImpl(observer);
        callResult = Reflect.apply(value, thisArg, [
            mutations,
            observer
        ]);
    }
    invokeTheCallbackFunction.construct = (mutations, observer)=>{
        mutations = utils.tryWrapperForImpl(mutations);
        observer = utils.tryWrapperForImpl(observer);
        let callResult = Reflect.construct(value, [
            mutations,
            observer
        ]);
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationObserverInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "attributeFilter";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            if (!utils.isObject(value)) {
                throw new globalObject.TypeError(context + " has member 'attributeFilter' that" + " is not an iterable object.");
            } else {
                const V = [];
                const tmp = value;
                for (let nextItem of tmp){
                    nextItem = conversions["DOMString"](nextItem, {
                        context: context + " has member 'attributeFilter' that" + "'s element",
                        globals: globalObject
                    });
                    V.push(nextItem);
                }
                value = V;
            }
            ret[key] = value;
        }
    }
    {
        const key = "attributeOldValue";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'attributeOldValue' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
    {
        const key = "attributes";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'attributes' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
    {
        const key = "characterData";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'characterData' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
    {
        const key = "characterDataOldValue";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'characterDataOldValue' that",
                globals: globalObject
            });
            ret[key] = value;
        }
    }
    {
        const key = "childList";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'childList' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
    {
        const key = "subtree";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["boolean"](value, {
                context: context + " has member 'subtree' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = false;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationObserver.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const MutationCallback = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationCallback.js [middleware-edge] (ecmascript)");
const Node = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Node.js [middleware-edge] (ecmascript)");
const MutationObserverInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/MutationObserverInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "MutationObserver";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'MutationObserver'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["MutationObserver"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class MutationObserver {
        constructor(callback){
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to construct 'MutationObserver': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = MutationCallback.convert(globalObject, curArg, {
                    context: "Failed to construct 'MutationObserver': parameter 1"
                });
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        observe(target) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'observe' called on an object that is not a valid instance of MutationObserver.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'observe' on 'MutationObserver': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = Node.convert(globalObject, curArg, {
                    context: "Failed to execute 'observe' on 'MutationObserver': parameter 1"
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = MutationObserverInit.convert(globalObject, curArg, {
                    context: "Failed to execute 'observe' on 'MutationObserver': parameter 2"
                });
                args.push(curArg);
            }
            return esValue[implSymbol].observe(...args);
        }
        disconnect() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'disconnect' called on an object that is not a valid instance of MutationObserver.");
            }
            return esValue[implSymbol].disconnect();
        }
        takeRecords() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'takeRecords' called on an object that is not a valid instance of MutationObserver.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].takeRecords());
        }
    }
    Object.defineProperties(MutationObserver.prototype, {
        observe: {
            enumerable: true
        },
        disconnect: {
            enumerable: true
        },
        takeRecords: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "MutationObserver",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = MutationObserver;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: MutationObserver
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/mutation-observer/MutationObserver-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/Headers.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const Function = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/Function.js [middleware-edge] (ecmascript)");
const newObjectInRealm = utils.newObjectInRealm;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "Headers";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'Headers'.`);
};
exports.createDefaultIterator = (globalObject, target, kind)=>{
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["Headers Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils.iterInternalSymbol, {
        value: {
            target,
            kind,
            index: 0
        },
        configurable: true
    });
    return iterator;
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["Headers"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class Headers {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    if (utils.isObject(curArg)) {
                        if (curArg[Symbol.iterator] !== undefined) {
                            if (!utils.isObject(curArg)) {
                                throw new globalObject.TypeError("Failed to construct 'Headers': parameter 1" + " sequence" + " is not an iterable object.");
                            } else {
                                const V = [];
                                const tmp = curArg;
                                for (let nextItem of tmp){
                                    if (!utils.isObject(nextItem)) {
                                        throw new globalObject.TypeError("Failed to construct 'Headers': parameter 1" + " sequence" + "'s element" + " is not an iterable object.");
                                    } else {
                                        const V = [];
                                        const tmp = nextItem;
                                        for (let nextItem of tmp){
                                            nextItem = conversions["ByteString"](nextItem, {
                                                context: "Failed to construct 'Headers': parameter 1" + " sequence" + "'s element" + "'s element",
                                                globals: globalObject
                                            });
                                            V.push(nextItem);
                                        }
                                        nextItem = V;
                                    }
                                    V.push(nextItem);
                                }
                                curArg = V;
                            }
                        } else {
                            if (!utils.isObject(curArg)) {
                                throw new globalObject.TypeError("Failed to construct 'Headers': parameter 1" + " record" + " is not an object.");
                            } else {
                                const result = Object.create(null);
                                for (const key of Reflect.ownKeys(curArg)){
                                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                                    if (desc && desc.enumerable) {
                                        let typedKey = key;
                                        typedKey = conversions["ByteString"](typedKey, {
                                            context: "Failed to construct 'Headers': parameter 1" + " record" + "'s key",
                                            globals: globalObject
                                        });
                                        let typedValue = curArg[key];
                                        typedValue = conversions["ByteString"](typedValue, {
                                            context: "Failed to construct 'Headers': parameter 1" + " record" + "'s value",
                                            globals: globalObject
                                        });
                                        result[typedKey] = typedValue;
                                    }
                                }
                                curArg = result;
                            }
                        }
                    } else {
                        throw new globalObject.TypeError("Failed to construct 'Headers': parameter 1" + " is not of any supported type.");
                    }
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'append' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'append' on 'Headers': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'append' on 'Headers': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].append(...args);
        }
        delete(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'delete' on 'Headers': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].delete(...args);
        }
        get(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'get' on 'Headers': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].get(...args);
        }
        getSetCookie() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'getSetCookie' called on an object that is not a valid instance of Headers.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getSetCookie());
        }
        has(name) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'has' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'has' on 'Headers': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].has(...args);
        }
        set(name, value) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 2) {
                throw new globalObject.TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);
            }
            const args = [];
            {
                let curArg = arguments[0];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'set' on 'Headers': parameter 1",
                    globals: globalObject
                });
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                curArg = conversions["ByteString"](curArg, {
                    context: "Failed to execute 'set' on 'Headers': parameter 2",
                    globals: globalObject
                });
                args.push(curArg);
            }
            return esValue[implSymbol].set(...args);
        }
        keys() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of Headers.");
            }
            return exports.createDefaultIterator(globalObject, this, "key");
        }
        values() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'values' called on an object that is not a valid instance of Headers.");
            }
            return exports.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of Headers.");
            }
            return exports.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
            if (!exports.is(this)) {
                throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of Headers.");
            }
            if (arguments.length < 1) {
                throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
            }
            callback = Function.convert(globalObject, callback, {
                context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
            });
            const thisArg = arguments[1];
            let pairs = Array.from(this[implSymbol]);
            let i = 0;
            while(i < pairs.length){
                const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
                callback.call(thisArg, value, key, this);
                pairs = Array.from(this[implSymbol]);
                i++;
            }
        }
    }
    Object.defineProperties(Headers.prototype, {
        append: {
            enumerable: true
        },
        delete: {
            enumerable: true
        },
        get: {
            enumerable: true
        },
        getSetCookie: {
            enumerable: true
        },
        has: {
            enumerable: true
        },
        set: {
            enumerable: true
        },
        keys: {
            enumerable: true
        },
        values: {
            enumerable: true
        },
        entries: {
            enumerable: true
        },
        forEach: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "Headers",
            configurable: true
        },
        [Symbol.iterator]: {
            value: Headers.prototype.entries,
            configurable: true,
            writable: true
        }
    });
    ctorRegistry[interfaceName] = Headers;
    ctorRegistry["Headers Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
            configurable: true,
            value: "Headers Iterator"
        }
    });
    utils.define(ctorRegistry["Headers Iterator"], {
        next () {
            const internal = this && this[utils.iterInternalSymbol];
            if (!internal) {
                throw new globalObject.TypeError("next() called on a value that is not a Headers iterator object");
            }
            const { target, kind, index } = internal;
            const values = Array.from(target[implSymbol]);
            const len = values.length;
            if (index >= len) {
                return newObjectInRealm(globalObject, {
                    value: undefined,
                    done: true
                });
            }
            const pair = values[index];
            internal.index = index + 1;
            return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
        }
    });
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: Headers
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/fetch/Headers-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/AbortController.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "AbortController";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'AbortController'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["AbortController"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class AbortController {
        constructor(){
            return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
        }
        abort() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'abort' called on an object that is not a valid instance of AbortController.");
            }
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["any"](curArg, {
                        context: "Failed to execute 'abort' on 'AbortController': parameter 1",
                        globals: globalObject
                    });
                }
                args.push(curArg);
            }
            return esValue[implSymbol].abort(...args);
        }
        get signal() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get signal' called on an object that is not a valid instance of AbortController.");
            }
            return utils.getSameObject(this, "signal", ()=>{
                return utils.tryWrapperForImpl(esValue[implSymbol]["signal"]);
            });
        }
    }
    Object.defineProperties(AbortController.prototype, {
        abort: {
            enumerable: true
        },
        signal: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "AbortController",
            configurable: true
        }
    });
    ctorRegistry[interfaceName] = AbortController;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: AbortController
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/aborting/AbortController-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRectInit.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
exports._convertInherit = (globalObject, obj, ret, { context = "The provided value" } = {})=>{
    {
        const key = "height";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unrestricted double"](value, {
                context: context + " has member 'height' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "width";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unrestricted double"](value, {
                context: context + " has member 'width' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "x";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unrestricted double"](value, {
                context: context + " has member 'x' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
    {
        const key = "y";
        let value = obj === undefined || obj === null ? undefined : obj[key];
        if (value !== undefined) {
            value = conversions["unrestricted double"](value, {
                context: context + " has member 'y' that",
                globals: globalObject
            });
            ret[key] = value;
        } else {
            ret[key] = 0;
        }
    }
};
exports.convert = (globalObject, obj, { context = "The provided value" } = {})=>{
    if (obj !== undefined && typeof obj !== "object" && typeof obj !== "function") {
        throw new globalObject.TypeError(`${context} is not an object.`);
    }
    const ret = Object.create(null);
    exports._convertInherit(globalObject, obj, ret, {
        context
    });
    return ret;
};
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRectReadOnly.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const DOMRectInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRectInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const interfaceName = "DOMRectReadOnly";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMRectReadOnly'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMRectReadOnly"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMRectReadOnly {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRectReadOnly': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRectReadOnly': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRectReadOnly': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRectReadOnly': parameter 4",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        toJSON() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol].toJSON();
        }
        get x() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get x' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["x"];
        }
        get y() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get y' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["y"];
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["width"];
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["height"];
        }
        get top() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get top' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["top"];
        }
        get right() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get right' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["right"];
        }
        get bottom() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get bottom' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["bottom"];
        }
        get left() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get left' called on an object that is not a valid instance of DOMRectReadOnly.");
            }
            return esValue[implSymbol]["left"];
        }
        static fromRect() {
            const args = [];
            {
                let curArg = arguments[0];
                curArg = DOMRectInit.convert(globalObject, curArg, {
                    context: "Failed to execute 'fromRect' on 'DOMRectReadOnly': parameter 1"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.fromRect(globalObject, ...args));
        }
    }
    Object.defineProperties(DOMRectReadOnly.prototype, {
        toJSON: {
            enumerable: true
        },
        x: {
            enumerable: true
        },
        y: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        top: {
            enumerable: true
        },
        right: {
            enumerable: true
        },
        bottom: {
            enumerable: true
        },
        left: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMRectReadOnly",
            configurable: true
        }
    });
    Object.defineProperties(DOMRectReadOnly, {
        fromRect: {
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = DOMRectReadOnly;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMRectReadOnly
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/geometry/DOMRectReadOnly-impl.js [middleware-edge] (ecmascript)");
}}),
"[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRect.js [middleware-edge] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const conversions = __turbopack_context__.r("[project]/node_modules/webidl-conversions/lib/index.js [middleware-edge] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/utils.js [middleware-edge] (ecmascript)");
const DOMRectInit = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRectInit.js [middleware-edge] (ecmascript)");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const DOMRectReadOnly = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/generated/DOMRectReadOnly.js [middleware-edge] (ecmascript)");
const interfaceName = "DOMRect";
exports.is = (value)=>{
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = (value)=>{
    return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = "The provided value" } = {})=>{
    if (exports.is(value)) {
        return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'DOMRect'.`);
};
function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
        proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["DOMRect"].prototype;
    }
    return Object.create(proto);
}
exports.create = (globalObject, constructorArgs, privateData)=>{
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};
exports.createImpl = (globalObject, constructorArgs, privateData)=>{
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
};
exports._internalSetup = (wrapper, globalObject)=>{
    DOMRectReadOnly._internalSetup(wrapper, globalObject);
};
exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {})=>{
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
};
exports.new = (globalObject, newTarget)=>{
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
};
const exposed = new Set([
    "Window",
    "Worker"
]);
exports.install = (globalObject, globalNames)=>{
    if (!globalNames.some((globalName)=>exposed.has(globalName))) {
        return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);
    class DOMRect extends globalObject.DOMRectReadOnly {
        constructor(){
            const args = [];
            {
                let curArg = arguments[0];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRect': parameter 1",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRect': parameter 2",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[2];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRect': parameter 3",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            {
                let curArg = arguments[3];
                if (curArg !== undefined) {
                    curArg = conversions["unrestricted double"](curArg, {
                        context: "Failed to construct 'DOMRect': parameter 4",
                        globals: globalObject
                    });
                } else {
                    curArg = 0;
                }
                args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        get x() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get x' called on an object that is not a valid instance of DOMRect.");
            }
            return esValue[implSymbol]["x"];
        }
        set x(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set x' called on an object that is not a valid instance of DOMRect.");
            }
            V = conversions["unrestricted double"](V, {
                context: "Failed to set the 'x' property on 'DOMRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["x"] = V;
        }
        get y() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get y' called on an object that is not a valid instance of DOMRect.");
            }
            return esValue[implSymbol]["y"];
        }
        set y(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set y' called on an object that is not a valid instance of DOMRect.");
            }
            V = conversions["unrestricted double"](V, {
                context: "Failed to set the 'y' property on 'DOMRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["y"] = V;
        }
        get width() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get width' called on an object that is not a valid instance of DOMRect.");
            }
            return esValue[implSymbol]["width"];
        }
        set width(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set width' called on an object that is not a valid instance of DOMRect.");
            }
            V = conversions["unrestricted double"](V, {
                context: "Failed to set the 'width' property on 'DOMRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["width"] = V;
        }
        get height() {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'get height' called on an object that is not a valid instance of DOMRect.");
            }
            return esValue[implSymbol]["height"];
        }
        set height(V) {
            const esValue = this !== null && this !== undefined ? this : globalObject;
            if (!exports.is(esValue)) {
                throw new globalObject.TypeError("'set height' called on an object that is not a valid instance of DOMRect.");
            }
            V = conversions["unrestricted double"](V, {
                context: "Failed to set the 'height' property on 'DOMRect': The provided value",
                globals: globalObject
            });
            esValue[implSymbol]["height"] = V;
        }
        static fromRect() {
            const args = [];
            {
                let curArg = arguments[0];
                curArg = DOMRectInit.convert(globalObject, curArg, {
                    context: "Failed to execute 'fromRect' on 'DOMRect': parameter 1"
                });
                args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.fromRect(globalObject, ...args));
        }
    }
    Object.defineProperties(DOMRect.prototype, {
        x: {
            enumerable: true
        },
        y: {
            enumerable: true
        },
        width: {
            enumerable: true
        },
        height: {
            enumerable: true
        },
        [Symbol.toStringTag]: {
            value: "DOMRect",
            configurable: true
        }
    });
    Object.defineProperties(DOMRect, {
        fromRect: {
            enumerable: true
        }
    });
    ctorRegistry[interfaceName] = DOMRect;
    Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: DOMRect
    });
};
const Impl = __turbopack_context__.r("[project]/node_modules/jsdom/lib/jsdom/living/geometry/DOMRect-impl.js [middleware-edge] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_jsdom_lib_jsdom_living_generated_149ba895._.js.map